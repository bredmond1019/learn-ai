# Advanced Workflows

Claude Code's true power emerges when you adopt advanced workflows that leverage its AI capabilities strategically. In this module, we'll explore Test-Driven Development with Claude, master Plan Mode, optimize memory management, and harness parallel sessions.

## Learning Objectives

By the end of this module, you'll be able to:
- Implement Test-Driven Development (TDD) with Claude as your pair programmer
- Use Plan Mode to break down complex tasks systematically
- Manage Claude's memory effectively for long sessions
- Run parallel Claude sessions for concurrent development tasks

## Test-Driven Development with Claude

TDD with Claude transforms the red-green-refactor cycle into a collaborative process where Claude helps write both tests and implementations.

### The Claude-Enhanced TDD Cycle

<CodeExample language="bash">
# Traditional TDD
# 1. Write failing test
# 2. Write minimal code to pass
# 3. Refactor

# Claude-Enhanced TDD
# 1. Describe the feature to Claude
$ claude "I need a function that validates email addresses according to RFC 5322"

# 2. Claude writes comprehensive tests
$ claude "write comprehensive tests for the email validator, including edge cases"

# 3. Run tests (they fail)
$ npm test -- email.test.js

# 4. Claude implements the solution
$ claude "implement the email validator to pass all tests"

# 5. Refactor together
$ claude "refactor this implementation for better performance while maintaining test coverage"
</CodeExample>

### Real-World TDD Example

Let's build a rate limiter using TDD with Claude:

<CodeExample language="bash">
# Step 1: Describe requirements
$ claude "I need a rate limiter that allows 10 requests per minute per IP, with Redis backing"

# Claude responds with test structure
$ claude "write comprehensive tests for this rate limiter" > test/rateLimiter.test.js
</CodeExample>

<CodeExample language="javascript">
// test/rateLimiter.test.js (generated by Claude)
describe('RateLimiter', () => {
  let rateLimiter;
  let redisClient;

  beforeEach(() => {
    redisClient = createMockRedis();
    rateLimiter = new RateLimiter(redisClient, {
      windowMs: 60000, // 1 minute
      max: 10
    });
  });

  describe('allow()', () => {
    it('should allow first request', async () => {
      const result = await rateLimiter.allow('192.168.1.1');
      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(9);
    });

    it('should block after limit exceeded', async () => {
      const ip = '192.168.1.1';
      
      // Make 10 requests
      for (let i = 0; i < 10; i++) {
        await rateLimiter.allow(ip);
      }
      
      // 11th request should be blocked
      const result = await rateLimiter.allow(ip);
      expect(result.allowed).toBe(false);
      expect(result.retryAfter).toBeGreaterThan(0);
    });

    it('should reset after time window', async () => {
      const ip = '192.168.1.1';
      
      // Exhaust limit
      for (let i = 0; i < 10; i++) {
        await rateLimiter.allow(ip);
      }
      
      // Fast-forward time
      jest.advanceTimersByTime(61000);
      
      // Should allow again
      const result = await rateLimiter.allow(ip);
      expect(result.allowed).toBe(true);
    });
  });
});
</CodeExample>

<CodeExample language="bash">
# Step 2: Run tests (they fail)
$ npm test -- rateLimiter.test.js
# FAIL: RateLimiter is not defined

# Step 3: Ask Claude to implement
$ claude "implement the RateLimiter class to pass all tests" > src/rateLimiter.js

# Step 4: Tests pass!
$ npm test -- rateLimiter.test.js
# PASS: All tests passing

# Step 5: Enhance with Claude
$ claude "add distributed rate limiting support to handle multiple server instances"
</CodeExample>

### TDD Best Practices with Claude

<Callout type="best-practice">
Claude excels at generating comprehensive test cases, including edge cases you might miss. Always review and enhance the generated tests.
</Callout>

1. **Test First, Always**: Ask Claude for tests before implementation
2. **Edge Case Discovery**: "What edge cases should I test for this function?"
3. **Test Refactoring**: "How can I make these tests more maintainable?"
4. **Coverage Analysis**: "What test cases am I missing for full coverage?"

## Plan Mode: Strategic Task Decomposition

Plan Mode transforms Claude from a coding assistant into a strategic planning partner. It's perfect for complex, multi-step tasks.

### Activating Plan Mode

<CodeExample language="bash">
# In terminal
$ claude --plan "migrate our monolithic API to microservices"

# In chat
"I need to refactor our authentication system. Let's plan this out first."
# Claude automatically enters planning mode for complex tasks
</CodeExample>

### Plan Mode in Action

Here's how Claude breaks down a complex migration:

<CodeExample language="markdown">
## Migration Plan: Monolith to Microservices

### Phase 1: Analysis (Week 1)
- [ ] Identify bounded contexts in current monolith
- [ ] Map data dependencies between modules
- [ ] Document API contracts between components
- [ ] Analyze database coupling points

### Phase 2: Preparation (Week 2)
- [ ] Set up service discovery infrastructure
- [ ] Implement distributed tracing
- [ ] Create service communication layer
- [ ] Set up CI/CD pipelines for services

### Phase 3: Extraction (Weeks 3-6)
#### Service 1: User Authentication
- [ ] Extract auth logic to standalone service
- [ ] Implement JWT token management
- [ ] Create auth service API
- [ ] Update monolith to use auth service

#### Service 2: Payment Processing
- [ ] Isolate payment logic
- [ ] Implement payment service with Stripe/PayPal
- [ ] Handle distributed transactions
- [ ] Implement saga pattern for failures

### Phase 4: Data Migration (Week 7)
- [ ] Split shared database
- [ ] Implement event sourcing for data sync
- [ ] Set up database-per-service pattern
- [ ] Implement CQRS where needed

### Phase 5: Cutover (Week 8)
- [ ] Progressive rollout with feature flags
- [ ] Monitor service health metrics
- [ ] Implement circuit breakers
- [ ] Full cutover and monolith decommission
</CodeExample>

### Advanced Plan Mode Techniques

<CodeExample language="bash">
# Hierarchical Planning
$ claude --plan "build a real-time collaboration feature"
# Claude creates main plan

$ claude --plan "elaborate on Phase 2: WebSocket implementation"
# Claude expands specific phase

# Risk-Aware Planning
$ claude --plan "migrate to new payment provider" --consider-risks
# Claude includes risk mitigation strategies

# Time-Boxed Planning
$ claude --plan "optimize database performance" --timeline="2 weeks"
# Claude creates realistic timeline

# Dependency-Aware Planning
$ claude --plan "upgrade to React 18" --show-dependencies
# Claude maps out all dependencies and order of operations
</CodeExample>

### Plan Validation

<CodeExample language="bash">
# Have Claude review its own plan
$ claude "review this migration plan for potential issues or missing steps"

# Get alternative approaches
$ claude "suggest alternative approaches to this plan"

# Estimate effort
$ claude "estimate developer-hours for each phase of this plan"
</CodeExample>

## Memory Management Strategies

Claude's context window is powerful but finite. Effective memory management ensures productive long sessions.

### Understanding Context Windows

<CodeExample language="bash">
# Check context usage
$ claude --status
# Context: 45,000 / 200,000 tokens used
# Files in context: 12
# Active memory markers: 3

# Clear context
$ claude --clear-context
# Context cleared. Ready for fresh session.

# Selective context
$ claude --only "src/api/*" "refactor the API layer"
# Only loads API-related files
</CodeExample>

### Memory Optimization Techniques

#### 1. Chunking Large Tasks

<CodeExample language="bash">
# Instead of:
$ claude "refactor the entire application for better performance"

# Do this:
$ claude "let's refactor in phases. First, analyze the current performance bottlenecks"
# Complete phase 1

$ claude --clear-context
$ claude "based on our analysis, let's optimize the database queries in src/db/"
# Complete phase 2

$ claude --clear-context  
$ claude "now let's optimize the API response caching"
# Complete phase 3
</CodeExample>

#### 2. Memory Markers

<CodeExample language="bash">
# Mark important context
$ claude --mark "Remember: we're using PostgreSQL 14 with these extensions: pgvector, pg_stat_statements"

# Reference markers later
$ claude "optimize this query (check our memory markers for DB details)"

# List markers
$ claude --list-markers
# 1. Database configuration
# 2. API rate limits
# 3. Deployment constraints
</CodeExample>

#### 3. Context Summarization

<CodeExample language="bash">
# Before clearing context
$ claude "summarize what we've accomplished and what's next"

# Save summary
$ claude --save-summary migration-progress.md

# Later, restore context
$ claude --from-summary migration-progress.md "continue with the next phase"
</CodeExample>

### Memory Management Patterns

<Callout type="pattern">
The "Checkpoint Pattern": Regularly save progress summaries and clear context to maintain performance over long sessions.
</Callout>

<CodeExample language="bash">
# Checkpoint Pattern Implementation
#!/bin/bash

# Function to create checkpoint
checkpoint() {
  local name=$1
  claude "summarize our progress and current state" > "checkpoints/${name}.md"
  claude --clear-context
  echo "Checkpoint saved: ${name}"
}

# Usage in long session
claude "start implementing the shopping cart feature"
# ... work for 30 minutes ...
checkpoint "cart-basic-implementation"

claude --from-summary "checkpoints/cart-basic-implementation.md" "add discount calculation"
# ... work for 30 minutes ...
checkpoint "cart-with-discounts"
</CodeExample>

## Parallel Claude Sessions

Maximize productivity by running multiple Claude sessions for different aspects of your project.

### Setting Up Parallel Sessions

<CodeExample language="bash">
# Terminal 1: Backend Development
$ cd backend
$ claude --session-name backend "implement the new API endpoints"

# Terminal 2: Frontend Development  
$ cd frontend
$ claude --session-name frontend "create React components for the new features"

# Terminal 3: Testing
$ cd tests
$ claude --session-name testing "write integration tests for the new features"

# Terminal 4: Documentation
$ cd docs
$ claude --session-name docs "update API documentation"
</CodeExample>

### Parallel Session Strategies

#### 1. Feature Development Pattern

<CodeExample language="bash">
# Main session: Architecture and planning
$ claude --session-name architect "design the notification system architecture"

# Parallel session 1: Backend implementation
$ claude --session-name backend "implement the notification service based on our architecture"

# Parallel session 2: Frontend implementation  
$ claude --session-name frontend "build the notification UI components"

# Parallel session 3: Real-time testing
$ claude --session-name test "test the notification system as we build"
</CodeExample>

#### 2. Refactoring Pattern

<CodeExample language="bash">
# Session 1: Identify refactoring targets
$ find . -name "*.js" -exec wc -l {} + | sort -rn | head -20 > large-files.txt
$ claude --session-name analyzer "analyze these large files for refactoring opportunities"

# Session 2: Refactor backend
$ claude --session-name backend-refactor "refactor the identified backend files"

# Session 3: Refactor frontend
$ claude --session-name frontend-refactor "refactor the identified frontend files"

# Session 4: Update tests
$ claude --session-name test-update "update tests affected by refactoring"
</CodeExample>

#### 3. Multi-Language Pattern

<CodeExample language="bash">
# When working with polyglot projects
# Session 1: Python ML service
$ cd ml-service
$ claude --session-name python "optimize the recommendation algorithm"

# Session 2: Go API Gateway
$ cd api-gateway  
$ claude --session-name go "implement rate limiting in the gateway"

# Session 3: React Frontend
$ cd web-app
$ claude --session-name react "integrate with the new ML endpoints"
</CodeExample>

### Session Coordination

<CodeExample language="bash">
# Create a coordination script
#!/bin/bash
# coordinate-sessions.sh

# Share context between sessions
claude --session-name backend --export-context > backend-context.json
claude --session-name frontend --import-context backend-context.json

# Synchronize checkpoints
for session in backend frontend testing docs; do
  claude --session-name $session "create checkpoint of current progress"
done

# Merge session outputs
claude --merge-sessions backend,frontend,testing "integrate all components"
</CodeExample>

<Quiz>
  <Question
    question="In TDD with Claude, what should you always ask for before implementation?"
    options={[
      "Performance benchmarks",
      "Comprehensive tests including edge cases",
      "Code style guidelines",
      "Database schemas"
    ]}
    correct={1}
    explanation="In TDD with Claude, always ask for comprehensive tests first. Claude excels at generating thorough test cases including edge cases you might miss."
  />
  
  <Question
    question="What command would you use to check Claude's context usage?"
    options={[
      "claude --memory",
      "claude --context-info",
      "claude --status",
      "claude --check-tokens"
    ]}
    correct={2}
    explanation="The --status flag shows current context usage, including tokens used, files in context, and active memory markers."
  />
  
  <Question
    question="What is the Checkpoint Pattern used for?"
    options={[
      "Creating database backups",
      "Saving progress and clearing context in long sessions",
      "Version control commits",
      "Testing deployments"
    ]}
    correct={1}
    explanation="The Checkpoint Pattern involves regularly saving progress summaries and clearing context to maintain performance over long coding sessions."
  />
  
  <Question
    question="When running parallel Claude sessions, what's the benefit of using --session-name?"
    options={[
      "It makes Claude work faster",
      "It allows context isolation between different tasks",
      "It's required for Claude to work",
      "It automatically syncs code between sessions"
    ]}
    correct={1}
    explanation="Using --session-name creates isolated contexts for different tasks, allowing you to work on multiple aspects of a project simultaneously without context pollution."
  />
</Quiz>

## Practical Exercise: Building a Feature with Advanced Workflows

Let's build a complete feature using all the advanced workflows we've learned.

### Scenario: Real-time Commenting System

Build a real-time commenting system with nested replies, reactions, and live updates.

<CodeExample language="bash">
# Step 1: Plan Mode
$ claude --plan "build a real-time commenting system with nested replies and reactions"

# Step 2: TDD Setup (Session 1)
$ claude --session-name tests "create comprehensive test suite for commenting system including:
- Comment CRUD operations
- Nested reply handling  
- Real-time WebSocket events
- Reaction management
- Permission checking"

# Step 3: Backend Implementation (Session 2)
$ cd backend
$ claude --session-name backend "implement the comment service to pass all tests"

# Step 4: Frontend Implementation (Session 3)
$ cd frontend
$ claude --session-name frontend "build React components for the commenting UI with optimistic updates"

# Step 5: Integration (Main Session)
$ claude "integrate the backend and frontend components, ensuring real-time updates work"

# Step 6: Memory Checkpoint
$ claude "summarize the commenting system implementation and remaining tasks" > checkpoints/comments-v1.md
$ claude --clear-context

# Step 7: Performance Optimization (Fresh Context)
$ claude --from-summary checkpoints/comments-v1.md "optimize the commenting system for 10k+ comments per post"
</CodeExample>

### Exercise Tasks

1. **TDD Challenge**: Use Claude to build a rate limiter with sliding window algorithm using pure TDD
2. **Plan Mode Project**: Plan a migration from REST to GraphQL API using Claude's planning capabilities  
3. **Memory Management**: Build a large feature using the checkpoint pattern, never exceeding 50% context usage
4. **Parallel Development**: Use 4 parallel sessions to build a full-stack feature with automatic session coordination

## Advanced Workflow Combinations

### The "Spike and Stabilize" Pattern

<CodeExample language="bash">
# Session 1: Rapid prototype
$ claude --session-name spike "quickly prototype a recommendation engine"

# Session 2: Write tests for the prototype
$ claude --session-name test "write tests for the spiked recommendation engine"

# Session 3: Refactor to production quality
$ claude --session-name refactor "refactor the prototype to pass all tests and meet production standards"
</CodeExample>

### The "Documentation-Driven Development" Pattern

<CodeExample language="bash">
# Start with documentation
$ claude "write comprehensive API documentation for a task management system"

# Generate tests from docs
$ claude "generate tests based on the API documentation"

# Implement to match docs
$ claude "implement the API to match the documentation and pass tests"
</CodeExample>

## Best Practices for Advanced Workflows

### TDD with Claude
- Always review generated tests for completeness
- Ask for edge cases explicitly
- Use Claude to refactor tests for maintainability
- Request performance tests when relevant

### Plan Mode
- Break large plans into phases
- Ask for alternative approaches
- Request risk analysis for critical paths
- Use hierarchical planning for complex projects

### Memory Management
- Monitor context usage regularly
- Create checkpoints before major transitions
- Use selective context loading
- Summarize before clearing

### Parallel Sessions
- Name sessions clearly by function
- Coordinate through shared checkpoints
- Use session export/import for context sharing
- Merge sessions for integration work

## Key Takeaways

1. **TDD Transformation**: Claude makes TDD faster and more thorough
2. **Strategic Planning**: Plan Mode turns complex tasks into manageable phases
3. **Memory Mastery**: Effective context management enables long productive sessions
4. **Parallel Power**: Multiple sessions multiply productivity
5. **Pattern Application**: Combine workflows for maximum effectiveness

## Next Steps

You've mastered advanced workflows that transform how you develop with Claude Code. In our final module, we'll explore building custom integrations with the Claude Code SDK.

<Callout type="preview">
**Coming Next**: Build custom tools, create Unix utilities, and extend Claude Code with your own integrations using the SDK.
</Callout>