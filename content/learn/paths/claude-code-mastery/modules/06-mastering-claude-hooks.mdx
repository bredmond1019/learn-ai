---
title: "Mastering Claude Hooks"
description: "Transform Claude Code into a proactive development partner"
duration: "2 hours"
difficulty: "intermediate"
objectives:
  - "Understand the five Claude hook events and when to use each"
  - "Implement safety controls to prevent dangerous operations"
  - "Build comprehensive observability with logging and monitoring"
  - "Create voice notifications for long-running tasks"
  - "Develop advanced hook patterns for parallel agents and complex workflows"
tags:
  - "hooks"
  - "automation"
  - "observability"
  - "Claude Code"
lastUpdated: "2025-01-11"
author: "Brandon J. Redmond"
---

import { CodeExample } from '@/components/claude-sdk/CodeEditor'
import { Callout } from '@/components/ui/callout'
import { Quiz } from '@/components/claude-sdk/Quiz'
import { Diagram } from '@/components/claude-sdk/Diagram'

# Mastering Claude Hooks

## Introduction {#introduction}

Picture this: It's 6 AM, you're in the flow with Claude Code, and suddenly your AI assistant decides that "the best code is no code" and starts deleting your entire codebase with `rm -rf` commands. Sound terrifying? This exact scenario is what Claude hooks were designed to prevent.

Claude hooks transform your AI coding assistant from a reactive tool into a proactive development partner that:
- Automatically runs tests and formatters
- Blocks dangerous operations before they execute
- Provides voice notifications for long-running tasks
- Generates comprehensive logs for debugging
- Coordinates parallel agent workflows

<Callout type="info">
  **Key Insight**: As IndyDevDan puts it: "As we push into the age of agents, we need observability to scale our impact." Hooks provide the observability and control necessary for truly agentic engineering.
</Callout>

### Why Hooks Matter

Traditional AI assistants write code, but then leave you to handle all the housekeeping:
- Running linters and formatters
- Executing test suites
- Checking for type errors
- Monitoring what the AI actually did
- Preventing dangerous operations

Hooks automate all of this and more, letting you focus on solving problems instead of babysitting your AI.

## Understanding Hook Events {#hook-events}

Claude Code provides five powerful hook events that fire at specific points in the AI's lifecycle:

### 1. PreToolUse - Your Safety Guardian

This hook fires **before** any tool runs, giving you the power to inspect and potentially block operations.

### Basic PreToolUse Hook

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": ".*",
      "hooks": [{
        "type": "command",
        "command": "python scripts/check_safety.py"
      }]
    }]
  }
}
```

**Common Use Cases:**
- Block dangerous commands (`rm -rf`, `sudo`, etc.)
- Require approval for sensitive operations
- Validate inputs before execution
- Set up environment prerequisites

### 2. PostToolUse - The Observer

Fires **after** a tool completes, perfect for logging and monitoring.

### Logging with PostToolUse

```json
{
  "PostToolUse": [{
    "matcher": "Edit|Write",
    "hooks": [{
      "type": "command",
      "command": "uv run scripts/log_changes.py"
    }]
  }]
}
```

**Common Use Cases:**
- Log all file modifications
- Track tool execution times
- Generate audit trails
- Trigger follow-up actions

### 3. Notification - Interactive Moments

Triggers when Claude needs your input or wants to notify you of something important.

### Voice Notification Hook

```json
{
  "Notification": [{
    "matcher": ".*",
    "hooks": [{
      "type": "command",
      "command": "echo 'Claude needs your attention' | say"
    }]
  }]
}
```

### 4. Stop - Session Complete

Executes when Claude finishes responding, ideal for cleanup and final actions.

### Save Chat Log on Stop

```json
{
  "Stop": [{
    "matcher": ".*",
    "hooks": [{
      "type": "command",
      "command": "python scripts/save_chat.py --format json"
    }]
  }]
}
```

### 5. SubagentStop - Parallel Processing

Fires when sub-agents complete their tasks in parallel workflows.

<Callout type="success">
  **Pro Tip**: Use SubagentStop hooks to get individual notifications as parallel tasks complete, perfect for long-running operations where you want progress updates.
</Callout>

## Implementing Safety Controls {#safety-controls}

One of the most critical uses of hooks is preventing disasters before they happen. Let's build a comprehensive safety system.

### Basic Command Blocking

Start with a simple Python script that checks for dangerous commands:

### scripts/safety_check.py

```python
#!/usr/bin/env python3
import os
import sys
import json

DANGEROUS_COMMANDS = [
    'rm -rf',
    'sudo rm',
    'format',
    'dd if=',
    ':(){:|:&};:',  # Fork bomb
]

def check_command_safety():
    tool_name = os.environ.get('TOOL_NAME', '')
    command = os.environ.get('TOOL_COMMAND', '')
    
    if tool_name != 'Bash':
        return True
    
    for danger in DANGEROUS_COMMANDS:
        if danger in command:
            print(f"BLOCKED: Dangerous command detected: {danger}")
            sys.exit(1)
    
    return True

if __name__ == "__main__":
    check_command_safety()
```

### Advanced Safety with Allowlists

For production environments, use an allowlist approach:

### Advanced Safety Configuration

```python
ALLOWED_PATTERNS = {
    'npm': ['install', 'run', 'test', 'build'],
    'git': ['status', 'diff', 'log', 'add', 'commit'],
    'python': ['*.py', '-m pytest'],
    'cargo': ['build', 'test', 'run', 'fmt'],
}

def validate_against_allowlist(command):
    parts = command.split()
    if not parts:
        return False
    
    base_cmd = parts[0]
    if base_cmd not in ALLOWED_PATTERNS:
        return needs_approval(command)
    
    # Check if command matches allowed patterns
    allowed = ALLOWED_PATTERNS[base_cmd]
    return any(pattern_matches(command, pattern) 
               for pattern in allowed)
```

## Building Observability {#observability}

Observability is crucial for understanding and improving your agent's behavior. Let's build a comprehensive logging system.

### Structured Logging

Create detailed, structured logs that capture everything your agent does:

### Comprehensive Logging System

```python
import json
import time
from datetime import datetime
from pathlib import Path

class HookLogger:
    def __init__(self, log_dir="logs"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(exist_ok=True)
        
    def log_tool_use(self):
        entry = {
            "timestamp": datetime.now().isoformat(),
            "event": "tool_use",
            "tool": os.environ.get("TOOL_NAME"),
            "file_path": os.environ.get("TOOL_FILE_PATH"),
            "pattern": os.environ.get("TOOL_PATTERN"),
            "command": os.environ.get("TOOL_COMMAND"),
            "duration_ms": None,
        }
        
        log_file = self.log_dir / "post-tool-use.json"
        self._append_log(log_file, entry)
    
    def log_chat_complete(self):
        # Capture entire conversation
        chat_data = self._get_chat_context()
        
        log_file = self.log_dir / "chat.json"
        with open(log_file, 'w') as f:
            json.dump(chat_data, f, indent=2)
```

### Analyzing Agent Behavior

Use the logs to understand patterns and optimize workflows:

### Log Analysis Script

```python
def analyze_tool_usage(log_file):
    with open(log_file) as f:
        logs = [json.loads(line) for line in f]
    
    # Find most used tools
    tool_counts = {}
    for entry in logs:
        tool = entry.get('tool', 'unknown')
        tool_counts[tool] = tool_counts.get(tool, 0) + 1
    
    # Calculate average execution times
    # Identify error patterns
    # Track file modification frequency
    
    return {
        'total_operations': len(logs),
        'tool_usage': tool_counts,
        'files_modified': len(set(e['file_path'] for e in logs if e.get('file_path')))
    }
```

## Advanced Hook Patterns {#advanced-patterns}

### Voice-Enabled Development

Transform your development experience with audio feedback:

### Complete Voice Integration

```python
# scripts/voice_assistant.py
import pyttsx3
import os

class VoiceAssistant:
    def __init__(self):
        self.engine = pyttsx3.init()
        self.engine.setProperty('rate', 180)
        
    def notify_complete(self):
        task_type = os.environ.get('TASK_TYPE', 'Task')
        self.speak(f"{task_type} complete. Ready for next step.")
    
    def alert_error(self, error_msg):
        self.speak(f"Error detected: {error_msg}")
    
    def progress_update(self, current, total):
        self.speak(f"Progress: {current} of {total} complete")
```

### Parallel Agent Coordination

Handle multiple agents working simultaneously:

### Parallel Agent Monitoring

```json
{
  "SubagentStop": [{
    "matcher": ".*",
    "hooks": [
      {
        "type": "command",
        "command": "python scripts/track_agent.py --notify"
      },
      {
        "type": "command", 
        "command": "python scripts/update_dashboard.py"
      }
    ]
  }]
}
```

### Integration with External Tools

Connect Claude to your existing development ecosystem:

### Slack Integration

```python
import requests

def notify_slack(message, channel="#dev-notifications"):
    webhook_url = os.environ.get('SLACK_WEBHOOK_URL')
    
    payload = {
        "channel": channel,
        "text": message,
        "username": "Claude Code",
        "icon_emoji": ":robot_face:"
    }
    
    requests.post(webhook_url, json=payload)
```

<Callout type="warning">
  **Security Note**: Never hardcode webhook URLs or API keys. Always use environment variables and keep sensitive data out of your hook scripts.
</Callout>

## Practice Exercise {#practice-exercise}

Let's put it all together by building a complete hook configuration for a production environment.

### Exercise: Build Your Safety Net

Create a comprehensive hook setup that:

1. **Prevents disasters** with PreToolUse safety checks
2. **Logs everything** with PostToolUse monitoring
3. **Notifies on completion** with voice alerts
4. **Saves chat context** for analysis
5. **Handles parallel agents** gracefully

### Complete Hook Configuration

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": ".*",
      "hooks": [{
        "type": "command",
        "command": "uv run scripts/safety_guard.py"
      }]
    }],
    "PostToolUse": [{
      "matcher": ".*",
      "hooks": [{
        "type": "command",
        "command": "uv run scripts/logger.py --event post-tool"
      }]
    }],
    "Notification": [{
      "matcher": ".*", 
      "hooks": [{
        "type": "command",
        "command": "uv run scripts/voice.py --notify"
      }]
    }],
    "Stop": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run scripts/logger.py --save-chat"
        },
        {
          "type": "command",
          "command": "echo 'Session complete' | say"
        }
      ]
    }],
    "SubagentStop": [{
      "matcher": ".*",
      "hooks": [{
        "type": "command",
        "command": "uv run scripts/agent_tracker.py"
      }]
    }]
  }
}
```

### Challenge Tasks

1. **Add Custom Matchers**: Instead of `".*"`, create specific matchers for different file types
2. **Build a Dashboard**: Create a real-time dashboard that visualizes your agent's activity
3. **Implement Rollback**: Add a hook that can automatically rollback changes if tests fail
4. **Create Team Notifications**: Build hooks that notify your team channel when important milestones are reached

## Building Multi-Agent Observability {#multi-agent-observability}

As you scale from one Claude instance to many, observability becomes critical. Let's build a complete observability system that tracks multiple agents in real-time.

### The Observability Architecture

### Multi-Agent Observability Flow

```text
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Claude Agent 1 │     │  Claude Agent 2 │     │  Claude Agent 3 │
│   (Frontend)    │     │   (Backend)     │     │   (Testing)     │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │ Hooks                 │ Hooks                 │ Hooks
         └───────────┬───────────┴───────────┬──────────┘
                     ▼                       ▼
              ┌─────────────────────────────────┐
              │      Observability Server       │
              │   • Event Storage (SQLite)      │
              │   • WebSocket Broadcasting      │
              │   • AI Summarization           │
              └──────────────┬──────────────────┘
                             ▼
              ┌─────────────────────────────────┐
              │    Real-Time Dashboard          │
              │   • Live Activity Pulse         │
              │   • Event Stream & Filtering   │
              │   • Agent Health Monitoring     │
              └─────────────────────────────────┘
```

### Step 1: Enhanced Hook for Event Streaming

### Universal Event Streaming Hook

```python
#!/usr/bin/env uv run
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "requests",
#   "anthropic",
# ]
# ///

import sys
import json
import requests
import os
from datetime import datetime
import socket

def summarize_event(event_data, event_type):
    """Use Haiku for ultra-fast event summarization"""
    if event_type not in ['PreToolUse', 'PostToolUse']:
        return None
    
    try:
        import anthropic
        client = anthropic.Client()
        
        prompt = f"Summarize in 10 words: {json.dumps(event_data)}"
        response = client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=30,
            messages=[{"role": "user", "content": prompt}]
        )
        return response.content[0].text
    except:
        return None

def main():
    event_type = sys.argv[1] if len(sys.argv) > 1 else "unknown"
    event = json.loads(sys.stdin.read())
    
    # Enrich event data
    event['timestamp'] = datetime.now().isoformat()
    event['hostname'] = socket.gethostname()
    event['event_type'] = event_type
    event['app_name'] = os.environ.get('PROJECT_NAME', 'unknown')
    event['session_id'] = os.environ.get('CLAUDE_SESSION_ID', 'unknown')
    
    # Add AI summary for key events
    if summary := summarize_event(event, event_type):
        event['summary'] = summary
    
    # Send to observability server
    try:
        requests.post(
            'http://localhost:3000/events',
            json=event,
            timeout=0.5  # Non-blocking
        )
    except:
        pass  # Fail silently to not disrupt workflow

if __name__ == "__main__":
    main()
```

### Step 2: Real-Time Observability Server

### Bun-Based Event Server

```typescript
// server.ts
import { serve } from 'bun';
import { Database } from 'bun:sqlite';

const db = new Database('agent-events.db');

// Initialize schema
db.run(\`
  CREATE TABLE IF NOT EXISTS events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    app_name TEXT,
    session_id TEXT,
    event_type TEXT,
    summary TEXT,
    data TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
\`);

// WebSocket clients
const clients = new Set<WebSocket>();

serve({
  port: 3000,
  
  async fetch(req, server) {
    const url = new URL(req.url);
    
    // Handle event ingestion
    if (url.pathname === '/events' && req.method === 'POST') {
      const event = await req.json();
      
      // Store event
      db.run(
        \`INSERT INTO events 
         (timestamp, app_name, session_id, event_type, summary, data) 
         VALUES (?, ?, ?, ?, ?, ?)\`,
        event.timestamp,
        event.app_name,
        event.session_id,
        event.event_type,
        event.summary,
        JSON.stringify(event)
      );
      
      // Broadcast to connected clients
      const message = JSON.stringify({
        type: 'event',
        data: event
      });
      
      clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(message);
        }
      });
      
      return new Response('OK');
    }
    
    // WebSocket endpoint
    if (url.pathname === '/ws') {
      if (server.upgrade(req)) {
        return; // Upgrade successful
      }
    }
    
    // Dashboard endpoint
    if (url.pathname === '/') {
      return new Response(dashboardHTML, {
        headers: { 'Content-Type': 'text/html' }
      });
    }
    
    return new Response('Not found', { status: 404 });
  },
  
  websocket: {
    open(ws) {
      clients.add(ws);
      
      // Send recent events on connect
      const recent = db.query(\`
        SELECT * FROM events 
        ORDER BY id DESC 
        LIMIT 100
      \`).all();
      
      ws.send(JSON.stringify({
        type: 'history',
        data: recent
      }));
    },
    
    close(ws) {
      clients.delete(ws);
    }
  }
});
```

### Step 3: Live Dashboard Implementation

### Real-Time Dashboard Component

```html
<!DOCTYPE html>
<html>
<head>
  <title>Claude Multi-Agent Observatory</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    .event-stream { 
      height: 400px; 
      overflow-y: auto; 
      border: 1px solid #333;
      padding: 10px;
    }
    .event-item {
      padding: 8px;
      margin: 4px 0;
      border-radius: 4px;
      background: #f0f0f0;
    }
    .session-badge {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: white;
    }
    .activity-pulse {
      display: flex;
      height: 100px;
      align-items: flex-end;
      gap: 2px;
    }
    .pulse-bar {
      flex: 1;
      background: #3498db;
      transition: height 0.3s;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Claude Multi-Agent Observatory</h1>
    
    <!-- Activity Pulse -->
    <div class="activity-pulse">
      <div v-for="bar in activityBars" 
           :key="bar.time"
           class="pulse-bar"
           :style="{ height: bar.height + '%' }">
      </div>
    </div>
    
    <!-- Stats -->
    <div>
      <h3>Active Sessions: {{ activeSessions.size }}</h3>
      <span v-for="session in activeSessions" 
            :key="session"
            class="session-badge"
            :style="{ backgroundColor: getSessionColor(session) }">
        {{ session.slice(0, 8) }}
      </span>
    </div>
    
    <!-- Event Stream -->
    <div class="event-stream">
      <div v-for="event in events" 
           :key="event.id"
           class="event-item">
        <strong>{{ event.app_name }}</strong> - 
        {{ event.event_type }} - 
        <span v-if="event.summary">{{ event.summary }}</span>
        <small>{{ new Date(event.timestamp).toLocaleTimeString() }}</small>
      </div>
    </div>
  </div>
  
  <script>
    const { createApp } = Vue;
    
    createApp({
      data() {
        return {
          events: [],
          ws: null,
          activityBars: Array(60).fill({ height: 0 })
        };
      },
      
      computed: {
        activeSessions() {
          const sessions = new Set();
          this.events.slice(0, 100).forEach(e => {
            sessions.add(e.session_id);
          });
          return sessions;
        }
      },
      
      methods: {
        connect() {
          this.ws = new WebSocket('ws://localhost:3000/ws');
          
          this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            
            if (message.type === 'event') {
              this.events.unshift(message.data);
              this.events = this.events.slice(0, 1000);
              this.updateActivityPulse();
            } else if (message.type === 'history') {
              this.events = message.data.reverse();
            }
          };
          
          this.ws.onclose = () => {
            setTimeout(() => this.connect(), 1000);
          };
        },
        
        updateActivityPulse() {
          // Update activity visualization
          const now = Date.now();
          const minute = Math.floor(now / 1000);
          const index = minute % 60;
          
          this.activityBars[index] = {
            height: Math.min(100, this.activityBars[index].height + 10),
            time: minute
          };
        },
        
        getSessionColor(sessionId) {
          // Generate consistent color from session ID
          let hash = 0;
          for (let i = 0; i < sessionId.length; i++) {
            hash = sessionId.charCodeAt(i) + ((hash << 5) - hash);
          }
          const hue = Math.abs(hash) % 360;
          return \`hsl(\${hue}, 70%, 50%)\`;
        }
      },
      
      mounted() {
        this.connect();
        
        // Decay activity bars over time
        setInterval(() => {
          this.activityBars = this.activityBars.map(bar => ({
            ...bar,
            height: Math.max(0, bar.height - 1)
          }));
        }, 1000);
      }
    }).mount('#app');
  </script>
</body>
</html>
```

### Step 4: Configure Hooks for Full Observability

### Complete Observability Hook Configuration

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run scripts/stream-event.py PreToolUse"
        }
      ]
    }],
    "PostToolUse": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run scripts/stream-event.py PostToolUse"
        }
      ]
    }],
    "Notification": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run scripts/stream-event.py Notification"
        }
      ]
    }],
    "Stop": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run scripts/stream-event.py Stop"
        },
        {
          "type": "command",
          "command": "uv run scripts/save-transcript.py"
        }
      ]
    }],
    "SubagentStop": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run scripts/stream-event.py SubagentStop"
        }
      ]
    }]
  }
}
```

### Advanced Observability Patterns

<Callout type="info">
  **Pro Tip**: Use small, fast models like Claude Haiku for event summarization. Thousands of summaries cost less than $0.20 and provide instant context.
</Callout>

#### Pattern 1: Agent Health Monitoring

### Agent Health Check Script

```python
#!/usr/bin/env uv run
# Check for stuck or inactive agents

import sqlite3
from datetime import datetime, timedelta

def check_agent_health():
    conn = sqlite3.connect('agent-events.db')
    cursor = conn.cursor()
    
    # Find inactive agents
    threshold = datetime.now() - timedelta(minutes=5)
    
    cursor.execute("""
        SELECT session_id, MAX(timestamp) as last_seen
        FROM events
        GROUP BY session_id
        HAVING last_seen < ?
    """, (threshold.isoformat(),))
    
    inactive = cursor.fetchall()
    
    if inactive:
        print("⚠️  Inactive agents detected:")
        for session_id, last_seen in inactive:
            print(f"  - {session_id}: Last seen {last_seen}")
    
    conn.close()

if __name__ == "__main__":
    check_agent_health()
```

#### Pattern 2: Cross-Agent Conflict Detection

### Detect File Conflicts Between Agents

```python
#!/usr/bin/env uv run
# Detect when multiple agents modify the same files

import json
import sqlite3
from collections import defaultdict

def detect_conflicts():
    conn = sqlite3.connect('agent-events.db')
    cursor = conn.cursor()
    
    # Get recent file modifications
    cursor.execute("""
        SELECT session_id, data
        FROM events
        WHERE event_type = 'PostToolUse'
        AND timestamp > datetime('now', '-1 hour')
    """)
    
    file_sessions = defaultdict(set)
    
    for session_id, data_str in cursor.fetchall():
        data = json.loads(data_str)
        if data.get('tool') in ['Edit', 'Write']:
            file_path = data.get('arguments', {}).get('path')
            if file_path:
                file_sessions[file_path].add(session_id)
    
    # Report conflicts
    conflicts = {f: list(s) for f, s in file_sessions.items() if len(s) > 1}
    
    if conflicts:
        print("⚠️  File conflicts detected:")
        for file_path, sessions in conflicts.items():
            print(f"  - {file_path}: {len(sessions)} agents")
    
    conn.close()
    return conflicts

if __name__ == "__main__":
    detect_conflicts()
```

### Scaling Considerations

As you scale to 10+ agents:

1. **Event Sampling**: For high-frequency events, sample rather than log everything
2. **Batch Processing**: Buffer events and send in batches
3. **Data Retention**: Implement automatic cleanup of old events
4. **Performance Monitoring**: Track hook execution time to avoid slowdowns

<Callout type="warning">
  **Important**: Keep your hooks fast! They run synchronously and can slow down Claude if they take too long. Aim for <100ms execution time.
</Callout>

## Summary

Claude hooks represent a fundamental shift in how we work with AI coding assistants. By implementing proper hooks with comprehensive observability, you gain:

- **Safety**: Prevent disasters before they happen
- **Visibility**: See everything your agents are doing in real-time
- **Automation**: Eliminate repetitive manual tasks
- **Awareness**: Stay informed with voice and visual notifications
- **Control**: Fine-grained control over agent behavior
- **Scale**: Manage multiple agents with confidence

Remember: The goal isn't to constrain your AI assistant, but to enhance it with the context and guardrails that make it a truly effective development partner.

<Quiz>
  <Question
    question="Which hook event should you use to prevent dangerous commands from executing?"
    options={[
      "PostToolUse",
      "PreToolUse",
      "Notification",
      "Stop"
    ]}
    correct={1}
    explanation="PreToolUse fires before any tool runs, giving you the opportunity to inspect and block dangerous operations before they execute."
  />
  <Question
    question="What is the primary benefit of using PostToolUse hooks?"
    options={[
      "Blocking dangerous commands",
      "Getting user input",
      "Logging and observability",
      "Cleaning up resources"
    ]}
    correct={2}
    explanation="PostToolUse hooks are perfect for logging tool executions, building observability, and tracking what your agent has done."
  />
  <Question
    question="When working with parallel sub-agents, which hook helps you track individual completions?"
    options={[
      "Stop",
      "SubagentStop",
      "Notification",
      "PreToolUse"
    ]}
    correct={1}
    explanation="SubagentStop fires when individual sub-agents complete their tasks, allowing you to track progress in parallel workflows."
  />
</Quiz>

## Next Steps

Now that you understand Claude hooks, consider:

1. **Start Simple**: Implement one basic hook and gradually expand
2. **Share Your Hooks**: Join the Claude community to share configurations
3. **Build Tools**: Create reusable hook scripts for common patterns
4. **Measure Impact**: Use your logs to quantify productivity improvements

The future of AI-assisted development is here, and with hooks, you're in full control.