---
title: "Construir um Servidor MCP Completo"
description: "Projeto final: Crie um servidor MCP pronto para produ√ß√£o que integre m√∫ltiplos provedores, ferramentas e sistemas do mundo real"
duration: "120 minutos"
difficulty: "avan√ßado"
objectives:
  - "Projetar e arquitetar uma solu√ß√£o completa de servidor MCP"
  - "Integrar m√∫ltiplos provedores de recursos e ferramentas"
  - "Implementar tratamento de erros e logging prontos para produ√ß√£o"
  - "Adicionar gerenciamento de configura√ß√£o e suporte a ambientes"
  - "Construir testes e documenta√ß√£o abrangentes"
  - "Implantar e testar com aplica√ß√µes de IA reais"
tags:
  - "mcp"
  - "projeto-final"
  - "projeto"
  - "produ√ß√£o"
  - "integra√ß√£o"
lastUpdated: "2024-01-15"
author: "Brandon Redmond"
---

import { CodeExample } from '@/components/claude-sdk/CodeEditor'
import { Callout } from '@/components/ui/callout'
import { Exercise } from '@/components/claude-sdk/Exercise'

# Construir um Servidor MCP Completo

## Vis√£o Geral e Arquitetura do Projeto {#project-overview}

Parab√©ns por chegar ao projeto final! Agora voc√™ aplicar√° tudo o que aprendeu para construir um servidor MCP pronto para produ√ß√£o que demonstra padr√µes de integra√ß√£o do mundo real e melhores pr√°ticas.

### O que Voc√™ Construir√°: Servidor de Intelig√™ncia de Workspace

Seu projeto final √© um **Servidor de Intelig√™ncia de Workspace** - um servidor MCP que fornece √†s aplica√ß√µes de IA acesso abrangente a ambientes de desenvolvimento. Este servidor integrar√° m√∫ltiplas fontes de dados e fornecer√° ferramentas poderosas para gerenciamento de projetos, fluxos de trabalho de desenvolvimento e colabora√ß√£o em equipe.

### Recursos Principais

üîß **Arquitetura Multi-Provedor**: Sistema de arquivos, Git, banco de dados, API e provedores de configura√ß√£o
üõ†Ô∏è **Conjunto Abrangente de Ferramentas**: Opera√ß√µes de arquivo, gerenciamento de projetos, comunica√ß√£o e ferramentas de desenvolvimento
‚ö° **Pronto para Produ√ß√£o**: Logging, monitoramento, tratamento de erros e desligamento gracioso
üîí **Seguro por Design**: Valida√ß√£o de entrada, controles de acesso e logging de auditoria
üìä **Observ√°vel**: Verifica√ß√µes de sa√∫de, m√©tricas e monitoramento de performance
üß™ **Bem Testado**: Testes unit√°rios, testes de integra√ß√£o e testes end-to-end

<CodeExample
  title="Estrutura Completa do Projeto"
  language="text"
  code={`mcp-workspace-server/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts                 # Entrada principal do servidor
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts            # Gerenciamento de configura√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema.ts           # Valida√ß√£o de config
‚îÇ   ‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts            # Registro de provedores
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ filesystem.ts       # Provedor de sistema de arquivos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.ts         # Provedor de banco de dados
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts              # Provedor de API externa
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ git.ts              # Provedor de reposit√≥rio Git
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts            # Registro de ferramentas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ file-ops.ts         # Opera√ß√µes de arquivo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project-mgmt.ts     # Gerenciamento de projeto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ communication.ts    # Ferramentas Email/Slack
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ development.ts      # Ferramentas dev (git, npm, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts             # Autentica√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rate-limit.ts       # Limita√ß√£o de taxa
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.ts          # Logging de requisi√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation.ts       # Valida√ß√£o de entrada
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.ts         # Helpers de seguran√ßa
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors.ts           # Classes de erro
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îú‚îÄ‚îÄ config.ts           # Tipos de configura√ß√£o
‚îÇ       ‚îú‚îÄ‚îÄ providers.ts        # Interfaces de provedor
‚îÇ       ‚îî‚îÄ‚îÄ tools.ts            # Interfaces de ferramenta
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/                   # Testes unit√°rios
‚îÇ   ‚îú‚îÄ‚îÄ integration/            # Testes de integra√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/               # Dados de teste
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ README.md               # Documenta√ß√£o principal
‚îÇ   ‚îú‚îÄ‚îÄ API.md                  # Refer√™ncia da API
‚îÇ   ‚îî‚îÄ‚îÄ DEPLOYMENT.md           # Guia de implanta√ß√£o
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ development.json        # Config de desenvolvimento
‚îÇ   ‚îú‚îÄ‚îÄ production.json         # Config de produ√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ test.json               # Config de teste
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ build.sh               # Script de build
‚îÇ   ‚îú‚îÄ‚îÄ test.sh                # Script de teste
‚îÇ   ‚îî‚îÄ‚îÄ deploy.sh              # Script de implanta√ß√£o
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/             # Workflows CI/CD
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ .eslintrc.js
‚îî‚îÄ‚îÄ .gitignore`}
/>

### Princ√≠pios de Arquitetura

Seu servidor seguir√° estes princ√≠pios arquiteturais:

1. **Modularidade**: Cada provedor e ferramenta √© autocontido e test√°vel independentemente
2. **Extensibilidade**: Novos provedores e ferramentas podem ser adicionados sem modificar c√≥digo principal
3. **Resili√™ncia**: Falhas em um componente n√£o afetam outros
4. **Observabilidade**: Logging e monitoramento abrangentes em todo o sistema
5. **Seguran√ßa**: Defesa em profundidade com m√∫ltiplas camadas de seguran√ßa

<Callout type="info">
  **Filosofia de Design**: Construa para produ√ß√£o desde o primeiro dia. Cada componente deve incluir tratamento de erros, logging, valida√ß√£o e testes.
</Callout>

## Implementa√ß√£o do Servidor Principal {#core-implementation}

Vamos come√ßar construindo a arquitetura fundamental do servidor que suportar√° todos os seus provedores e ferramentas.

<Exercise
  id="core-implementation"
  title="Construir a Arquitetura Principal do Servidor MCP"
/>

### Sistema de Gerenciamento de Configura√ß√£o

Um servidor de produ√ß√£o precisa de gerenciamento robusto de configura√ß√£o:

<CodeExample
  title="Sistema de Configura√ß√£o"
  language="typescript"
  code={`// src/config/index.ts
import { readFileSync } from 'fs';
import { join } from 'path';
import Ajv from 'ajv';
import { configSchema } from './schema.js';

export interface ServerConfig {
  server: {
    name: string;
    version: string;
    environment: string;
  };
  providers: {
    filesystem: { enabled: boolean; basePath: string; watchFiles?: boolean };
    git: { enabled: boolean; repositoryPath: string };
    database: { enabled: boolean; connectionString: string };
    api: { enabled: boolean; endpoints: string[]; timeout: number };
    config: { enabled: boolean; configPath: string };
  };
  tools: {
    fileOps: { enabled: boolean; maxFileSize: number };
    projectMgmt: { enabled: boolean; projectsPath: string };
    communication: { enabled: boolean; slackToken?: string; emailConfig?: any };
    development: { enabled: boolean; allowedCommands: string[] };
  };
  security: {
    rateLimiting: { enabled: boolean; maxRequests: number; window: number };
    allowedOrigins: string[];
    logLevel: 'debug' | 'info' | 'warn' | 'error';
  };
  monitoring: {
    healthCheck: { enabled: boolean; interval: number };
    metrics: { enabled: boolean; port?: number };
  };
}

export function loadConfiguration(): ServerConfig {
  const environment = process.env.NODE_ENV || 'development';
  const configFile = join(process.cwd(), 'config', \`\${environment}.json\`);
  
  try {
    const configData = JSON.parse(readFileSync(configFile, 'utf-8'));
    
    // Mesclar com vari√°veis de ambiente
    const config = mergeEnvironmentVariables(configData);
    
    // Validar configura√ß√£o
    const ajv = new Ajv();
    const validate = ajv.compile(configSchema);
    
    if (!validate(config)) {
      throw new Error(\`Configura√ß√£o inv√°lida: \${JSON.stringify(validate.errors)}\`);
    }
    
    return config;
  } catch (error) {
    console.error(\`Falha ao carregar configura√ß√£o: \${error.message}\`);
    process.exit(1);
  }
}

function mergeEnvironmentVariables(config: any): ServerConfig {
  // Sobrescrever com vari√°veis de ambiente
  if (process.env.MCP_LOG_LEVEL) {
    config.security.logLevel = process.env.MCP_LOG_LEVEL;
  }
  
  if (process.env.MCP_DATABASE_URL) {
    config.providers.database.connectionString = process.env.MCP_DATABASE_URL;
  }
  
  if (process.env.MCP_SLACK_TOKEN) {
    config.tools.communication.slackToken = process.env.MCP_SLACK_TOKEN;
  }
  
  return config;
}`}
/>

### Sistema de Logging Estruturado

Implemente logging abrangente para depura√ß√£o e monitoramento:

<CodeExample
  title="Logging de Produ√ß√£o"
  language="typescript"
  code={`// src/utils/logging.ts
import winston from 'winston';

export class Logger {
  private logger: winston.Logger;
  
  constructor(component: string, config: any) {
    this.logger = winston.createLogger({
      level: config.security?.logLevel || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json(),
        winston.format.printf(({ timestamp, level, message, component: comp, ...meta }) => {
          return JSON.stringify({
            timestamp,
            level,
            component: comp || component,
            message,
            ...meta
          });
        })
      ),
      defaultMeta: { component },
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        }),
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' })
      ]
    });
  }
  
  debug(message: string, meta?: any) {
    this.logger.debug(message, meta);
  }
  
  info(message: string, meta?: any) {
    this.logger.info(message, meta);
  }
  
  warn(message: string, meta?: any) {
    this.logger.warn(message, meta);
  }
  
  error(message: string, error?: Error | any) {
    if (error instanceof Error) {
      this.logger.error(message, { error: error.message, stack: error.stack });
    } else {
      this.logger.error(message, { error });
    }
  }
  
  // Logging estruturado para eventos espec√≠ficos
  logResourceAccess(uri: string, success: boolean, duration: number) {
    this.info('Recurso acessado', {
      event: 'resource_access',
      uri,
      success,
      duration,
      timestamp: new Date().toISOString()
    });
  }
  
  logToolExecution(tool: string, success: boolean, duration: number, args?: any) {
    this.info('Ferramenta executada', {
      event: 'tool_execution',
      tool,
      success,
      duration,
      argsHash: args ? this.hashArgs(args) : undefined,
      timestamp: new Date().toISOString()
    });
  }
  
  private hashArgs(args: any): string {
    // Criar um hash de argumentos para logging (n√£o registrar dados sens√≠veis)
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(JSON.stringify(args)).digest('hex').substring(0, 8);
  }
}`}
/>

## Integrando M√∫ltiplos Provedores {#provider-integration}

Agora vamos construir um sistema abrangente de provedores que lida com m√∫ltiplas fontes de dados com resili√™ncia e performance em mente.

<Exercise
  id="provider-integration"
  title="Construir e Integrar M√∫ltiplos Provedores de Recursos"
/>

### Padr√µes Avan√ßados de Provedores

Aqui est√£o alguns padr√µes avan√ßados para sistemas de provedores de produ√ß√£o:

<CodeExample
  title="Provedor Git com Recursos Avan√ßados"
  language="typescript"
  code={`// src/providers/git.ts
import { execAsync } from '../utils/exec.js';
import { Provider, Resource, ResourceContent } from '../types/providers.js';

export class GitProvider implements Provider {
  name = 'git';
  scheme = 'git';
  
  constructor(private config: any, private logger: any) {}
  
  async listResources(): Promise<Resource[]> {
    const resources: Resource[] = [];
    
    try {
      // Status do reposit√≥rio
      resources.push({
        uri: 'git://status',
        name: 'Status do Reposit√≥rio',
        description: 'Status atual do reposit√≥rio git e mudan√ßas na √°rvore de trabalho',
        mimeType: 'application/json'
      });
      
      // Informa√ß√µes de branch
      resources.push({
        uri: 'git://branches',
        name: 'Branches Git',
        description: 'Lista de todas as branches locais e remotas',
        mimeType: 'application/json'
      });
      
      // Commits recentes
      resources.push({
        uri: 'git://commits/recent',
        name: 'Commits Recentes',
        description: '√öltimos 10 commits com detalhes',
        mimeType: 'application/json'
      });
      
      // Informa√ß√µes do reposit√≥rio
      resources.push({
        uri: 'git://info',
        name: 'Informa√ß√µes do Reposit√≥rio',
        description: 'Configura√ß√£o do reposit√≥rio e informa√ß√µes remotas',
        mimeType: 'application/json'
      });
      
      // Hist√≥rico de arquivo para arquivos rastreados
      const trackedFiles = await this.getTrackedFiles();
      for (const file of trackedFiles.slice(0, 20)) { // Limitar para evitar sobrecarga
        resources.push({
          uri: \`git://history/\${encodeURIComponent(file)}\`,
          name: \`Hist√≥rico: \${file}\`,
          description: \`Hist√≥rico git para \${file}\`,
          mimeType: 'application/json'
        });
      }
      
    } catch (error) {
      this.logger.error('Falha ao listar recursos git:', error);
      // Retornar array vazio em vez de lan√ßar erro - seja resiliente
    }
    
    return resources;
  }
  
  async readResource(uri: string): Promise<ResourceContent> {
    const path = uri.replace('git://', '');
    
    switch (path) {
      case 'status':
        return this.getRepositoryStatus();
      case 'branches':
        return this.getBranches();
      case 'commits/recent':
        return this.getRecentCommits();
      case 'info':
        return this.getRepositoryInfo();
      default:
        if (path.startsWith('history/')) {
          const filePath = decodeURIComponent(path.replace('history/', ''));
          return this.getFileHistory(filePath);
        }
        throw new Error(\`Recurso git desconhecido: \${path}\`);
    }
  }
  
  private async getRepositoryStatus(): Promise<ResourceContent> {
    try {
      const [status, branch] = await Promise.all([
        execAsync('git status --porcelain', { cwd: this.config.repositoryPath }),
        execAsync('git branch --show-current', { cwd: this.config.repositoryPath })
      ]);
      
      const changes = status.stdout.split('\\n').filter(line => line.trim()).map(line => ({
        status: line.substring(0, 2),
        file: line.substring(3),
        staged: line[0] !== ' ',
        unstaged: line[1] !== ' '
      }));
      
      const data = {
        currentBranch: branch.stdout.trim(),
        changes,
        totalChanges: changes.length,
        stagedChanges: changes.filter(c => c.staged).length,
        unstagedChanges: changes.filter(c => c.unstaged).length,
        timestamp: new Date().toISOString()
      };
      
      return {
        uri: 'git://status',
        mimeType: 'application/json',
        text: JSON.stringify(data, null, 2)
      };
    } catch (error) {
      throw new Error(\`Falha ao obter status git: \${error.message}\`);
    }
  }
  
  private async getBranches(): Promise<ResourceContent> {
    try {
      const [local, remote] = await Promise.all([
        execAsync('git branch --format="%(refname:short)|%(objectname:short)|%(committerdate:iso8601)"', { cwd: this.config.repositoryPath }),
        execAsync('git branch -r --format="%(refname:short)|%(objectname:short)|%(committerdate:iso8601)"', { cwd: this.config.repositoryPath })
      ]);
      
      const parseBranches = (output: string, type: string) => 
        output.split('\\n').filter(line => line.trim()).map(line => {
          const [name, commit, date] = line.split('|');
          return { name: name.trim(), commit, date, type };
        });
      
      const data = {
        local: parseBranches(local.stdout, 'local'),
        remote: parseBranches(remote.stdout, 'remote'),
        timestamp: new Date().toISOString()
      };
      
      return {
        uri: 'git://branches',
        mimeType: 'application/json',
        text: JSON.stringify(data, null, 2)
      };
    } catch (error) {
      throw new Error(\`Falha ao obter branches: \${error.message}\`);
    }
  }
  
  private async getTrackedFiles(): Promise<string[]> {
    try {
      const result = await execAsync('git ls-files', { cwd: this.config.repositoryPath });
      return result.stdout.split('\\n').filter(line => line.trim());
    } catch (error) {
      this.logger.error('Falha ao obter arquivos rastreados:', error);
      return [];
    }
  }
  
  async healthCheck(): Promise<{ healthy: boolean; message?: string }> {
    try {
      // Verificar se git est√° dispon√≠vel
      await execAsync('git --version');
      
      // Verificar se o reposit√≥rio existe e √© v√°lido
      await execAsync('git rev-parse --git-dir', { cwd: this.config.repositoryPath });
      
      return { healthy: true };
    } catch (error) {
      return { 
        healthy: false, 
        message: \`Provedor Git n√£o saud√°vel: \${error.message}\`
      };
    }
  }
  
  async cleanup(): Promise<void> {
    // Provedor Git n√£o precisa de limpeza, mas poderia cancelar opera√ß√µes em andamento
    this.logger.debug('Limpeza do provedor Git conclu√≠da');
  }
}`}
/>

### Provedor de Banco de Dados com Pool de Conex√£o

<CodeExample
  title="Provedor de Banco de Dados de Produ√ß√£o"
  language="typescript"
  code={`// src/providers/database.ts
import sqlite3 from 'sqlite3';
import { Provider, Resource, ResourceContent } from '../types/providers.js';

export class DatabaseProvider implements Provider {
  name = 'database';
  scheme = 'db';
  private db: sqlite3.Database | null = null;
  private connectionPool: ConnectionPool;
  
  constructor(private config: any, private logger: any) {
    this.connectionPool = new ConnectionPool(config.connectionString, {
      max: 10,
      min: 2,
      acquireTimeoutMillis: 30000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      idleTimeoutMillis: 30000
    });
  }
  
  async listResources(): Promise<Resource[]> {
    const connection = await this.connectionPool.acquire();
    
    try {
      // Obter todas as tabelas
      const tables = await this.query(connection, 
        "SELECT name FROM sqlite_master WHERE type='table'"
      );
      
      const resources: Resource[] = [];
      
      // Adicionar cada tabela como recurso
      for (const table of tables) {
        const count = await this.query(connection,
          \`SELECT COUNT(*) as count FROM \${table.name}\`
        );
        
        resources.push({
          uri: \`db://tables/\${table.name}\`,
          name: \`Tabela: \${table.name}\`,
          description: \`Tabela de banco de dados com \${count[0].count} registros\`,
          mimeType: 'application/json'
        });
        
        // Adicionar esquema da tabela como recurso
        resources.push({
          uri: \`db://schema/\${table.name}\`,
          name: \`Esquema: \${table.name}\`,
          description: \`Esquema da tabela para \${table.name}\`,
          mimeType: 'application/json'
        });
      }
      
      // Adicionar informa√ß√µes do banco de dados
      resources.push({
        uri: 'db://info',
        name: 'Informa√ß√µes do Banco de Dados',
        description: 'Metadados e estat√≠sticas do banco de dados',
        mimeType: 'application/json'
      });
      
      return resources;
    } finally {
      this.connectionPool.release(connection);
    }
  }
  
  async readResource(uri: string): Promise<ResourceContent> {
    const path = uri.replace('db://', '');
    const connection = await this.connectionPool.acquire();
    
    try {
      if (path.startsWith('tables/')) {
        const tableName = path.replace('tables/', '');
        return this.getTableData(connection, tableName);
      } else if (path.startsWith('schema/')) {
        const tableName = path.replace('schema/', '');
        return this.getTableSchema(connection, tableName);
      } else if (path === 'info') {
        return this.getDatabaseInfo(connection);
      } else {
        throw new Error(\`Recurso de banco de dados desconhecido: \${path}\`);
      }
    } finally {
      this.connectionPool.release(connection);
    }
  }
  
  private async getTableData(connection: any, tableName: string): Promise<ResourceContent> {
    // Validar nome da tabela para prevenir inje√ß√£o SQL
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(tableName)) {
      throw new Error('Nome de tabela inv√°lido');
    }
    
    const data = await this.query(connection,
      \`SELECT * FROM \${tableName} LIMIT 100\`
    );
    
    return {
      uri: \`db://tables/\${tableName}\`,
      mimeType: 'application/json',
      text: JSON.stringify({
        table: tableName,
        recordCount: data.length,
        records: data,
        timestamp: new Date().toISOString()
      }, null, 2)
    };
  }
  
  private async query(connection: any, sql: string, params: any[] = []): Promise<any[]> {
    return new Promise((resolve, reject) => {
      connection.all(sql, params, (err: Error, rows: any[]) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
  
  async healthCheck(): Promise<{ healthy: boolean; message?: string }> {
    try {
      const connection = await this.connectionPool.acquire();
      await this.query(connection, 'SELECT 1');
      this.connectionPool.release(connection);
      return { healthy: true };
    } catch (error) {
      return { 
        healthy: false, 
        message: \`Banco de dados n√£o saud√°vel: \${error.message}\`
      };
    }
  }
  
  async cleanup(): Promise<void> {
    await this.connectionPool.drain();
    await this.connectionPool.clear();
    this.logger.debug('Limpeza do provedor de banco de dados conclu√≠da');
  }
}`}
/>

## Integra√ß√£o Abrangente de Ferramentas {#tool-integration}

Seu servidor precisa de um conjunto robusto de ferramentas que cubra todo o espectro de tarefas de desenvolvimento e gerenciamento de projetos.

<CodeExample
  title="Implementa√ß√£o do Registro de Ferramentas"
  language="typescript"
  code={`export class ToolRegistry {
  private tools: Map<string, Tool> = new Map();
  private toolProviders: Map<string, ToolProvider> = new Map();
  private executionLog: ExecutionLog[] = [];
  private rateLimiter: RateLimiter;
  
  constructor(private config: any, private logger: any) {
    this.rateLimiter = new RateLimiter(config.rateLimiting);
  }
  
  async registerAll() {
    const providers = [
      new FileOperationTools(this.config.filesystem),
      new ProjectManagementTools(this.config.project),
      new CommunicationTools(this.config.communication),
      new DevelopmentTools(this.config.development)
    ];
    
    for (const provider of providers) {
      await this.registerToolProvider(provider);
    }
  }
  
  async executeTool(name: string, args: any): Promise<ToolResult> {
    // Limita√ß√£o de taxa
    if (!this.rateLimiter.allow(name)) {
      throw new Error(\`Limite de taxa excedido para ferramenta: \${name}\`);
    }
    
    // Encontrar ferramenta
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(\`Ferramenta n√£o encontrada: \${name}\`);
    }
    
    // Validar argumentos
    const validation = this.validateArguments(tool, args);
    if (!validation.valid) {
      throw new Error(\`Argumentos inv√°lidos: \${validation.errors.join(', ')}\`);
    }
    
    // Executar com monitoramento
    const startTime = Date.now();
    try {
      const result = await tool.execute(args);
      
      // Registrar execu√ß√£o
      this.logExecution({
        tool: name,
        success: !result.isError,
        duration: Date.now() - startTime,
        timestamp: new Date()
      });
      
      return result;
    } catch (error) {
      this.logExecution({
        tool: name,
        success: false,
        duration: Date.now() - startTime,
        error: error.message,
        timestamp: new Date()
      });
      throw error;
    }
  }
  
  getAllTools(): ToolDefinition[] {
    return Array.from(this.tools.values()).map(tool => ({
      name: tool.name,
      description: tool.description,
      inputSchema: tool.inputSchema
    }));
  }
  
  getExecutionStats(): ExecutionStats {
    const recent = this.executionLog.filter(
      log => Date.now() - log.timestamp.getTime() < 24 * 60 * 60 * 1000
    );
    
    return {
      totalExecutions: recent.length,
      successRate: recent.filter(log => log.success).length / recent.length,
      averageDuration: recent.reduce((sum, log) => sum + log.duration, 0) / recent.length,
      topTools: this.getTopTools(recent)
    };
  }
}`}
/>

### Ferramentas Avan√ßadas de Desenvolvimento

<CodeExample
  title="Conjunto de Ferramentas de Desenvolvimento"
  language="typescript"
  code={`// src/tools/development.ts
export class DevelopmentTools implements ToolProvider {
  getName() { return 'development'; }
  
  getTools(): ToolDefinition[] {
    return [
      {
        name: 'git_commit',
        description: 'Criar um commit git com mudan√ßas preparadas',
        inputSchema: {
          type: 'object',
          properties: {
            message: { type: 'string', description: 'Mensagem de commit' },
            addAll: { type: 'boolean', default: false, description: 'Adicionar todas as mudan√ßas antes de commitar' }
          },
          required: ['message']
        }
      },
      {
        name: 'npm_install',
        description: 'Instalar pacotes npm',
        inputSchema: {
          type: 'object',
          properties: {
            packages: { 
              type: 'array', 
              items: { type: 'string' },
              description: 'Nomes dos pacotes para instalar' 
            },
            dev: { type: 'boolean', default: false, description: 'Instalar como depend√™ncias de desenvolvimento' },
            global: { type: 'boolean', default: false, description: 'Instalar globalmente' }
          },
          required: ['packages']
        }
      },
      {
        name: 'run_tests',
        description: 'Executar testes do projeto',
        inputSchema: {
          type: 'object',
          properties: {
            pattern: { type: 'string', description: 'Padr√£o de arquivo de teste' },
            watch: { type: 'boolean', default: false, description: 'Executar em modo watch' },
            coverage: { type: 'boolean', default: false, description: 'Gerar relat√≥rio de cobertura' }
          }
        }
      },
      {
        name: 'build_project',
        description: 'Construir o projeto',
        inputSchema: {
          type: 'object',
          properties: {
            mode: { 
              type: 'string', 
              enum: ['development', 'production'], 
              default: 'development',
              description: 'Modo de build'
            },
            clean: { type: 'boolean', default: false, description: 'Limpar antes do build' }
          }
        }
      }
    ];
  }
  
  async executeTool(name: string, args: any): Promise<ToolResult> {
    switch (name) {
      case 'git_commit':
        return this.gitCommit(args);
      case 'npm_install':
        return this.npmInstall(args);
      case 'run_tests':
        return this.runTests(args);
      case 'build_project':
        return this.buildProject(args);
      default:
        throw new Error(\`Ferramenta de desenvolvimento desconhecida: \${name}\`);
    }
  }
  
  private async gitCommit(args: any): Promise<ToolResult> {
    try {
      const commands = [];
      
      if (args.addAll) {
        commands.push('git add .');
      }
      
      commands.push(\`git commit -m "\${args.message}"\`);
      
      const results = [];
      for (const command of commands) {
        const result = await execAsync(command, { cwd: this.config.repositoryPath });
        results.push(result.stdout);
      }
      
      return {
        content: [
          {
            type: 'text',
            text: \`Commit git bem-sucedido:\\n\${results.join('\\n')}\`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Commit git falhou: \${error.message}\`
          }
        ],
        isError: true
      };
    }
  }
  
  private async npmInstall(args: any): Promise<ToolResult> {
    try {
      const flags = [];
      if (args.dev) flags.push('--save-dev');
      if (args.global) flags.push('--global');
      
      const command = \`npm install \${args.packages.join(' ')} \${flags.join(' ')}\`;
      const result = await execAsync(command, { 
        cwd: this.config.projectPath,
        timeout: 300000 // 5 minutos
      });
      
      return {
        content: [
          {
            type: 'text',
            text: \`Pacotes instalados com sucesso:\\n\${result.stdout}\`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`npm install falhou: \${error.message}\`
          }
        ],
        isError: true
      };
    }
  }
}`}
/>

### Ferramentas de Comunica√ß√£o

<CodeExample
  title="Ferramentas de Comunica√ß√£o"
  language="typescript"
  code={`// src/tools/communication.ts
export class CommunicationTools implements ToolProvider {
  getName() { return 'communication'; }
  
  getTools(): ToolDefinition[] {
    const tools = [
      {
        name: 'send_email',
        description: 'Enviar uma notifica√ß√£o por e-mail',
        inputSchema: {
          type: 'object',
          properties: {
            to: { type: 'string', description: 'Endere√ßo de e-mail do destinat√°rio' },
            subject: { type: 'string', description: 'Assunto do e-mail' },
            body: { type: 'string', description: 'Conte√∫do do corpo do e-mail' },
            priority: { 
              type: 'string', 
              enum: ['low', 'normal', 'high'], 
              default: 'normal',
              description: 'Prioridade do e-mail'
            }
          },
          required: ['to', 'subject', 'body']
        }
      }
    ];
    
    // Adicionar ferramentas Slack se token estiver configurado
    if (this.config.slackToken) {
      tools.push({
        name: 'slack_message',
        description: 'Enviar mensagem para canal Slack',
        inputSchema: {
          type: 'object',
          properties: {
            channel: { type: 'string', description: 'Nome ou ID do canal Slack' },
            message: { type: 'string', description: 'Texto da mensagem' },
            urgent: { type: 'boolean', default: false, description: 'Marcar como urgente' },
            threadId: { type: 'string', description: 'Responder a thread (opcional)' }
          },
          required: ['channel', 'message']
        }
      });
    }
    
    return tools;
  }
  
  async executeTool(name: string, args: any): Promise<ToolResult> {
    switch (name) {
      case 'send_email':
        return this.sendEmail(args);
      case 'slack_message':
        return this.sendSlackMessage(args);
      default:
        throw new Error(\`Ferramenta de comunica√ß√£o desconhecida: \${name}\`);
    }
  }
  
  private async sendSlackMessage(args: any): Promise<ToolResult> {
    try {
      const response = await fetch('https://slack.com/api/chat.postMessage', {
        method: 'POST',
        headers: {
          'Authorization': \`Bearer \${this.config.slackToken}\`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          channel: args.channel,
          text: args.message,
          thread_ts: args.threadId,
          ...(args.urgent && {
            attachments: [{
              color: 'danger',
              text: 'üö® MENSAGEM URGENTE üö®'
            }]
          })
        })
      });
      
      const result = await response.json();
      
      if (!result.ok) {
        throw new Error(result.error || 'Erro da API Slack');
      }
      
      return {
        content: [
          {
            type: 'text',
            text: \`Mensagem enviada para \${args.channel} com sucesso\`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Falha ao enviar mensagem Slack: \${error.message}\`
          }
        ],
        isError: true
      };
    }
  }
}`}
/>

## Testes e Implanta√ß√£o {#testing-deployment}

Um servidor de produ√ß√£o requer testes abrangentes e processos adequados de implanta√ß√£o.

<CodeExample
  title="Conjunto Abrangente de Testes"
  language="typescript"
  code={`// tests/integration/server.test.ts
import { MCPWorkspaceServer } from '../../src/index.js';
import { TestTransport } from '../utils/test-transport.js';

describe('Integra√ß√£o do Servidor MCP Workspace', () => {
  let server: MCPWorkspaceServer;
  let transport: TestTransport;
  
  beforeEach(async () => {
    // Configurar ambiente de teste
    process.env.NODE_ENV = 'test';
    
    server = new MCPWorkspaceServer();
    transport = new TestTransport();
    
    await server.start(transport);
  });
  
  afterEach(async () => {
    await server.shutdown();
  });
  
  describe('Recursos', () => {
    test('deve listar todos os recursos dispon√≠veis', async () => {
      const response = await transport.request('resources/list', {});
      
      expect(response.resources).toBeDefined();
      expect(Array.isArray(response.resources)).toBe(true);
      expect(response.resources.length).toBeGreaterThan(0);
    });
    
    test('deve ler recursos do sistema de arquivos', async () => {
      const response = await transport.request('resources/read', {
        uri: 'file://test-file.txt'
      });
      
      expect(response.contents).toBeDefined();
      expect(response.contents[0].text).toContain('conte√∫do de teste');
    });
    
    test('deve lidar com URIs de recurso inv√°lidos', async () => {
      await expect(
        transport.request('resources/read', { uri: 'invalid://uri' })
      ).rejects.toThrow('Nenhum provedor encontrado');
    });
  });
  
  describe('Ferramentas', () => {
    test('deve listar todas as ferramentas dispon√≠veis', async () => {
      const response = await transport.request('tools/list', {});
      
      expect(response.tools).toBeDefined();
      expect(Array.isArray(response.tools)).toBe(true);
      
      // Verificar ferramentas esperadas
      const toolNames = response.tools.map(t => t.name);
      expect(toolNames).toContain('read_file');
      expect(toolNames).toContain('write_file');
    });
    
    test('deve executar opera√ß√µes de arquivo', async () => {
      const response = await transport.request('tools/call', {
        name: 'write_file',
        arguments: {
          path: 'test-output.txt',
          content: 'Ol√°, MCP!'
        }
      });
      
      expect(response.isError).toBeFalsy();
      expect(response.content[0].text).toContain('Escrito com sucesso');
    });
    
    test('deve validar par√¢metros de ferramentas', async () => {
      await expect(
        transport.request('tools/call', {
          name: 'write_file',
          arguments: {
            // Faltando par√¢metro obrigat√≥rio 'content'
            path: 'test.txt'
          }
        })
      ).rejects.toThrow('Argumentos inv√°lidos');
    });
  });
  
  describe('Sa√∫de e Monitoramento', () => {
    test('deve fornecer status de sa√∫de', async () => {
      const response = await transport.request('health', {});
      
      expect(response.status).toBe('healthy');
      expect(response.providers).toBeGreaterThan(0);
      expect(response.tools).toBeGreaterThan(0);
    });
  });
});`}
/>

### Implanta√ß√£o Docker

<CodeExample
  title="Configura√ß√£o de Implanta√ß√£o de Produ√ß√£o"
  language="dockerfile"
  code={`# Dockerfile
FROM node:18-alpine

# Instalar git e outras depend√™ncias
RUN apk add --no-cache git

# Criar diret√≥rio da aplica√ß√£o
WORKDIR /app

# Copiar arquivos de pacote
COPY package*.json ./
COPY tsconfig.json ./

# Instalar depend√™ncias
RUN npm ci --only=production

# Copiar c√≥digo fonte
COPY src/ ./src/
COPY config/ ./config/

# Construir a aplica√ß√£o
RUN npm run build

# Criar usu√°rio n√£o-root
RUN addgroup -g 1001 -S nodejs
RUN adduser -S mcp -u 1001

# Criar diret√≥rio workspace
RUN mkdir -p /workspace && chown mcp:nodejs /workspace

# Mudar para usu√°rio n√£o-root
USER mcp

# Expor porta de health check (se usando transporte HTTP)
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node dist/health-check.js

# Iniciar o servidor
CMD ["npm", "start"]`}
/>

### Pipeline CI/CD

<CodeExample
  title="Workflow GitHub Actions"
  language="yaml"
  code={`# .github/workflows/ci.yml
name: Pipeline CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Usar Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Instalar depend√™ncias
      run: npm ci
    
    - name: Executar linting
      run: npm run lint
    
    - name: Executar verifica√ß√£o de tipos
      run: npm run type-check
    
    - name: Executar testes
      run: npm run test:coverage
    
    - name: Upload relat√≥rios de cobertura
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
  
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Construir imagem Docker
      run: docker build -t mcp-workspace-server .
    
    - name: Executar scan de seguran√ßa
      run: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image mcp-workspace-server
  
  deploy:
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Implantar em produ√ß√£o
      run: echo "Implantar no ambiente de produ√ß√£o"`}
/>

## Entreg√°veis do Projeto {#deliverables}

### Submiss√µes Obrigat√≥rias

Seu projeto final deve incluir:

1. **Implementa√ß√£o Completa do Servidor MCP**
   - Todos os 5 m√≥dulos integrados (configura√ß√£o, provedores, ferramentas, logging, monitoramento)
   - Tratamento de erros e medidas de seguran√ßa prontas para produ√ß√£o
   - Documenta√ß√£o abrangente

2. **Provedores de Recursos (m√≠nimo 3)**
   - Provedor de sistema de arquivos com controles de seguran√ßa
   - Provedor Git com integra√ß√£o de reposit√≥rio
   - Provedor de banco de dados com pool de conex√µes
   - Opcional: Provedor de API, provedor de configura√ß√£o

3. **Conjunto de Ferramentas (m√≠nimo 5 ferramentas)**
   - Opera√ß√µes de arquivo (ler, escrever, listar)
   - Ferramentas de desenvolvimento (git, npm, testes)
   - Ferramentas de comunica√ß√£o (e-mail, Slack)
   - Ferramentas de gerenciamento de projeto

4. **Testes e Qualidade**
   - Testes unit√°rios para componentes principais
   - Testes de integra√ß√£o para fluxos completos
   - Testes de performance para opera√ß√µes intensivas
   - Testes de seguran√ßa para valida√ß√£o de entrada

5. **Documenta√ß√£o**
   - README com instru√ß√µes de configura√ß√£o e uso
   - Documenta√ß√£o da API para todos os recursos e ferramentas
   - Guia de implanta√ß√£o com configura√ß√£o Docker
   - Documenta√ß√£o de arquitetura

6. **Configura√ß√£o de Implanta√ß√£o**
   - Containeriza√ß√£o Docker
   - Configura√ß√µes espec√≠ficas de ambiente
   - Configura√ß√£o de health checks e monitoramento
   - Pipeline CI/CD (GitHub Actions)

<Callout type="success">
  **Crit√©rios de Avalia√ß√£o**:
  - **Funcionalidade**: Todos os recursos funcionam conforme especificado
  - **Qualidade de C√≥digo**: C√≥digo limpo, bem organizado e documentado
  - **Seguran√ßa**: Valida√ß√£o adequada de entrada e medidas de seguran√ßa
  - **Testes**: Cobertura abrangente de testes
  - **Documenta√ß√£o**: Documenta√ß√£o clara e completa
  - **Prontid√£o para Produ√ß√£o**: Tratamento adequado de erros, logging e monitoramento
</Callout>

## Testando Sua Implementa√ß√£o

### Integra√ß√£o com Aplica√ß√µes de IA

Teste seu servidor com aplica√ß√µes de IA reais:

1. **Claude Desktop**: Configure seu servidor nas configura√ß√µes do Claude
2. **MCP Inspector**: Use a ferramenta oficial de testes
3. **Cliente de Teste Personalizado**: Construa um cliente de teste simples

<CodeExample
  title="Testando com Claude Desktop"
  language="json"
  code={`// Configura√ß√£o do Claude Desktop
{
  "mcpServers": {
    "workspace-server": {
      "command": "node",
      "args": ["caminho/para/seu/dist/index.js"],
      "env": {
        "NODE_ENV": "production",
        "MCP_LOG_LEVEL": "info"
      }
    }
  }
}`}
/>

### Teste de Performance

Teste seu servidor sob carga:

<CodeExample
  title="Script de Teste de Carga"
  language="javascript"
  code={`// Script de teste de carga
const { performance } = require('perf_hooks');

async function loadTest() {
  const requests = [];
  const startTime = performance.now();
  
  // Simular requisi√ß√µes concorrentes
  for (let i = 0; i < 100; i++) {
    requests.push(
      testResourceRequest(),
      testToolExecution()
    );
  }
  
  const results = await Promise.allSettled(requests);
  const endTime = performance.now();
  
  const successful = results.filter(r => r.status === 'fulfilled').length;
  const failed = results.filter(r => r.status === 'rejected').length;
  
  console.log(\`Teste de carga conclu√≠do em \${endTime - startTime}ms\`);
  console.log(\`Bem-sucedidas: \${successful}, Falhadas: \${failed}\`);
  console.log(\`Taxa de sucesso: \${(successful / results.length * 100).toFixed(2)}%\`);
}`}
/>

## Resumo e Pr√≥ximos Passos {#summary}

Parab√©ns! Voc√™ construiu um servidor MCP completo e pronto para produ√ß√£o que demonstra:

‚úÖ **Arquitetura Profissional**: Design modular, extens√≠vel e manuten√≠vel
‚úÖ **Integra√ß√£o Multi-Provedor**: Provedores de sistema de arquivos, Git, banco de dados e API
‚úÖ **Conjunto Abrangente de Ferramentas**: Ferramentas de desenvolvimento, comunica√ß√£o e gerenciamento de projetos
‚úÖ **Recursos de Produ√ß√£o**: Logging, monitoramento, tratamento de erros e seguran√ßa
‚úÖ **Garantia de Qualidade**: Testes, documenta√ß√£o e automa√ß√£o de implanta√ß√£o
‚úÖ **Prontid√£o para o Mundo Real**: Otimiza√ß√£o de performance e considera√ß√µes de escalabilidade

### O que Voc√™ Conquistou

Voc√™ conseguiu:
- Construir um servidor MCP completo do zero
- Integrar m√∫ltiplas fontes de dados e sistemas externos
- Implementar um conjunto abrangente de ferramentas para aplica√ß√µes de IA
- Aplicar pr√°ticas prontas para produ√ß√£o em todo o projeto
- Criar documenta√ß√£o e testes abrangentes

### Melhorias Futuras

Considere estes recursos avan√ßados para seu servidor:
- **Sistema de Plugins**: Permitir extens√µes de terceiros
- **Integra√ß√£o GraphQL**: Fornecer capacidades de consulta GraphQL
- **Suporte a Webhooks**: Atualiza√ß√µes em tempo real via webhooks
- **Suporte Multi-tenant**: Suportar m√∫ltiplos workspaces
- **Analytics Avan√ßado**: An√°lises detalhadas de uso e insights

### Aplica√ß√µes de Carreira

Este projeto demonstra habilidades valiosas para:
- **Engenharia de IA**: Construir sistemas integrados com IA
- **Desenvolvimento Backend**: Arquitetura de servidor de produ√ß√£o
- **DevOps**: Implanta√ß√£o, monitoramento e automa√ß√£o
- **Design de API**: Criar APIs amig√°veis para desenvolvedores
- **Integra√ß√£o de Sistemas**: Conectar sistemas diversos

<Callout type="success">
  **Parab√©ns!** Voc√™ completou o caminho de aprendizado de Fundamentos do Servidor MCP. Agora voc√™ tem as habilidades para construir integra√ß√µes sofisticadas de IA e contribuir para o crescente ecossistema de aplica√ß√µes habilitadas por IA.
</Callout>

## Recursos Adicionais {#resources}

- [Documenta√ß√£o Oficial do MCP](https://modelcontextprotocol.io/docs)
- [Melhores Pr√°ticas TypeScript](https://typescript-eslint.io/docs/linting/troubleshooting)
- [Pr√°ticas de Produ√ß√£o Node.js](https://nodejs.org/en/docs/guides/simple-profiling)
- [Melhores Pr√°ticas Docker](https://docs.docker.com/develop/dev-best-practices/)
- [Estrat√©gias de Teste](https://jestjs.io/docs/testing-strategies)

Compartilhe seu projeto conclu√≠do e conecte-se com outros desenvolvedores MCP na comunidade!