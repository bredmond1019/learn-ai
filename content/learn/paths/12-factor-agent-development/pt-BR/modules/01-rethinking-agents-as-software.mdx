---
title: "Repensando Agentes como Software"
moduleId: "01-rethinking-agents-as-software"
pathId: "12-factor-agent-development"
description: "Descubra por que a capacidade mais poderosa dos LLMs n√£o √© orquestra√ß√£o complexa‚Äî√© a simples extra√ß√£o JSON. Aprenda a ver al√©m da 'm√°gica' e entenda agentes como componentes de software determin√≠sticos."
duration: "90 minutos"
author: "Brandon J. Redmond"
---



# Repensando Agentes como Software

## Introdu√ß√£o {#introduction}

Bem-vindo ao primeiro m√≥dulo do Desenvolvimento de Agentes 12 Fatores. Antes de mergulharmos em arquiteturas complexas e padr√µes de orquestra√ß√£o, precisamos estabelecer uma verdade fundamental que transformar√° como voc√™ pensa sobre desenvolvimento de agentes.

<Callout type="story" title="Uma Jornada Comum">
Voc√™ provavelmente j√° passou por isso: Voc√™ come√ßa a construir um agente, pega um framework popular e, em poucas horas, est√° com 70-80% de funcionalidade. A demonstra√ß√£o √© impressionante. A equipe est√° animada. Recursos s√£o alocados.

Ent√£o a realidade bate. Aqueles √∫ltimos 20% se tornam um pesadelo. Voc√™ est√° depurando atrav√©s de camadas de abstra√ß√£o, tentando entender por que seu agente continua chamando a API errada ou ficando preso em loops. Eventualmente, voc√™ reescreve do zero ou percebe que agentes n√£o eram a solu√ß√£o certa.

**E se o problema n√£o fossem os agentes em si, mas como pensamos sobre eles?**
</Callout>

### A Revela√ß√£o

Ap√≥s analisar mais de 100 implementa√ß√µes de agentes em produ√ß√£o, um padr√£o claro emergiu: **Os agentes mais bem-sucedidos n√£o s√£o os mais "ag√™nticos"**. Eles s√£o principalmente software determin√≠stico com intera√ß√µes LLM cuidadosamente controladas em pontos espec√≠ficos de decis√£o.

As equipes que est√£o tendo sucesso n√£o est√£o usando os frameworks mais sofisticados. Elas est√£o aplicando princ√≠pios de engenharia de software a um novo dom√≠nio. E a base do seu sucesso? Entender que a coisa mais m√°gica que os LLMs podem fazer n√£o tem nada a ver com racioc√≠nio complexo ou comportamento aut√¥nomo.

√â muito mais simples que isso.

## Fator 1: Extra√ß√£o JSON √© Seu Superpoder {#json-extraction}

Vamos come√ßar com a capacidade mais fundamental que torna os agentes poss√≠veis:

<CodeExample title="A M√°gica da Extra√ß√£o JSON" language="python">
```python
# O que parece m√°gica...
user_input = "Agende uma reuni√£o com a Sara na pr√≥xima ter√ßa √†s 15h sobre o planejamento do Q4"

# ...√© realmente apenas esta transforma√ß√£o:
extracted_json = {
    "intent": "schedule_meeting",
    "participants": ["Sara"],
    "date": "proxima_terca",
    "time": "15:00",
    "topic": "planejamento do Q4"
}

# √â isso. Esse √© o superpoder.
```
</CodeExample>

### Por Que Isso Importa

Toda demonstra√ß√£o impressionante de agente, todo fluxo de trabalho complexo, todo comportamento "aut√¥nomo"‚Äîtudo se baseia nesta funda√ß√£o. LLMs se destacam em pegar linguagem humana n√£o estruturada e convert√™-la em dados estruturados com os quais o c√≥digo pode trabalhar.

<Diagram type="flow" title="A Realidade dos Agentes">
```mermaid
graph LR
    A[Entrada em Linguagem Natural] -->|LLM| B[JSON Estruturado]
    B -->|C√≥digo Regular| C[A√ß√µes Determin√≠sticas]
    C --> D[Resultados]
    D -->|Formatar| E[Sa√≠da em Linguagem Natural]
    
    style B fill:#f96,stroke:#333,stroke-width:4px
```
</Diagram>

### Construindo Seu Primeiro Extrator

Vamos construir um extrator JSON pr√°tico que voc√™ pode usar como funda√ß√£o:

<CodeExample title="Extrator JSON Pronto para Produ√ß√£o" language="python">
```python
import json
from typing import Dict, Any, Optional
from pydantic import BaseModel, ValidationError

class MeetingIntent(BaseModel):
    """Schema para inten√ß√µes relacionadas a reuni√µes"""
    intent: str
    participants: list[str]
    date: Optional[str] = None
    time: Optional[str] = None
    topic: Optional[str] = None
    duration_minutes: Optional[int] = 60

class JSONExtractor:
    def __init__(self, llm_client):
        self.llm = llm_client
        
    def extract(self, user_input: str, schema: type[BaseModel]) -> Dict[str, Any]:
        """Extrai dados estruturados de linguagem natural"""
        
        # Constr√≥i um prompt que guia o LLM a produzir JSON v√°lido
        prompt = self._build_extraction_prompt(user_input, schema)
        
        # Obt√©m resposta do LLM
        response = self.llm.complete(prompt)
        
        # Analisa e valida
        try:
            data = json.loads(response)
            validated = schema(**data)
            return validated.dict()
        except (json.JSONDecodeError, ValidationError) as e:
            # Trata erros graciosamente
            return self._handle_extraction_error(e, response, user_input)
    
    def _build_extraction_prompt(self, user_input: str, schema: type[BaseModel]) -> str:
        """Cria um prompt que produz JSON confi√°vel correspondente ao nosso schema"""
        
        schema_example = schema.schema()
        
        return f"""Extraia informa√ß√µes estruturadas da mensagem do usu√°rio.

Mensagem do Usu√°rio: {user_input}

Responda com um objeto JSON que corresponda a este schema:
{json.dumps(schema_example, indent=2)}

Importante:
- Produza APENAS JSON v√°lido, nenhum texto adicional
- Inclua todos os campos que podem ser inferidos da mensagem
- Use null para campos que n√£o podem ser determinados
- Garanta que a sa√≠da possa ser analisada por json.loads()

Sa√≠da JSON:"""

# Uso
extractor = JSONExtractor(llm_client)
user_message = "Configure uma chamada de 30 minutos com a equipe de engenharia amanh√£ √†s 14h"

result = extractor.extract(user_message, MeetingIntent)
print(result)
# {
#     "intent": "schedule_meeting",
#     "participants": ["equipe de engenharia"],
#     "date": "amanh√£",
#     "time": "14:00",
#     "topic": null,
#     "duration_minutes": 30
# }
```
</CodeExample>

### O Poder do Desenvolvimento Orientado por Schema

Observe como estamos usando modelos Pydantic para definir nossa estrutura de sa√≠da esperada? Isso nos d√°:

1. **Seguran√ßa de tipos**: Sabemos exatamente com quais dados estamos trabalhando
2. **Valida√ß√£o**: Sa√≠das inv√°lidas s√£o capturadas imediatamente
3. **Documenta√ß√£o**: O schema serve como documenta√ß√£o
4. **Flexibilidade**: F√°cil de estender ou modificar conforme os requisitos mudam

<Callout type="tip" title="Dica Pro: Comece Simples">
N√£o tente extrair tudo de uma vez. Comece com o m√≠nimo absoluto de campos que voc√™ precisa, fa√ßa isso funcionar de forma confi√°vel, depois adicione complexidade gradualmente. √â muito mais f√°cil depurar um schema com 3 campos do que um com 30.
</Callout>

## Fator 4: 'Uso de Ferramentas' √© Apenas JSON e C√≥digo {#tools-are-code}

Agora vamos abordar uma das abstra√ß√µes mais enganosas no desenvolvimento de agentes: "uso de ferramentas."

### A Abstra√ß√£o Prejudicial

Quando frameworks falam sobre agentes "usando ferramentas", isso cria um modelo mental de alguma entidade de IA et√©rea alcan√ßando o mundo. Esta abstra√ß√£o:

- Torna a depura√ß√£o mais dif√≠cil (o que est√° realmente acontecendo?)
- Esconde a simples realidade do que est√° acontecendo
- Leva a engenharia excessiva e complexidade desnecess√°ria

### A Realidade

Aqui est√° o que "uso de ferramentas" realmente √©:

<CodeExample title="Desmistificando o Uso de Ferramentas" language="python">
```python
# O que frameworks chamam de "uso de ferramentas"...
@tool
def send_email(to: str, subject: str, body: str):
    """Envia um email para um destinat√°rio"""
    # ... implementa√ß√£o ...

# ...√© realmente apenas isso:
def handle_agent_action(llm_output: dict):
    """Roteia sa√≠da JSON para fun√ß√µes apropriadas"""
    
    action = llm_output.get("action")
    params = llm_output.get("parameters", {})
    
    # Apenas uma instru√ß√£o switch!
    match action:
        case "send_email":
            return send_email(**params)
        case "schedule_meeting":
            return schedule_meeting(**params)
        case "query_database":
            return query_database(**params)
        case "respond_to_user":
            return {"type": "message", "content": llm_output["message"]}
        case _:
            return {"type": "error", "message": f"A√ß√£o desconhecida: {action}"}

# O LLM produz JSON como:
{
    "action": "send_email",
    "parameters": {
        "to": "sara@empresa.com",
        "subject": "Reuni√£o de Planejamento Q4",
        "body": "Oi Sara, confirmando nossa reuni√£o para pr√≥xima ter√ßa √†s 15h..."
    },
    "reasoning": "Usu√°rio quer agendar uma reuni√£o, devo enviar um email de confirma√ß√£o"
}

# Seu c√≥digo roteia para a fun√ß√£o certa. √â isso!
```
</CodeExample>

### Construindo um Roteador de Produ√ß√£o

Vamos construir um roteador de a√ß√µes mais robusto que voc√™ realmente usaria em produ√ß√£o:

<CodeExample title="Roteador de A√ß√µes de Produ√ß√£o" language="python">
```python
from typing import Dict, Any, Callable, Optional
from dataclasses import dataclass
import logging

@dataclass
class ActionResult:
    """Resultado da execu√ß√£o de uma a√ß√£o"""
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    metadata: Dict[str, Any] = None

class ActionRouter:
    """Roteia a√ß√µes geradas por LLM para manipuladores apropriados"""
    
    def __init__(self):
        self.handlers: Dict[str, Callable] = {}
        self.logger = logging.getLogger(__name__)
        
    def register(self, action_name: str, handler: Callable) -> None:
        """Registra um manipulador para uma a√ß√£o"""
        self.handlers[action_name] = handler
        
    async def route(self, llm_output: Dict[str, Any]) -> ActionResult:
        """Roteia uma sa√≠da LLM para o manipulador apropriado"""
        
        # Extrai a√ß√£o e par√¢metros
        action = llm_output.get("action")
        if not action:
            return ActionResult(
                success=False,
                error="Nenhuma a√ß√£o especificada na sa√≠da do LLM"
            )
        
        # Encontra manipulador
        handler = self.handlers.get(action)
        if not handler:
            return ActionResult(
                success=False,
                error=f"Nenhum manipulador registrado para a√ß√£o: {action}",
                metadata={"available_actions": list(self.handlers.keys())}
            )
        
        # Executa com tratamento de erros
        try:
            params = llm_output.get("parameters", {})
            
            # Log para depura√ß√£o
            self.logger.info(f"Executando a√ß√£o: {action} com params: {params}")
            
            # Executa manipulador
            result = await handler(**params) if asyncio.iscoroutinefunction(handler) else handler(**params)
            
            return ActionResult(
                success=True,
                data=result,
                metadata={
                    "action": action,
                    "reasoning": llm_output.get("reasoning")
                }
            )
            
        except Exception as e:
            self.logger.error(f"Erro executando {action}: {str(e)}")
            return ActionResult(
                success=False,
                error=str(e),
                metadata={"action": action, "error_type": type(e).__name__}
            )

# Uso
router = ActionRouter()

# Registre suas "ferramentas" (tamb√©m conhecidas como fun√ß√µes)
router.register("send_email", email_service.send)
router.register("schedule_meeting", calendar_service.schedule)
router.register("query_database", db.query)

# Roteie sa√≠da do LLM
llm_output = {
    "action": "send_email",
    "parameters": {
        "to": "equipe@empresa.com",
        "subject": "Atualiza√ß√µes",
        "body": "Aqui est√£o as atualiza√ß√µes desta semana..."
    },
    "reasoning": "Usu√°rio pediu para atualizar a equipe"
}

result = await router.route(llm_output)
if result.success:
    print(f"A√ß√£o conclu√≠da: {result.data}")
else:
    print(f"A√ß√£o falhou: {result.error}")
```
</CodeExample>

### Os Benef√≠cios de Pensar Desta Forma

Quando voc√™ para de pensar em "uso de ferramentas" e come√ßa a pensar em "roteamento JSON":

1. **A depura√ß√£o se torna trivial**: Voc√™ pode registrar o JSON exato e ver qual fun√ß√£o √© chamada
2. **O teste √© direto**: Apenas teste seu roteador com diferentes entradas JSON
3. **Sem m√°gica**: Tudo √© expl√≠cito e sob seu controle
4. **F√°cil de estender**: Adicionar uma nova "ferramenta" √© apenas registrar uma nova fun√ß√£o

<Quiz id="tools-are-code-quiz">
  <Question
    question="Se um agente 'usa uma ferramenta' para enviar um email, qual √© o fluxo de execu√ß√£o real?"
    options={[
      "O LLM chama diretamente a API de email",
      "O framework magicamente lida com tudo",
      "O LLM produz JSON, que seu c√≥digo roteia para uma fun√ß√£o de email",
      "O agente ganha capacidades de envio de email"
    ]}
    correctAnswer={2}
    explanation="O LLM produz JSON estruturado indicando que quer enviar um email. Seu c√≥digo de roteamento recebe este JSON e chama a fun√ß√£o de email apropriada com os par√¢metros fornecidos. N√£o h√° m√°gica‚Äîapenas JSON e chamadas de fun√ß√£o."
  />
  <Question
    question="Por que pensar em 'uso de ferramentas' como uma abstra√ß√£o prejudicial?"
    options={[
      "Faz os agentes parecerem mais complexos do que s√£o",
      "Esconde o simples roteamento JSON-para-fun√ß√£o que est√° realmente acontecendo",
      "Impede depura√ß√£o e testes adequados",
      "Todas as anteriores"
    ]}
    correctAnswer={3}
    explanation="A abstra√ß√£o de 'uso de ferramentas' √© prejudicial porque: 1) Torna a depura√ß√£o mais dif√≠cil ao esconder o que est√° realmente acontecendo, 2) Cria um modelo mental falso de entidades de IA com poderes especiais, 3) Leva a engenharia excessiva, e 4) Impede que desenvolvedores vejam o simples padr√£o de roteamento JSON que est√° realmente em funcionamento."
  />
</Quiz>

## Juntando Tudo: Seu Primeiro Componente de Agente Real

Vamos combinar extra√ß√£o JSON e roteamento de a√ß√µes em um componente de agente simples mas completo:

<CodeExample title="Componente de Agente Completo" language="python">
```python
class SimpleAgent:
    """Um agente simples que extrai inten√ß√£o e roteia para a√ß√µes"""
    
    def __init__(self, llm_client):
        self.llm = llm_client
        self.router = ActionRouter()
        self.extractor = JSONExtractor(llm_client)
        
        # Registra a√ß√µes dispon√≠veis
        self._register_actions()
        
    def _register_actions(self):
        """Registra todas as a√ß√µes dispon√≠veis"""
        self.router.register("send_email", self._send_email)
        self.router.register("schedule_meeting", self._schedule_meeting)
        self.router.register("search_knowledge_base", self._search_kb)
        self.router.register("respond", self._respond)
        
    async def process(self, user_input: str) -> Dict[str, Any]:
        """Processa entrada do usu√°rio e executa a√ß√£o apropriada"""
        
        # Passo 1: Extrai inten√ß√£o estruturada da linguagem natural
        extracted = self.extractor.extract(user_input, AgentAction)
        
        # Passo 2: Roteia para manipulador apropriado
        result = await self.router.route(extracted)
        
        # Passo 3: Formata resposta
        if result.success:
            return {
                "status": "success",
                "action_taken": result.metadata["action"],
                "result": result.data
            }
        else:
            return {
                "status": "error",
                "error": result.error,
                "fallback": self._generate_fallback_response(user_input)
            }
    
    def _generate_fallback_response(self, user_input: str) -> str:
        """Gera resposta √∫til quando roteamento de a√ß√£o falha"""
        prompt = f"""O usu√°rio disse: "{user_input}"
        
N√£o conseguimos processar isso como uma a√ß√£o espec√≠fica. Gere uma resposta √∫til que:
1. Reconhe√ßa a solicita√ß√£o deles
2. Explique quais a√ß√µes est√£o dispon√≠veis
3. Pe√ßa esclarecimento se necess√°rio

Resposta:"""
        
        return self.llm.complete(prompt)

# Usando seu agente
agent = SimpleAgent(llm_client)

response = await agent.process("Voc√™ pode enviar um email para Jo√£o sobre a reuni√£o de amanh√£?")
print(response)
# {
#     "status": "success",
#     "action_taken": "send_email",
#     "result": {"email_id": "12345", "sent": True}
# }
```
</CodeExample>

## Principais Aprendizados

Ao encerrarmos este primeiro m√≥dulo, lembre-se destes pontos cruciais:

<Card className="mb-4">
  <h3 className="text-xl font-semibold mb-2">üéØ A Funda√ß√£o</h3>
  <p>A capacidade mais poderosa dos LLMs em sistemas de agentes n√£o √© racioc√≠nio complexo‚Äî√© converter de forma confi√°vel linguagem natural em JSON estruturado com o qual seu c√≥digo pode trabalhar.</p>
</Card>

<Card className="mb-4">
  <h3 className="text-xl font-semibold mb-2">üîß Ferramentas S√£o Apenas Fun√ß√µes</h3>
  <p>"Uso de ferramentas" √© uma abstra√ß√£o prejudicial. √â realmente apenas JSON sendo roteado para fun√ß√µes. Quando voc√™ entende isso, a depura√ß√£o se torna trivial e as extens√µes se tornam √≥bvias.</p>
</Card>

<Card className="mb-4">
  <h3 className="text-xl font-semibold mb-2">üèóÔ∏è Agentes S√£o Software</h3>
  <p>Pare de pensar em agentes como entidades m√°gicas de IA. Eles s√£o componentes de software que usam LLMs para transforma√ß√µes espec√≠ficas. Essa mudan√ßa mental torna tudo mais claro.</p>
</Card>

## O Que Vem a Seguir?

No pr√≥ximo m√≥dulo, exploraremos os Fatores 6 e 7: como gerenciar adequadamente o fluxo de controle e o estado em sistemas de agentes. Voc√™ aprender√° por que a abordagem ing√™nua de "anexar tudo ao contexto" falha e como construir agentes que podem ser pausados, retomados e depurados como qualquer outro software.

Mas primeiro, complete o exerc√≠cio abaixo para solidificar sua compreens√£o de extra√ß√£o JSON e roteamento de a√ß√µes.

---

<Callout type="assignment" title="Exerc√≠cio do M√≥dulo: Construa um Classificador de Inten√ß√£o do Cliente">
Sua tarefa √© construir um sistema simples mas robusto que:
1. Extrai inten√ß√£o do cliente de mensagens de suporte
2. Roteia para manipuladores apropriados (responder, escalar, pesquisar_kb)
3. Trata erros graciosamente
4. Fornece respostas de fallback √∫teis
</Callout>

## Exerc√≠cio: Classificador de Inten√ß√£o do Cliente

Construa um agente de suporte ao cliente pronto para produ√ß√£o que demonstre os princ√≠pios deste m√≥dulo.

### Requisitos

Seu sistema deve:
1. Extrair inten√ß√£o e entidades de mensagens de clientes
2. Rotear para manipuladores de a√ß√£o apropriados
3. Tratar casos extremos e erros graciosamente
4. Fornecer respostas de fallback √∫teis

### C√≥digo Inicial

<CodeExample title="Classificador de Inten√ß√£o do Cliente - C√≥digo Inicial" language="python">
```python
from typing import Dict, Any, Optional, List
from enum import Enum
from pydantic import BaseModel, Field
import json

# Define o schema de inten√ß√£o
class CustomerIntent(BaseModel):
    """Schema para inten√ß√µes de suporte ao cliente"""
    intent: str = Field(..., description="A inten√ß√£o principal: pergunta, reclama√ß√£o, solicita√ß√£o ou feedback")
    urgency: str = Field(default="normal", description="N√≠vel de urg√™ncia: baixo, normal, alto, cr√≠tico")
    category: Optional[str] = Field(None, description="Categoria: cobran√ßa, t√©cnico, conta, geral")
    entities: Dict[str, Any] = Field(default_factory=dict, description="Entidades extra√≠das como order_id, product_name")
    sentiment: str = Field(default="neutral", description="Sentimento do cliente: positivo, neutro, negativo")
    
class ActionType(Enum):
    RESPOND = "respond"
    ESCALATE = "escalate"
    SEARCH_KB = "search_kb"
    TRANSFER = "transfer"

# TODO: Implementar o JSONExtractor para CustomerIntent
class CustomerIntentExtractor:
    def __init__(self, llm_client):
        self.llm = llm_client
        
    def extract(self, message: str) -> CustomerIntent:
        """Extrai inten√ß√£o do cliente da mensagem"""
        # TODO: Construir prompt que extrai CustomerIntent
        # TODO: Chamar LLM e analisar resposta
        # TODO: Validar com modelo Pydantic
        pass

# TODO: Implementar o ActionRouter
class CustomerSupportRouter:
    def __init__(self):
        self.handlers = {}
        self._register_handlers()
        
    def _register_handlers(self):
        """Registra todos os manipuladores dispon√≠veis"""
        # TODO: Registrar manipuladores para cada ActionType
        pass
        
    def route(self, intent: CustomerIntent) -> Dict[str, Any]:
        """Roteia inten√ß√£o para manipulador apropriado"""
        # TODO: Determinar a√ß√£o baseada na inten√ß√£o
        # TODO: Executar manipulador apropriado
        # TODO: Retornar resultado com tratamento adequado de erros
        pass
    
    # M√©todos manipuladores para implementar
    def _handle_respond(self, intent: CustomerIntent) -> Dict[str, Any]:
        """Gera resposta direta ao cliente"""
        # TODO: Implementar gera√ß√£o de resposta
        pass
        
    def _handle_escalate(self, intent: CustomerIntent) -> Dict[str, Any]:
        """Escala para agente humano"""
        # TODO: Implementar l√≥gica de escala√ß√£o
        pass
        
    def _handle_search_kb(self, intent: CustomerIntent) -> Dict[str, Any]:
        """Pesquisa base de conhecimento por informa√ß√µes relevantes"""
        # TODO: Implementar pesquisa KB
        pass

# TODO: Implementar o CustomerSupportAgent principal
class CustomerSupportAgent:
    def __init__(self, llm_client):
        self.extractor = CustomerIntentExtractor(llm_client)
        self.router = CustomerSupportRouter()
        
    def process_message(self, message: str) -> Dict[str, Any]:
        """Processa mensagem de cliente de ponta a ponta"""
        # TODO: Extrair inten√ß√£o
        # TODO: Rotear para manipulador
        # TODO: Formatar resposta
        # TODO: Tratar erros com fallback
        pass

# Casos de teste para tratar
test_messages = [
    "Fui cobrado duas vezes pelo meu pedido #12345!",
    "Como fa√ßo para redefinir minha senha?",
    "Seu servi√ßo √© incr√≠vel, obrigado!",
    "URGENTE: Site est√° fora do ar, perdendo clientes!!!",
    "Voc√™ pode me ajudar a rastrear o pedido 98765?",
    "Quero falar com um gerente imediatamente",
    "Quais s√£o os hor√°rios comerciais?",
    "Relat√≥rio de bug: Bot√£o de login n√£o funciona no celular"
]
```
</CodeExample>

### Dicas de Implementa√ß√£o

1. **Para Extra√ß√£o de Inten√ß√£o**:
   - Use exemplos claros em seu prompt
   - Considere usar exemplos few-shot
   - Valide n√≠veis de urg√™ncia cuidadosamente

2. **Para L√≥gica de Roteamento**:
   - Alta urg√™ncia + reclama√ß√£o = escalar
   - Perguntas = pesquisar KB primeiro, depois responder
   - Problemas cr√≠ticos = escala√ß√£o imediata

3. **Para Tratamento de Erros**:
   - Sempre tenha uma resposta de fallback
   - Registre erros para depura√ß√£o
   - Nunca exponha erros internos aos clientes

### Exemplo de Sa√≠da Esperada

```python
# Entrada
message = "Fui cobrado duas vezes pelo meu pedido #12345!"

# Inten√ß√£o extra√≠da esperada
{
    "intent": "reclama√ß√£o",
    "urgency": "alto",
    "category": "cobran√ßa",
    "entities": {"order_id": "12345", "issue": "cobran√ßa_duplicada"},
    "sentiment": "negativo"
}

# Decis√£o de roteamento esperada
{
    "action": "escalate",
    "reason": "Reclama√ß√£o de cobran√ßa de alta urg√™ncia",
    "data": {
        "priority": 1,
        "department": "cobran√ßa",
        "initial_response": "Entendo sua preocupa√ß√£o sobre a cobran√ßa duplicada..."
    }
}
```

### Desafios B√¥nus

1. **Adicionar contexto de conversa**: Manter contexto entre m√∫ltiplas mensagens
2. **Implementar pontua√ß√£o de confian√ßa**: Adicionar n√≠veis de confian√ßa √† extra√ß√£o de inten√ß√£o
3. **Suporte multi-idioma**: Lidar com mensagens em diferentes idiomas
4. **Limita√ß√£o de taxa**: Prevenir abuso com limita√ß√£o de taxa por cliente

### Discuss√£o da Solu√ß√£o

<details>
<summary>Clique para ver a abordagem da solu√ß√£o</summary>

Os principais insights para este exerc√≠cio:

1. **Extra√ß√£o de inten√ß√£o √© mais que apenas classifica√ß√£o** - voc√™ precisa extrair m√∫ltiplas dimens√µes (inten√ß√£o, urg√™ncia, entidades)

2. **A l√≥gica de roteamento deve ser expl√≠cita e test√°vel** - evite esconder regras de neg√≥cio em prompts

3. **O tratamento de erros √© cr√≠tico** - clientes devem sempre receber uma resposta √∫til, mesmo quando as coisas d√£o errado

4. **As camadas de abstra√ß√£o importam**:
   - Camada de extra√ß√£o (intera√ß√£o com LLM)
   - Camada de roteamento (l√≥gica de neg√≥cio)  
   - Camada de manipulador (a√ß√µes)
   - Camada de agente (orquestra√ß√£o)

Esta separa√ß√£o torna o sistema mant√≠vel, test√°vel e extens√≠vel.

</details>