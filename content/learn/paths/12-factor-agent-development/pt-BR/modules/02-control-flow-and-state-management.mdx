---
title: "Fluxo de Controle e Gerenciamento de Estado"
moduleId: "02-control-flow-and-state-management"
pathId: "12-factor-agent-development"
description: "Domine a arte de construir agentes sem estado e paus√°veis. Aprenda por que controlar seu fluxo √© a chave para confiabilidade, e como separar estado de neg√≥cio do estado de execu√ß√£o para sistemas de agentes prontos para produ√ß√£o."
duration: "120 minutos"
author: "Brandon J. Redmond"
---



# Fluxo de Controle e Gerenciamento de Estado

## O Problema do Fluxo de Controle {#introduction}

No M√≥dulo 1, descobrimos que agentes s√£o fundamentalmente sobre extra√ß√£o JSON. Mas saber como extrair dados estruturados √© apenas o come√ßo. O verdadeiro desafio? Gerenciar o que acontece depois.

<Callout type="warning" title="A Armadilha da Janela de Contexto">
Imagine isto: Seu agente come√ßa a processar uma solicita√ß√£o de cliente. Chama uma API, adiciona o resultado ao contexto. Chama outra API, adiciona isso tamb√©m. Verifica estoque, adiciona. Gera uma resposta, adiciona. 

Cinco passos depois, sua janela de contexto est√° explodindo. Dez passos depois, o LLM est√° confuso. Vinte passos? Voc√™ atingiu o limite de tokens e tudo trava.

**√â por isso que 70% dos projetos de agentes falham em chegar √† produ√ß√£o.**
</Callout>

A solu√ß√£o n√£o s√£o janelas de contexto maiores ou modelos mais inteligentes. √â controlar seu fluxo e gerenciar estado como o engenheiro de software que voc√™ √©.

### O Que Voc√™ Construir√°

Ao final deste m√≥dulo, voc√™ entender√°:
- Por que agentes s√£o apenas quatro componentes simples trabalhando juntos
- Como construir agentes que podem pausar no meio da execu√ß√£o e retomar horas depois
- A diferen√ßa cr√≠tica entre estado de neg√≥cio e estado de execu√ß√£o
- Padr√µes de fluxo de controle que evitam os desastres acima

Vamos come√ßar entendendo o que um agente realmente √©.

## Fator 6: Controle Seu Fluxo {#own-your-control-flow}

### A Abordagem Ing√™nua (E Por Que Ela Falha)

Aqui est√° como a maioria das pessoas constr√≥i seu primeiro agente:

<CodeExample title="O Loop de Agente Ing√™nuo" language="python">
```python
def naive_agent_loop(user_input: str, llm_client):
    """O agente mais simples poss√≠vel - e por que n√£o escala"""
    context = [{"role": "user", "content": user_input}]
    
    while True:
        # Pergunta ao LLM o que fazer em seguida
        response = llm_client.complete(context)
        action = extract_json(response)
        
        if action["type"] == "done":
            return action["result"]
        
        # Executa a a√ß√£o
        result = execute_tool(action["tool"], action["args"])
        
        # Adiciona tudo ao contexto (AQUI EST√Å O PROBLEMA!)
        context.append({"role": "assistant", "content": response})
        context.append({"role": "user", "content": f"Resultado: {result}"})
```
</CodeExample>

Isso funciona √≥timo para demonstra√ß√µes. Falha catastroficamente em produ√ß√£o. Por qu√™?

<Diagram type="flow" title="Explos√£o da Janela de Contexto">
```mermaid
graph TD
    A[Passo 1: 500 tokens] -->|Adiciona resultado| B[Passo 2: 1.200 tokens]
    B -->|Adiciona resultado| C[Passo 3: 2.100 tokens]
    C -->|Adiciona resultado| D[Passo 4: 3.500 tokens]
    D -->|Adiciona resultado| E[Passo 5: 5.200 tokens]
    E -->|Adiciona resultado| F[Passo 6: 7.800 tokens]
    F -->|üí•| G[Limite de Contexto Excedido]
    
    style G fill:#f66,stroke:#333,stroke-width:4px
```
</Diagram>

### Os Quatro Componentes de Todo Agente

Ap√≥s analisar centenas de agentes em produ√ß√£o, aqui est√° a verdade: **Todo agente √© apenas estes quatro componentes**:

<CodeExample title="A Equa√ß√£o do Agente" language="python">
```python
class Agent:
    """O que um agente REALMENTE √©"""
    
    def __init__(self):
        # 1. PROMPT: Instru√ß√µes para selecionar pr√≥ximo passo
        self.prompt = "Dado o hist√≥rico, o que devemos fazer em seguida?"
        
        # 2. SWITCH: Roteia JSON para c√≥digo real
        self.switch = {
            "pesquisar_estoque": self.pesquisar_estoque,
            "processar_pedido": self.processar_pedido,
            "contatar_humano": self.contatar_humano,
        }
        
        # 3. CONTEXTO: Mem√≥ria gerenciada (n√£o apenas anexando!)
        self.context_manager = ContextManager()
        
        # 4. LOOP: Controla quando/como continuar
        self.loop_controller = LoopController()
```
</CodeExample>

√â isso. Sem m√°gica. Apenas software.

### Assumindo o Controle do Seu Loop

Aqui est√° como agentes de produ√ß√£o realmente gerenciam fluxo de controle:

<CodeExample title="Fluxo de Controle de Produ√ß√£o" language="python">
```python
class ProductionAgent:
    def __init__(self, llm_client, max_steps=20):
        self.llm = llm_client
        self.max_steps = max_steps
        
    def run(self, task: str) -> dict:
        """Agente pronto para produ√ß√£o com fluxo de controle gerenciado"""
        state = {
            "task": task,
            "steps": [],
            "context_summary": "",
            "step_count": 0,
            "status": "running"
        }
        
        while state["status"] == "running":
            # Verifica condi√ß√µes do loop PRIMEIRO
            if state["step_count"] >= self.max_steps:
                state["status"] = "max_steps_exceeded"
                break
                
            # Constr√≥i contexto inteligentemente
            context = self._build_smart_context(state)
            
            # Obt√©m pr√≥xima a√ß√£o
            response = self.llm.complete(context)
            action = extract_json(response)
            
            # Executa com tratamento adequado de erros
            try:
                result = self._execute_action(action)
                state["steps"].append({
                    "action": action,
                    "result": result,
                    "timestamp": time.time()
                })
            except Exception as e:
                state["status"] = "error"
                state["error"] = str(e)
                break
            
            # Atualiza estado
            state["step_count"] += 1
            
            # Gerencia janela de contexto proativamente
            if self._should_summarize(state):
                state["context_summary"] = self._summarize_progress(state)
                state["steps"] = state["steps"][-3:]  # Mant√©m apenas passos recentes
            
            # Verifica conclus√£o
            if action.get("type") == "complete":
                state["status"] = "completed"
                state["result"] = action.get("result")
        
        return state
    
    def _build_smart_context(self, state: dict) -> list:
        """Constr√≥i contexto que n√£o explodir√°"""
        messages = []
        
        # Prompt do sistema com tarefa
        messages.append({
            "role": "system",
            "content": f"Tarefa: {state['task']}\n\nVoc√™ est√° no passo {state['step_count'] + 1} de no m√°ximo {self.max_steps}."
        })
        
        # Inclui resumo se tivermos um
        if state["context_summary"]:
            messages.append({
                "role": "user",
                "content": f"Resumo do progresso: {state['context_summary']}"
            })
        
        # Inclui apenas passos recentes
        for step in state["steps"][-3:]:
            messages.append({
                "role": "user",
                "content": f"Passo {step['action']['type']}: {step['result']}"
            })
        
        return messages
```
</CodeExample>

### Padr√µes Chave de Fluxo de Controle

<Callout type="success" title="Padr√µes de Produ√ß√£o que Funcionam">
1. **Limita√ß√£o de Passos**: Sempre imponha passos m√°ximos para evitar loops infinitos
2. **Sumariza√ß√£o de Contexto**: Comprima hist√≥rico antes de atingir limites  
3. **Condi√ß√µes de Sa√≠da Antecipada**: Verifique erros, timeouts e sinais de parada
4. **Mem√≥ria Seletiva**: Mantenha apenas passos recentes e relevantes no contexto
5. **Pontos de Interrup√ß√£o**: Adicione checkpoints onde o agente pode pausar para entrada humana
</Callout>

## Fator 7: Design de Agente Sem Estado {#stateless-design}

### Por Que Sem Estado?

A engenharia de software tradicional nos ensinou que servi√ßos sem estado s√£o mais confi√°veis, escal√°veis e mant√≠veis. O mesmo se aplica aos agentes.

<Diagram type="architecture" title="Arquitetura de Agente Sem Estado">
```mermaid
graph LR
    A[Requisi√ß√£o HTTP] --> B[Carregar Estado]
    B --> C[L√≥gica do Agente]
    C --> D{Opera√ß√£o Longa?}
    D -->|Sim| E[Serializar Estado]
    E --> F[Retornar ID do Estado]
    D -->|N√£o| G[Completar]
    G --> H[Retornar Resultado]
    
    I[Requisi√ß√£o de Callback] --> J[Carregar Estado por ID]
    J --> C
    
    style E fill:#6f9,stroke:#333,stroke-width:2px
    style B fill:#6f9,stroke:#333,stroke-width:2px
```
</Diagram>

### Construindo Agentes Paus√°veis

Aqui est√° como implementar um agente que pode pausar e retomar:

<CodeExample title="Implementa√ß√£o de Agente Paus√°vel" language="python">
```python
import json
import uuid
from typing import Optional, Dict, Any
from dataclasses import dataclass, asdict

@dataclass
class AgentState:
    """Estado serializ√°vel do agente"""
    id: str
    task: str
    steps: list
    context_summary: str
    step_count: int
    status: str
    metadata: dict
    
    def to_json(self) -> str:
        return json.dumps(asdict(self))
    
    @classmethod
    def from_json(cls, data: str) -> 'AgentState':
        return cls(**json.loads(data))

class PausableAgent:
    def __init__(self, llm_client, state_store):
        self.llm = llm_client
        self.state_store = state_store
        
    async def start_task(self, task: str, metadata: dict = None) -> str:
        """Inicia uma nova tarefa e retorna ID do estado"""
        state = AgentState(
            id=str(uuid.uuid4()),
            task=task,
            steps=[],
            context_summary="",
            step_count=0,
            status="running",
            metadata=metadata or {}
        )
        
        # Salva estado inicial
        await self.state_store.save(state.id, state.to_json())
        
        # Tenta fazer progresso
        state = await self._execute_steps(state, max_steps=5)
        
        # Salva estado atualizado
        await self.state_store.save(state.id, state.to_json())
        
        return state.id
    
    async def resume_task(self, state_id: str, additional_info: str = None) -> dict:
        """Retoma uma tarefa pausada"""
        # Carrega estado
        state_json = await self.state_store.load(state_id)
        state = AgentState.from_json(state_json)
        
        # Adiciona qualquer informa√ß√£o nova
        if additional_info:
            state.steps.append({
                "type": "human_input",
                "content": additional_info,
                "timestamp": time.time()
            })
        
        # Continua execu√ß√£o
        state = await self._execute_steps(state, max_steps=5)
        
        # Salva estado atualizado
        await self.state_store.save(state.id, state.to_json())
        
        return {
            "state_id": state.id,
            "status": state.status,
            "result": state.metadata.get("result")
        }
    
    async def _execute_steps(self, state: AgentState, max_steps: int) -> AgentState:
        """Executa at√© max_steps, lidando com interrup√ß√µes"""
        steps_executed = 0
        
        while state.status == "running" and steps_executed < max_steps:
            # Constr√≥i contexto do estado
            context = self._build_context_from_state(state)
            
            # Obt√©m pr√≥xima a√ß√£o
            response = await self.llm.complete(context)
            action = extract_json(response)
            
            # Verifica se a√ß√£o requer aprova√ß√£o humana
            if action.get("requires_approval"):
                state.status = "awaiting_approval"
                state.metadata["pending_action"] = action
                break
            
            # Executa a√ß√£o
            result = await self._execute_action(action)
            
            # Atualiza estado
            state.steps.append({
                "action": action,
                "result": result,
                "timestamp": time.time()
            })
            state.step_count += 1
            steps_executed += 1
            
            # Verifica conclus√£o
            if action.get("type") == "complete":
                state.status = "completed"
                state.metadata["result"] = result
                break
        
        return state
```
</CodeExample>

### Estrat√©gias de Serializa√ß√£o de Estado

Nem todo estado √© criado igual. Aqui est√° como serializar eficientemente:

<CodeExample title="Padr√µes de Serializa√ß√£o de Estado" language="python">
```python
class EfficientStateManager:
    """Padr√µes para serializa√ß√£o eficiente de estado"""
    
    def __init__(self, compression_threshold=1024):
        self.compression_threshold = compression_threshold
    
    def serialize_state(self, state: AgentState) -> bytes:
        """Serializa com compress√£o para estados grandes"""
        # Converte para JSON
        json_str = state.to_json()
        
        # Comprime se grande
        if len(json_str) > self.compression_threshold:
            import gzip
            return gzip.compress(json_str.encode())
        
        return json_str.encode()
    
    def deserialize_state(self, data: bytes) -> AgentState:
        """Desserializa com descompress√£o autom√°tica"""
        # Verifica se est√° comprimido
        if data[:2] == b'\x1f\x8b':  # n√∫mero m√°gico do gzip
            import gzip
            json_str = gzip.decompress(data).decode()
        else:
            json_str = data.decode()
        
        return AgentState.from_json(json_str)
    
    def create_checkpoint(self, state: AgentState) -> dict:
        """Cria checkpoint m√≠nimo para retomada r√°pida"""
        return {
            "id": state.id,
            "task": state.task,
            "step_count": state.step_count,
            "status": state.status,
            "last_action": state.steps[-1] if state.steps else None,
            "context_summary": state.context_summary
        }
    
    def archive_completed_state(self, state: AgentState) -> dict:
        """Arquiva estados completos com apenas dados essenciais"""
        return {
            "id": state.id,
            "task": state.task,
            "completed_at": time.time(),
            "total_steps": state.step_count,
            "result": state.metadata.get("result"),
            # N√£o armazena hist√≥rico completo de passos para tarefas conclu√≠das
            "summary": self._generate_execution_summary(state)
        }
```
</CodeExample>

## Fator 11: Separe Estado de Neg√≥cio do Estado de Execu√ß√£o {#state-separation}

### Entendendo a Distin√ß√£o

O maior erro no gerenciamento de estado de agentes? Misturar estado de neg√≥cio com estado de execu√ß√£o. Eles t√™m ciclos de vida diferentes, necessidades de persist√™ncia diferentes e padr√µes de acesso diferentes.

<Diagram type="comparison" title="Estado de Neg√≥cio vs Estado de Execu√ß√£o">
```mermaid
graph TB
    subgraph "Estado de Neg√≥cio"
        B1[Mensagens do Usu√°rio]
        B2[Dados do Pedido]
        B3[Informa√ß√µes do Cliente]
        B4[Detalhes do Produto]
        B5[Hist√≥rico de Transa√ß√µes]
    end
    
    subgraph "Estado de Execu√ß√£o"
        E1[Passo Atual]
        E2[Contador de Tentativas]
        E3[Contador de Loop]
        E4[A√ß√µes Pendentes]
        E5[Posi√ß√£o no Workflow]
    end
    
    subgraph "Estrat√©gia de Armazenamento"
        B1 --> DB1[Banco de Dados Persistente]
        B2 --> DB1
        B3 --> DB1
        E1 --> DB2[Redis/Cache]
        E2 --> DB2
        E3 --> DB2
    end
```
</Diagram>

### Implementando Separa√ß√£o Limpa de Estado

<CodeExample title="Arquitetura de Estado" language="python">
```python
from enum import Enum
from typing import Optional, Dict, Any
import json

class StateType(Enum):
    BUSINESS = "business"
    EXECUTION = "execution"

class SeparatedStateAgent:
    """Agente com separa√ß√£o limpa de preocupa√ß√µes de estado"""
    
    def __init__(self, llm_client, business_store, execution_store):
        self.llm = llm_client
        self.business_store = business_store
        self.execution_store = execution_store
    
    async def process_request(self, request_id: str, user_input: str) -> dict:
        """Processa uma solicita√ß√£o com separa√ß√£o adequada de estado"""
        
        # Inicializa estado de neg√≥cio
        business_state = {
            "request_id": request_id,
            "user_input": user_input,
            "messages": [],
            "data": {},
            "created_at": time.time()
        }
        await self.business_store.save(request_id, business_state)
        
        # Inicializa estado de execu√ß√£o
        execution_state = {
            "request_id": request_id,
            "current_step": 0,
            "retry_count": 0,
            "workflow": "customer_service",
            "status": "processing",
            "context_tokens": 0,
            "started_at": time.time()
        }
        exec_id = f"exec_{request_id}"
        await self.execution_store.save(exec_id, execution_state, ttl=3600)  # TTL de 1 hora
        
        # Processa com separa√ß√£o de estado
        return await self._run_workflow(business_state, execution_state)
    
    async def _run_workflow(self, business_state: dict, execution_state: dict) -> dict:
        """Executa workflow mantendo separa√ß√£o de estado"""
        
        while execution_state["status"] == "processing":
            # Constr√≥i contexto de AMBOS os estados apropriadamente
            context = self._build_context(business_state, execution_state)
            
            # Obt√©m pr√≥xima a√ß√£o
            response = await self.llm.complete(context)
            action = extract_json(response)
            
            # Atualiza estado de execu√ß√£o
            execution_state["current_step"] += 1
            execution_state["context_tokens"] = count_tokens(context)
            
            # Executa a√ß√£o
            try:
                result = await self._execute_action(action)
                
                # Atualiza estado de neg√≥cio com resultados
                if action["type"] == "collect_data":
                    business_state["data"][action["field"]] = result
                elif action["type"] == "send_message":
                    business_state["messages"].append({
                        "type": "agent",
                        "content": result,
                        "timestamp": time.time()
                    })
                
                # Reseta contador de tentativas em sucesso
                execution_state["retry_count"] = 0
                
            except Exception as e:
                execution_state["retry_count"] += 1
                if execution_state["retry_count"] > 3:
                    execution_state["status"] = "failed"
                    execution_state["error"] = str(e)
                    break
            
            # Verifica conclus√£o
            if action.get("type") == "complete":
                execution_state["status"] = "completed"
                business_state["completed_at"] = time.time()
        
        # Persiste estados finais
        await self.business_store.save(
            business_state["request_id"], 
            business_state
        )
        
        # Estado de execu√ß√£o pode ser arquivado ou deletado
        if execution_state["status"] == "completed":
            await self.execution_store.delete(f"exec_{business_state['request_id']}")
        
        return {
            "request_id": business_state["request_id"],
            "status": execution_state["status"],
            "result": business_state.get("data"),
            "messages": business_state.get("messages", [])
        }
    
    def _build_context(self, business_state: dict, execution_state: dict) -> list:
        """Constr√≥i contexto com consci√™ncia dos tipos de estado"""
        context = []
        
        # Mensagem do sistema inclui metadados de execu√ß√£o
        context.append({
            "role": "system",
            "content": f"""Processar solicita√ß√£o do cliente.
            Passo atual: {execution_state['current_step']}
            Workflow: {execution_state['workflow']}
            Tentativas anteriores: {execution_state['retry_count']}
            """
        })
        
        # Contexto de neg√≥cio
        context.append({
            "role": "user",
            "content": business_state["user_input"]
        })
        
        # Inclui dados de neg√≥cio relevantes
        if business_state.get("data"):
            context.append({
                "role": "user",
                "content": f"Dados coletados: {json.dumps(business_state['data'])}"
            })
        
        # Inclui apenas mensagens recentes
        for message in business_state.get("messages", [])[-3:]:
            context.append({
                "role": message["type"],
                "content": message["content"]
            })
        
        return context
```
</CodeExample>

### Melhores Pr√°ticas para Gerenciamento de Estado

<Callout type="info" title="Princ√≠pios de Gerenciamento de Estado">
**Estado de Neg√≥cio:**
- Persista permanentemente no seu banco de dados principal
- Inclua trilhas de auditoria e versionamento
- Otimize para consultas e relat√≥rios
- Nunca inclua metadados de execu√ß√£o

**Estado de Execu√ß√£o:**
- Use armazenamento r√°pido e tempor√°rio (Redis, mem√≥ria)
- Configure TTLs para prevenir acumula√ß√£o
- Mantenha m√≠nimo - apenas o necess√°rio para retomar
- Arquive resumos, n√£o hist√≥ricos completos

**Constru√ß√£o de Contexto:**
- Puxe de ambos os estados inteligentemente
- Sumarize estado de neg√≥cio antigo
- Inclua apenas dicas de execu√ß√£o relevantes
- Nunca exponha estado de execu√ß√£o interno aos usu√°rios
</Callout>

## Verifica√ß√£o de Conhecimento

<Quiz id="control-flow-quiz">
  <Question
    question="Quais s√£o os quatro componentes fundamentais de qualquer agente de acordo com o Fator 6?"
    options={[
      "Modelo, Dataset, Treinamento, Infer√™ncia",
      "Entrada, Processamento, Sa√≠da, Armazenamento",
      "Prompt, Instru√ß√£o Switch, Construtor de Contexto, Loop",
      "Requisi√ß√£o, Resposta, Banco de Dados, Cache"
    ]}
    correctAnswer={2}
    explanation="Todo agente se resume a quatro componentes: 1) Um prompt que instrui como selecionar o pr√≥ximo passo, 2) Uma instru√ß√£o switch que roteia a sa√≠da do modelo para c√≥digo, 3) Um construtor de contexto que gerencia o que o LLM v√™, e 4) Um loop que determina condi√ß√µes de sa√≠da."
  />
  <Question
    question="Por que projetar agentes para serem sem estado (Fator 7) √© crucial para sistemas de produ√ß√£o?"
    options={[
      "Faz eles rodarem mais r√°pido",
      "Reduz o uso de mem√≥ria",
      "Permite pausar/retomar, escalonamento e melhores testes",
      "Simplifica o c√≥digo"
    ]}
    correctAnswer={2}
    explanation="Agentes sem estado podem ser pausados e retomados em qualquer ponto, escalados horizontalmente atrav√©s de m√∫ltiplas inst√¢ncias, testados mais facilmente com estados conhecidos, e depurados examinando o estado em qualquer passo. O agente n√£o carrega estado entre passos‚Äîsua aplica√ß√£o faz."
  />
  <Question
    question="Qual √© a diferen√ßa chave entre estado de neg√≥cio e estado de execu√ß√£o?"
    options={[
      "Estado de neg√≥cio √© mais r√°pido de acessar",
      "Estado de execu√ß√£o √© mais importante",
      "Estado de neg√≥cio s√£o dados permanentes do dom√≠nio; estado de execu√ß√£o s√£o dados tempor√°rios do workflow",
      "Eles s√£o a mesma coisa com nomes diferentes"
    ]}
    correctAnswer={2}
    explanation="Estado de neg√≥cio inclui dados permanentes do dom√≠nio (mensagens de usu√°rios, pedidos, informa√ß√µes de clientes) que devem ser persistidos no seu banco de dados. Estado de execu√ß√£o inclui dados tempor√°rios do workflow (passo atual, contador de tentativas, posi√ß√£o no loop) que s√≥ importam durante a execu√ß√£o do agente e podem ser armazenados em armazenamento r√°pido e tempor√°rio."
  />
</Quiz>

## Exerc√≠cio: Construa um Agente de Atendimento ao Cliente Paus√°vel

Coloque suas habilidades de gerenciamento de estado em pr√°tica construindo um agente que pode ser pausado e retomado no meio de uma conversa.

### Requisitos

Construa um agente que:
1. Lida com workflows de atendimento ao cliente em m√∫ltiplos passos
2. Pode ser pausado em qualquer ponto e retomado mais tarde
3. Separa estado de neg√≥cio do estado de execu√ß√£o
4. Implementa gerenciamento adequado da janela de contexto
5. Suporta aprova√ß√£o humana para certas a√ß√µes

### C√≥digo Inicial

<CodeExample title="Agente Paus√°vel - C√≥digo Inicial" language="python">
```python
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum
import json
import time
import asyncio

# Define estruturas de estado
@dataclass
class BusinessState:
    """Dados permanentes de neg√≥cio"""
    customer_id: str
    conversation_id: str
    messages: List[Dict[str, str]] = field(default_factory=list)
    customer_data: Dict[str, Any] = field(default_factory=dict)
    resolved_issues: List[str] = field(default_factory=list)
    
@dataclass
class ExecutionState:
    """Dados tempor√°rios de execu√ß√£o"""
    workflow_id: str
    current_step: str = "start"
    step_count: int = 0
    retry_count: int = 0
    pending_actions: List[str] = field(default_factory=list)
    context_tokens: int = 0
    status: str = "active"  # active, paused, completed, error

@dataclass
class AgentState:
    """Estado combinado para serializa√ß√£o"""
    business: BusinessState
    execution: ExecutionState
    checkpoint_data: Dict[str, Any] = field(default_factory=dict)

# TODO: Implementar o StateManager
class StateManager:
    """Gerencia persist√™ncia e recupera√ß√£o de estado do agente"""
    def __init__(self, storage_backend="memory"):
        # TODO: Inicializar armazenamento (mem√≥ria, redis, banco de dados)
        pass
        
    async def save_state(self, state: AgentState) -> str:
        """Salva estado atual e retorna state_id"""
        # TODO: Serializar estado
        # TODO: Armazenar com ID √∫nico
        # TODO: Configurar TTL para estado de execu√ß√£o
        pass
        
    async def load_state(self, state_id: str) -> Optional[AgentState]:
        """Carrega estado por ID"""
        # TODO: Recuperar do armazenamento
        # TODO: Desserializar
        # TODO: Validar se estado ainda √© v√°lido
        pass
        
    async def update_execution_state(self, state_id: str, execution: ExecutionState):
        """Atualiza apenas a por√ß√£o de execu√ß√£o"""
        # TODO: Implementar atualiza√ß√£o parcial
        pass

# TODO: Implementar o ContextManager
class ContextWindowManager:
    """Gerencia janela de contexto para prevenir explos√£o"""
    def __init__(self, max_tokens: int = 4000):
        self.max_tokens = max_tokens
        
    def build_context(self, state: AgentState) -> str:
        """Constr√≥i contexto do estado, gerenciando tamanho"""
        # TODO: Calcular tamanho atual
        # TODO: Sumarizar mensagens antigas se necess√°rio
        # TODO: Incluir estado de neg√≥cio relevante
        # TODO: Adicionar dicas de execu√ß√£o
        pass
        
    def should_summarize(self, messages: List[Dict]) -> bool:
        """Determina se sumariza√ß√£o √© necess√°ria"""
        # TODO: Verificar contagem de tokens
        # TODO: Verificar contagem de mensagens
        pass

# TODO: Implementar o PauseableAgent principal
class PauseableCustomerServiceAgent:
    def __init__(self, llm_client, state_manager: StateManager):
        self.llm = llm_client
        self.state_manager = state_manager
        self.context_manager = ContextWindowManager()
        
    async def start_conversation(self, customer_id: str, initial_message: str) -> str:
        """Inicia uma nova conversa"""
        # TODO: Criar estado inicial de neg√≥cio e execu√ß√£o
        # TODO: Salvar estado
        # TODO: Processar primeira mensagem
        # TODO: Retornar state_id para retomada futura
        pass
        
    async def resume_conversation(self, state_id: str, new_message: Optional[str] = None) -> Dict[str, Any]:
        """Retoma do estado salvo"""
        # TODO: Carregar estado
        # TODO: Validar se estado √© retom√°vel
        # TODO: Processar nova mensagem se fornecida
        # TODO: Atualizar estado
        pass
        
    async def process_step(self, state: AgentState) -> AgentState:
        """Processa um passo da conversa"""
        # TODO: Construir contexto
        # TODO: Obter resposta do LLM
        # TODO: Rotear para a√ß√£o
        # TODO: Atualizar estado
        # TODO: Verificar se aprova√ß√£o humana √© necess√°ria
        pass
        
    async def pause_for_approval(self, state: AgentState, action: str) -> str:
        """Pausa agente para aprova√ß√£o humana"""
        # TODO: Configurar status como pausado
        # TODO: Salvar a√ß√£o pendente
        # TODO: Salvar estado
        # TODO: Retornar token de retomada
        pass

# Manipuladores de a√ß√£o
class ActionHandlers:
    @staticmethod
    async def handle_refund(amount: float, order_id: str) -> Dict[str, Any]:
        """Processa reembolso - requer aprova√ß√£o"""
        return {
            "action": "refund",
            "requires_approval": True,
            "details": {"amount": amount, "order_id": order_id}
        }
    
    @staticmethod
    async def handle_query(query: str) -> Dict[str, Any]:
        """Responde consulta - sem aprova√ß√£o necess√°ria"""
        return {
            "action": "query",
            "requires_approval": False,
            "response": f"Resposta da consulta para: {query}"
        }

# Cen√°rios de teste
test_scenarios = [
    {
        "scenario": "Consulta simples",
        "messages": [
            "Quais s√£o os hor√°rios de funcionamento?",
            "Obrigado!"
        ]
    },
    {
        "scenario": "Solicita√ß√£o de reembolso requerendo aprova√ß√£o",
        "messages": [
            "Quero um reembolso para o pedido #12345",
            "Sim, o valor total de R$ 99,99",
            "Obrigado por processar isso"
        ]
    },
    {
        "scenario": "Solu√ß√£o de problemas em m√∫ltiplos passos",
        "messages": [
            "Meu dispositivo n√£o liga",
            "Sim, tentei carregar",
            "A luz n√£o acende quando conectado",
            "OK, vou tentar outro cabo"
        ]
    }
]

# Exemplo de uso
async def demo_pause_resume():
    """Demonstra funcionalidade de pausar e retomar"""
    # Inicializa componentes
    state_manager = StateManager()
    agent = PauseableCustomerServiceAgent(llm_client, state_manager)
    
    # Inicia conversa
    state_id = await agent.start_conversation(
        customer_id="cust_123",
        initial_message="Preciso de um reembolso para meu pedido"
    )
    
    # Continua conversa
    result = await agent.resume_conversation(
        state_id=state_id,
        new_message="O n√∫mero do pedido √© #12345 por R$ 99,99"
    )
    
    if result["status"] == "paused_for_approval":
        print(f"Agente pausado. Aprova√ß√£o necess√°ria para: {result['pending_action']}")
        
        # Simula aprova√ß√£o humana
        await asyncio.sleep(2)
        
        # Retoma ap√≥s aprova√ß√£o
        result = await agent.resume_conversation(
            state_id=state_id,
            new_message="APROVADO: Processe o reembolso"
        )
    
    print(f"Resultado final: {result}")
```
</CodeExample>

### Dicas de Implementa√ß√£o

1. **Serializa√ß√£o de Estado**:
   - Use dataclasses.asdict() para serializa√ß√£o f√°cil
   - Considere usar pickle para objetos complexos
   - Sempre versione seu schema de estado

2. **Gerenciamento de Contexto**:
   - Conte tokens com precis√£o (biblioteca tiktoken ajuda)
   - Sumarize conversas mais antigas que N mensagens
   - Mantenha informa√ß√µes cr√≠ticas (IDs de pedido, valores) em todos os resumos

3. **L√≥gica de Pausar/Retomar**:
   - Salve estado antes de qualquer chamada externa
   - Use campo de status para rastrear estado do agente
   - Inclua timestamp para expira√ß√£o de estado

4. **Abordagem de Teste**:
   - Teste pausa em cada tipo de passo
   - Verifique reconstru√ß√£o de estado
   - Teste com estados expirados

### Comportamento Esperado

```python
# Inicia conversa
agent = PauseableCustomerServiceAgent(llm, state_mgr)
state_id = await agent.start_conversation("cust_123", "Preciso de ajuda")

# Mais tarde, retoma de outra inst√¢ncia
agent2 = PauseableCustomerServiceAgent(llm, state_mgr)
result = await agent2.resume_conversation(state_id, "Pedido #12345")

# Deve manter contexto completo e continuar naturalmente
```

### Desafios B√¥nus

1. **Adicionar ramifica√ß√£o de conversa**: Suporte a m√∫ltiplos caminhos de conversa
2. **Implementar migra√ß√£o de estado**: Lidar com mudan√ßas de schema graciosamente  
3. **Adicionar an√°lises**: Rastrear pontos de pausa e taxas de retomada
4. **Transfer√™ncia multi-agente**: Transferir estado entre agentes especializados

## Resumo e Pr√≥ximos Passos

Voc√™ agora dominou os padr√µes de fluxo de controle e gerenciamento de estado que separam agentes de brinquedo de sistemas de produ√ß√£o. Os principais insights:

1. **Agentes s√£o apenas quatro componentes**: Prompt, switch, contexto e loop
2. **Controle seu fluxo**: N√£o deixe janelas de contexto explodirem
3. **Projete para ser sem estado**: Habilite pausar, retomar e escalar
4. **Separe seus estados**: Neg√≥cio e execu√ß√£o t√™m necessidades diferentes

No pr√≥ximo m√≥dulo, exploraremos engenharia de prompt e contexto‚Äîa arte de criar entradas que produzem sa√≠das confi√°veis e prontas para produ√ß√£o.

### Cart√£o de Refer√™ncia R√°pida

<Card title="Checklist de Fluxo de Controle">
‚úì Limites m√°ximos de passos aplicados  
‚úì Sumariza√ß√£o de contexto implementada  
‚úì Serializa√ß√£o de estado testada  
‚úì Estados de neg√≥cio/execu√ß√£o separados  
‚úì Funcionalidade pausar/retomar funcionando  
‚úì Limites de erro no lugar  
‚úì Ganchos de aprova√ß√£o humana prontos  
</Card>