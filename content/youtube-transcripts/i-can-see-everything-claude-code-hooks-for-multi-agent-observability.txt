[00:00]  [00:00] What you're about to see is simple and [00:02] powerful. [00:04] Running a single Cloud Code agent is [00:06] just the beginning. Once you realize [00:09] this and you start scaling up the number [00:11] of agents you have shipping for you, you [00:14] quickly run into a massive problem. [00:17] There's too much to keep track of. When [00:19] it comes to multi-agent systems, [00:21] observability is everything. Check this [00:23] out. With cloud code hooks sending [00:26] events to a minimal client server [00:28] architecture, you can see everything. [00:31] Let's break down a concrete approach to [00:34] cloud code multi- aent observability [00:36] that let you scale up what you can do [00:38] with not just one cloud code instance [00:41] but 3 510 and beyond.

[00:48] So, as you can see here, we have a [00:50]  [00:50] multi- aent observability system that is [00:52] taking events in from every cloud code [00:55] instance I have running. Doesn't matter [00:56] if they're running subtasks, if they're [00:58] planning, building, web scraping, web [01:01] searching, deep research, calling MCP [01:03] servers. Every event is getting tracked [01:06] and traced into this simple multi- aent [01:09] observability application. Here's what [01:11] the application architecture looks like. [01:13] We have multiple agents firing their own [01:16] respective claude code hooks. Each one [01:18] of these hooks hits a bun server which [01:20] stores data to an SQL like database for [01:23] persistence and simultaneously it uses [01:26] websockets to stream the events right to [01:28] the client you see right here. So no [01:31] matter where your agents are running, if [01:33] you're running on multiple devices, if [01:35] you're running, you know, 5 10 plus [01:36] agents, every event's going to get [01:38] streamed in. You can see I have [01:40] different applications streaming in [01:42] events with different cloud code session [01:44] IDs getting recorded here. And every [01:46] tool call, every hook. [01:48] Dan, your agent needs your input. [01:49] You can see there every hook, every [01:51] event type is getting recorded. I just [01:53] got a notification event. So, one of my [01:55] agents needs my input. We can go ahead [01:57] go back to the terminal and we can see [01:59] which one needs it. So, [02:00] Dan, task nailed. Moving forward. [02:02] There we go. We got a stop event coming [02:04] in and we can see this custom theme [02:06] feature is looking good. It looks like [02:07] it needs a couple tweaks to this. Of [02:09] course, we'll just accept and let it [02:10] keep cooking. We have one Asian complete [02:12] and you can see we have a multitask sub [02:14] agent event getting a bunch of work [02:16] done. All these events are streaming in. [02:18] And so this is the power of [02:19] observability. As you scale up your [02:22] agents, as you specialize and build [02:25] agents into your workflows, right, into [02:27] your agentic workflows, you want to [02:29] understand what they're doing. So let's [02:31] break down this [02:31] needs your input. [02:32] Okay, so we got another input request [02:34] there. Once you start using cloud code [02:37] and once you start using agentic coding [02:38] tools, you realize that you can do a lot [02:41] more by just adding agents by just [02:44] scaling up the number of agents you have [02:46] working for you at any time. This is [02:48] also great for specialization and cross [02:50] app usage. This is just [02:52] agent complete. [02:53] Awesome. So we got sub agent complete [02:54] calls here. You can see every type of [02:57]  [02:57] cloud code event. At the top here we of [02:59] course have filters. We're operating out [03:01] of two code bases right now. the [03:02] infinite agentic loop codebase and this [03:04] brand new cloud code hook multi- aent [03:06] observability codebase. We can filter [03:09] down of course [03:09] your agent needs your input [03:11] to one or more of these code bases. [03:13] Let's just go ahead and set back to all [03:15] sources. You can hear in the background [03:16] text to speech that we put together in [03:18] the previous cloud code hooks video. My [03:20] agents are letting me know when they [03:21] need my input or when they're ready for [03:23] more work. [03:24] Sub agent complete. [03:25] So we have session IDs which detail the [03:27] exact cloud code instance and then of [03:29] course we have event types. So these are [03:31] all the current available cloud code [03:33] hooks that you can tap into. And we're [03:35] of course getting a stream of every [03:37] single event. So we can easily filter [03:39] down. Let's say we just want to see all [03:41] of the stop events, post, tool use, [03:44] notifications, so on and so forth. And [03:46] so you can of course see something [03:48] really, really cool, right? We have a [03:50] live activity pulse of all the events [03:53] coming in in real time. All the work our [03:55] agents are doing across every [03:57] application, across every cloud code [03:59] instance. You can see our infinite [04:01] agentic loop agent is doing a lot of [04:03] work and this is one of the heavy [04:05] hitters, right? Go ahead, let this [04:06] continue. You can see that we have five [04:09] subtasks operating in parallel. So, a [04:12] lot of events are going to stream in [04:13] from this. This agent here built out a [04:16] plan. Now, I'm going to have it actually [04:18] implement this plan. So, I'm just going [04:19] to copy this /implement. Paste that in. [04:22] And now, it's going to build out that [04:23] plan. I'm still building this. I'm still [04:25] working on this as I'm presenting it to [04:26] you here. I need to make this mobile [04:28] friendly so I can you know shrink this [04:29] down and use this on my phone on my [04:31] device on the go accept this cool stuff [04:34] right this live activity policy is great [04:36] for seeing all the events coming in live [04:38] throughout all agents and we can see [04:40] highle breakdown of what this looks like [04:42] let's get to the bulk of it right the [04:44] agent event stream you can see all the [04:46] events are streaming in here we have a [04:48] total of 63 events and this does cut off [04:50] and refresh if we scroll down here we [04:53] have the application that the events are [04:55] coming out of we have the clawed code [04:58] session ID. [04:59] Your agent needs your input. [05:00] Okay, thumbs up. This application and [05:02] session IDs uniquely mark this instance [05:05] for good UIUX. We have color coding here [05:08] on the app and the session ID. So, we're [05:11] hashing the incoming app name and [05:13] session ID so that we can consistently [05:15] see which agent is posting. [05:17] Mailed. What's next? [05:18] There we go. We got a task complete with [05:20] that cloud code hook stop event. That's [05:22] awesome. App name here, session ID, tool [05:24] that we're actually calling. And then [05:26] over here on the right, we have [05:27] something really, really powerful. So we [05:28] have summarizations of the work done in [05:31] some of our tools here. We're actually [05:33] running, and I'll show this off in the [05:34] codebase in a moment here, where every [05:36] event coming in before the cloud code [05:38] hook sends it off, it's running a [05:40] summarization prompt using a small fast [05:42] model. So in this case, I'm running haik [05:44] coup to get a summary on all of the [05:47] events that I care about. So [05:48] specifically, pre-tool, post tool, I [05:50] want to see what is going on and just be [05:52] able to read at a glance, right? I don't [05:54] want to click in here and have to look [05:56] at the exact payload which of course you [05:58] can. What does event represent? So you [05:59] can see here infinite agentic loop [06:01] writes HTML file for medscan pro [06:03] clinical dashboard at a specified [06:05] project path. That's the post tool use. [06:07] Sub aent complete. [06:08] There we go. We got another sub aent [06:10] complete. And post tool use fires of [06:12] course after the tool has run. Of course [06:14] we have pre-tool use right there. You [06:16] can see these events are tied together. [06:18] Right. Pre-tool post tool [06:20] sub aent complete. It's the same agent [06:22] 15CC5C and the running in the infinite [06:25] agentic loop codebase. This is this [06:27] agent here. My implementation agent is [06:30] still working and we are getting [06:31] infinite UIs generated over here. These [06:33] of course are just presentational [06:35] examples. Although these two are [06:36] actively, you know, working on [06:38] multi-agent observability codebase. But [06:40] anyway, I hope you can see the idea [06:42] here, right? This is something that's [06:43] going to be really really important for [06:45] you as you scale up your agents. This [06:48] architecture that we have here is a [06:50] one-way data stream. This keeps things [06:52] really, really simple. Everything flows [06:54] here from cloud code agents through [06:56] their hooks to the server. When they hit [06:58] the server, they're stored in SQL like [07:00] database. And then right after they're [07:02] saved, they're streamed to the front end [07:04] here. And so we're getting these live [07:05] events coming in. And of course in the [07:07] activity pulse, we can also, you know, [07:09] we're looking at a 1 minute feed here, [07:10] but we can go 3 minute and we can go 5 [07:12] minute. And you can see, you know, a [07:13] larger collection of all these events [07:15] coming in at a larger time frame. You [07:16] can also see, you know, every individual [07:18] line represents the actual agent that [07:21] did the work. [07:22] Sub agent complete. [07:23] Right? This is the session ID hashed [07:25] color. You want your observability to be [07:27] fast, easy, quick. [07:28] Sub agent complete. [07:29] Right? This is why we have the [07:30] summaries. If we scroll down here, [07:32] getting summaries for post tool use. If [07:34] we want to open up our sub agent stop [07:35] event and see what that looks like, you [07:37] can see here this is the exact payload [07:39] for that cloud code hook. And we're [07:41] putting it all together here in this [07:42] one-way data flow architecture where [07:45] Cloud Code uses its hooks after it [07:47] finishes events. And these events then [07:50] send information to the server. There [07:52] you go. You can see five agentic loop [07:54] tasks kicked off there. And then the [07:56] server takes those events, stores it in [07:58] SQLite, and then streams them right to [08:01] the client we're looking at right here. [08:02] So this oneway data stream keeps things [08:04] really simple. Every agent is [08:06] responsible for summarizing their work [08:08] in the cloud code hook before they send [08:09] it off. And we'll dive into the codebase [08:11] in just a moment here. I just want to [08:12] highlight how important this is. It's [08:15] the same deal. If you don't measure it, [08:17] you can't improve it. If you don't [08:18] monitor it, how will you know what's [08:20] actually happening? If you want to scale [08:22] up your work, if you want to scale up [08:23] your agents, you need to know what [08:25] they're doing. And it is really [08:27] interesting too to watch this data flow [08:29] come in and really trail what the agents [08:32] are doing to understand how your agentic [08:34] coding tool really works. All right, but [08:36] this is all powered, of course, by cloud [08:38] code hooks. This is an incredible [08:40] feature that lets you build on top of [08:42] and understand what's going on in Cloud [08:45] Code's life cycle. They give us [08:46] deterministic control over Cloud Code's [08:48] behavior and it lets us steer, monitor, [08:51] control our agents. All right, so this [08:54] is a big feature. I'm covering it again [08:56] here week after week. Last week, we [08:58] covered cloud code hooks in a more [08:59] fundamental way. This time in this [09:02] video, as you can see here, we're [09:03] putting cloud code hooks to work for [09:06] multi- aent observability. If you want [09:08] to do more, if you want to scale up your [09:11] agentic coding, if you want to become an [09:13] agentic engineer, you're going to want [09:15] multiple agents working for you, [09:17] accomplishing tasks across all of your [09:19] code bases. Of course, as you scale that [09:21] up, another problem emerges, right? [09:23] Solutions create problems, another [09:25] problem emerges where we need a way to [09:27] track and understand what is going on. [09:30] And the cool part is, you know, I don't [09:32] need to open up these terminals, these [09:34] instances to know what's going on now, [09:36] right? I can keep these closed and just [09:38] look at what's happening here. I think [09:40] you understand why multi-agent [09:42] observability is so important. If you're [09:43] scaling up your impact, if you're [09:45] scaling up your engineering work, you [09:46] need to understand what's happening, [09:48] where it's happening, and what agent is [09:50] doing the operation, right? Because [09:52] eventually something will go wrong. A [09:54] system will not do the right thing. And [09:56] then it's going to be essential to have [09:58] a trace throughout your system that you [10:00] can fully control. All right? So, I'm [10:02] not saying this is the right way to do [10:03] it. I'm just saying this is a way you [10:06] can start with multi- aent [10:07] observability. You can see [10:08] task accomplished and ready to roll. [10:10] There's our stop task there. And [10:12] something cool about the stop event, [10:13] just to mention it here. If we click [10:15] stop, we can see the entire chat [10:17] transcript. So you can see this agent, [10:19] agent07 [10:21] inside of the cloud code hooks multi- [10:22] aent observability codebase. It has 500 [10:25] messages, right? And if we click into [10:26] this, you can search through them and [10:28] understand exactly what was happening at [10:30] a glance. The stop event is the perfect [10:32] time to copy you know the entire log via [10:35] the transcript path right here and use [10:38] it to operate on the work that happened [10:40] right so for instance say I wanted to [10:42] find all the read commands we can [10:44] quickly filter all the reads and [10:46] understand where that's happening we can [10:48] do the same with all the glob usage [10:50] assistant responses you can see that [10:52] here to do all the responses here for [10:55] this chat anyway so you get the idea [10:57] right observability is ultra important [11:00] and you something we've talked about [11:01] before on the channel. Keeping track of [11:04] what your tool can do teaches you, the [11:06] engineer, what you can actually do with [11:08] these tools. Monitoring lets you tap [11:10] into the potential that your tool can [11:12] have. So, it looks like our mobile [11:14] version shipped. Okay, this is something [11:16] of course we can come in and tweak event [11:18] streams here. We probably want to [11:19] increase the default size of this, the [11:21] default height on mobile. That's fine. [11:23] So, what does this look like? How does [11:25] this actually work? Let's look at the [11:27] events flowing through the system. Let's [11:28] look at our small fast haik coup model [11:31] giving us summaries on the event. Right, [11:33] this is really powerful. We want to be [11:34] able to observe very quickly at a [11:36] glance. We got a notification here from [11:38] one of our agents. Accept the changes [11:40] there. That looks great. Infinite agent [11:42] loop still running here. That looks [11:43] great. All right. So, let's go ahead and [11:45] understand how this works. Okay. From [11:47] end to end cloud code agent to hook to [11:48]  [11:50] server to client, we can see the [11:52] following structure. As you know from [11:54] the previous video, we have the claude [11:56] directory and we've added a new hooks [11:58] directory. If we open up settings, we [12:01] can understand what's going on. And of [12:02] course, it all starts from the hooks and [12:04] see we have all of the events getting [12:07] tracked. And let's just look at pre-tool [12:09] use. We've added another hook. So [12:11] instead of running one hook, we're [12:13] running two hooks. Something very cool. [12:14] We have this pre-tool use specific [12:17] script. We're of course using Astral's [12:19] UV single file Python scripts. This is a [12:22] great way to isolate code and to create [12:24] standalone scripts. But then we have [12:27] something really cool down here. We have [12:29] this new script here. And we can, you [12:31] know, just shrink all this so that it's [12:33] a little bit more readable. This looks [12:34] like this, right? So in this directory, [12:36] we have this send event method and it [12:39] has a couple of args. We have the name [12:42] of the application we're operating in. [12:44] We have the event type and then we're [12:45] adding this summarize flag. And the [12:47] summarize flag is of course what's [12:49] creating these summaries here on the [12:52] right with our small fast haiku model. [12:54] Sub aent complete. Sub aent complete. [12:56] We're not going to dive into the natural [12:57] language responses here. We covered this [12:59] in our previous video. I'll link that in [13:00] the description. Check that out after [13:02] you understand multi-agent observability [13:04] in this video. So if we look for send [13:07] event, we have this running in all of [13:10] our hooks. You know, you can see post [13:12] tool use has it, pre-tool use has it, [13:14] notification has it, stop. [13:16] Dan, task nailed. What's next? [13:18] We have sub agent stop and pre-ompact, [13:20] right? The new cloud code hook that runs [13:22] right before you compact. These are all [13:24] running it. They're all passing in their [13:26] own information. This enables this [13:28] script to be dynamic and to handle every [13:30] one of our hooks. What happens in send [13:32] event? Let's look at this. We have the [13:34] event data, which is just whatever JSON [13:36] payload you want to send to the server. [13:38] We have our local server running that's [13:40] capturing events. We have apps, client, [13:44] server, and demo. The server is [13:46] receiving all of these events. And [13:47] you'll notice this pattern that I'm [13:49] adopting in every video and every [13:51] codebase I operate in. Now, the actual [13:53] application is inside of the wrapping of [13:57] our generative AI technology, of our [13:59] generative AI scaffolding. We're [14:01] starting to build out an aentic layer [14:04] around our codebase. and I'll highlight [14:06] all the essential folders that make up [14:09] that agentic layer. There are more of [14:11] these agentic directories that we're [14:13] going to be talking about on the [14:14] channel. Make sure you're subscribed so [14:16] you don't miss those. This new layer [14:19] around your codebase is going to change [14:21] the way you engineer forever. But you [14:23] need to know where to put the right [14:25] thing. More on that in the future. [14:26] Again, make sure you're part of the [14:28] journey. Here's apps. You know, the only [14:30] thing we need to look at in the server. [14:31] You can see the ESCO like database right [14:33] there. Nice and portable. And then in [14:35] the source, we're going to have our bun [14:37] server. Our cloud code event gets kicked [14:39] off no matter where this cloud code is, [14:41] right? Keep in mind, we have hook set [14:43] up. So the hook just fires off a, you [14:46] know, HTTP request with the event. So it [14:48] can go anywhere you want it to. And so [14:50] that's what our send event is doing. So [14:51] that's the cloud code and cloud code [14:53] hook side of things. It then gets passed [14:55] off to the server. And if we open up the [14:56] server here, run a quick collapse, you [14:59] can see all we have here is our [15:02] slashevents. This is just a simple [15:04] manual bun server. We are inserting this [15:07] into the database and then broadcasting [15:09] the event to our websocket client. Nice [15:12] and simple. This is the server and this [15:14] is of course the client. We have a use [15:17] websocket event like this which mounts [15:20] and handles our websocket. So classic [15:22] stuff, right? This is Vue.js. Every [15:24] front-end framework has their own [15:26] version of this code. You know, you can [15:28] easily use an agent, use a powerful [15:30] model to completely convert this to [15:32] whatever front-end framework you want. [15:33] These things don't matter anymore. [15:35] Frameworks are irrelevant when it comes [15:36] to raw productivity. Your agent knows [15:39] all of them. The key here is we have [15:41] connect after it's connected. We have [15:43] this websocket on event and we're just [15:45] taking all of our events, slicing them [15:48] because we don't want to overflow with [15:49] too many events. Add them to this [15:51] reference. And then, of course, our [15:52] reference here is going to be available [15:55] via this composable, right? via this [15:57] hook use websocket and then our front [16:00] end consumes this. So if we just search [16:02] all for this, you can see in app.view, [16:05] we're using this websocket event here [16:07] and then we're passing in our events to [16:09] anyone that's interested in our [16:11] components and then the rest is [16:13] front-end boring component stuff, right? [16:15] So nothing special there for your [16:16] observability systems. The key is you [16:18] want to keep it simple. You want to put [16:20] something up right away. And the [16:21] quickest way to do that is a oneway data [16:23] flow from your cloud code agents to your [16:26] server. Server is going to store to both [16:29] our SQLite database and our websocket [16:32] client. So if we hop into our database, [16:34] you can see exactly what this looks [16:35] like. And then you can see all the data [16:37] we're storing. And I can even open up [16:39] our SQLite database. This is what it [16:41] looks like with a quick preview. You can [16:43] see source app, session ID, event, and [16:46] then the raw payload. And then some of [16:48] the stop events will of course have the [16:50] entire chat attached. And this is what [16:52] the data structure looks like at a high [16:54] level. And then we of course just emit [16:56] all the events to the front end. If we [16:58] open up the readme, you can understand [17:00] how to get the setup on your own. And [17:01] really what I want to do here is I'm not [17:03] here to tell you how to observe your [17:05] agents. I'm here to show you what you [17:07] can do. I'm here to help you tap into [17:09] your potential with this powerful [17:11] generative AI technology. This codebase [17:13] is going to be available to you. Link in [17:15] the description. use this as a starting [17:17] place to understand what you can do with [17:20] cloud code, the best agentic coding tool [17:23] in the game. We're taking our big three. [17:25] We're taking our principles of ad coding [17:27] and of agentic coding, and we're [17:28] starting to put them to work. And the [17:30] key is that as you scale up the number [17:32] of agents doing work for you, [17:34] specialized agents working on specific [17:37] code bases, solving specific problems [17:39] very well, you want a way to observe [17:40]  [17:42] them, right? You want a way to monitor [17:44] your agents. You want a concrete way to [17:47] monitor success. None of this generative [17:49] AI technology matters if you have no [17:51] idea what's going on. If you don't know [17:53] how to steer, correct, and control your [17:56] agentic systems, it's as good as [17:58] garbage. Okay, so this is what we're [18:00] doing here. You can see our summaries. [18:03] So powerful, so useful. Just quick, [18:05] highlevel, small, fast language models. [18:08] This is a great use case for these [18:09] small, fast, cheap models. I've sent a [18:12] thousand of these events so far just in [18:14] testing. I haven't even set these up [18:16] against my real multi- aent system yet, [18:19] but I've spent less than 20 cents on [18:21] thousands of events. So, this is where [18:23] small fast models really shine, right? [18:26] These one-off quick summaries, these [18:28] quick prompts. Once you start scaling up [18:31] from one agent running on your machine [18:33] to multiple agents running on your [18:34] machine like this to multiple agents [18:37] running on different machines, you get [18:39] something really incredible. You start [18:41] pushing in to true off-device agentic [18:45] coding. This is the future of [18:46] engineering. You want to be on this [18:48] trend. You want to be writing this. You [18:49] want to be pushing toward this. [18:51] Prompting back and forth, one prompt at [18:53] a time is not the way to engineer. It's [18:56] a great place to start. It's a terrible [18:58] place to finish. Things are going to [18:59] continue to progress and on the channel [19:01] we're going to continue to progress [19:03] beyond the curve. [19:04] Your agent needs your input. [19:06] We're going to move beyond the state. [19:07] We're always looking at where the ball's [19:09] going, not where the ball is. Pay [19:12] attention to what your agents are doing. [19:14] Understand what your agents can do. Use [19:16] multi- aent observability. Start [19:18] spinning up multiple agents focused on [19:21] one specific task for you. Specialize [19:24] your agents and then scale them up. The [19:27] big idea here is that we want to get out [19:30] of back and forth prompting mode like [19:32] this and we want to move into fully [19:34] trusted, fully agentic, programmable [19:37] agentic coding. I'll also link that [19:39] video in the description. Everything [19:41] we're doing on the channel is pushing [19:43] towards something big, hence the phase 2 [19:45] agentic coding course coming in the next [19:48] couple of months. I'm ultra excited to [19:49] share that with you. What we're going to [19:51] do next is going to be truly [19:52] mind-blowing. So anyway, stay tuned for [19:54] that. Make sure you're subscribed so you [19:56] don't miss what's coming next in the [19:57] Agentic coding and the Agentic [19:59] engineering world. You know where to [20:01] find me every Monday. Stay focused and [20:04] keep building.