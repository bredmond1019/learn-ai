[Music] hello this awesome this is a big crowd who here has used quad code before jesus awesome that's what I like to see cool so my name is Boris i'm a member of technical staff at Enthropic and creator of Quad Code and um I was struggling with what to talk about for audience that already knows quad code already knows AI and all the coding tools and agentic coding and stuff like that so I'm going to zoom out a little bit and then we'll zoom back in so here's my TLDDR the model is moving really fast it's on exponential it's getting better at coding very very quickly as everyone that uses the model knows and the product is kind of struggling to keep up we're trying to figure out what product to build that's good enough for a model like this and we feel like there's so many more products that could be built for models that are this good at coding and we're kind of building the bare minimum and I'll kind of talk about why and with quad code we're trying to stay unopinionated about what the product should look like because we don't know so for everyone that didn't raise your hand I think that's like 10 of you uh this is how you get quad code um you can head to quadi/code to install it uh you can run this incantation to install from npm um as of yesterday we support quad pro plan so you can try it on that uh we support cloud max so yeah just try it out tell us what you think so programming is changing and it's changing faster and faster and if you look at where programming started back in you know the 1930s4s there were there was like switchboards and it was this physical thing there was no such thing as software and then sometime in the 1950s punch cards became a thing and my uh my my grandpa actually in the Soviet Union he was one of the first programmers in the in the Soviet Union and my mom would tell me stories about like you know when she grew up in the 1970s or whatever he would bring these big stacks of punch cards home and she would like from work and and she would like draw over them with crayons and that was growing out for her and that that's what programming was back back in the 1950s 60s 70s even but sometime in the late 50s we started to see these higher level languages emerge so first there was assembly so programming moves from hardware to punch cards which is still physical to to software and then the level of abstraction just went up so we got to cobalt then we got to typed languages we got to C++ in the early 90s there was this explosion of these new language families there was you know the Haskell family and um you know JavaScript and Java the evolution of the C family and then Python and I think nowadays if you kind of squint all the languages sort of look the same like when I write TypeScript it kind of feels like writing Rust and that kind of feels like writing Swift and that kind of feels like writing Go the abstractions have started to converge a bit if we think about the UX of programming languages this has also evolved back in the 1950s you use something like a typewriter to punch holes in punch cards and that was programming back in the day and at some point text editors appeared um and then uh Pascal and all these different ids uh appeared that let you interact with your programs and your software in new ways and each one kind of brought something and I I feel like programming languages have sort of leveled out but the model is on an exponential and the UX of programming is also on an exponential and I'll talk a little bit more about that does anyone know what was the first text editor okay I heard I heard Ed from someone i think you read the screen before well before text editors this is what programming looked like so this was the IPMO29 this was kind of a top-of-the-line this was like the MacBook of the time for programming punch cards everyone had this you can still find it in museums somewhere and yeah this is Ed this is the the first text editor this was uh Chem Thompson at at the labs invented this and you know it kind of looks familiar if you open your MacBook you can actually still type Ed this is still is still distributed on Unix uh as as part of Unix systems and this is crazy because this thing was invented like 50 years ago and this is nuts like there there's no cursor there's no scroll back uh there's no fancy commands there's no type ahead there's pretty much nothing this is the simple text editor of the time and it was built for teletype machines which were literally physical machines that printed paper on paper that's how your program was printed and this is the first software manifestation of a UX for programming software so it was really built for these machines that didn't support scrollback and cursors or anything like that um for all the Vim fans I'm going to jump at jump ahead of Vim vim was a big innovation emacs was a big innovation around the same time i think in 1980 Small Talk 80 was a big uh it was a big jump forward this is one of the first I think the first graphical interface for programming software and um for anyone that's tried to set up like live reload with React or Redux or any of this stuff this thing had live reload in 1980 and it worked and we're still kind of struggling to get that to work with like ReactJS nowadays so this this was a big jump forward and obviously like the language it had object-oriented programming and a bunch of new concepts but on the UI side there's a lot of new things too in '91 I think Visual Basic was the first code editor that introduced a graphical paradigm to the mainstream so before people were using textbased editors Vim and things like that were still very popular despite things like small talk um but this kind of brought it mainstream this is what I grew up with eclipse brought type ahead to the mainstream this isn't using AI type ahead this is not cursor when surf this is just using static analysis so it's indexing your symbols and then it can rank the symbols and rerank them and it knows what symbols to show i think this was also the first big third party ecosystem for ids copilot was a big jump forward with single line type ahead and then multi-line type ahead and I think Devon was probably the first IDE that introduced this next concept and this next abstraction to the world which is to program you don't have to write code you can write natural language and that becomes code and this is something people have been trying to figure out for decades i think Devon is the first product that broke through and and took this mainstream and the UX has evolved quickly but I think it's about to get even faster we talked about uh UX and we talked about programming languages and verification is a part of this too um so verification has started with manual debugging and like physically inspecting outputs um and now there's a lot of probabilistic verification uh like fuzzing and vulnerability testing and uh like Netflix's chaos uh testing and things like that and so with all this in mind cloud code's approach is a little different it's to start with a terminal and to give you as lowle access to the model as possible in a way that you can still be productive so we want the model to be useful for you we also want to get we want to be unopinionated and we want to get out of the way so we don't give you a bunch of flashy UI we don't try to put a bunch of scaffolding in the way some of this is we're a model company at Enthropic and you know we make models and we want people to experience those models but I think another part is we actually just don't know like we don't know what the right UX is so we're starting simple and so cloud code it's intentionally simple it's intentionally general um it shows off the model in the ways that matter to us which is they can use all your tools and they can fit into all your workloads so you can figure out how to use the model in this world where the UX of using code and using models is changing so fast and so this is my second point the model just keeps getting better and this is the better lesson i have it uh I have I have this like framed and taped to the side of my wall because the more general model always wins and the model increases in capability exponentially and there are many coral areas to this everything around the model is also increasing exponentially and the more general thing even around the model usually wins so with quad code there's one product and there's a lot of ways to use it um so there's a terminal product and you know this is the thing everyone knows so you can install quad code and then you just run claude in any terminal we're unopinionated so it works in iTerm 2 it works in WSL um it works over SSH and T-mok sessions uh it works in your VS Code terminal in your cursor terminal this works anywhere in any terminal when you run when you run quad code in the IDE we do a little bit more so we kind of take over the ID a little bit and you know diffs instead of being inline in the terminal they're going to be big and beautiful and show up in the ID itself um and we also ingest diagnostics um so we kind of try to take advantage of that and you'll notice this isn't as polished as something like uh again like cursor windsurf these are awesome products and I use these every day um this is to let you experience the model in a low-level raw way and this is sort of the minimal that we had to do to let you experience that we announced a couple weeks ago that you can now use Claude on GitHub can I get a show of hands who's who's tried this already so for everyone that hasn't tried this all you have to do is you open up Claude you run this one slashcomand install GitHub app you pick the repo and then you can run Claude in any repo um this is running on your compute um your data stays on your compute it does not go to us um so it's it's kind of a nice experience and it lets you use your existing stack you don't have to change stuff around takes a few minutes to set up and again here we intentionally built something really simple because we don't know what the UX is yet and this is the minimal possible thing that helps us learn but also is useful for engineers to do day-to-day work like I use this every day the extreme version of this is our SDK and this is something that you can use to build on cloud code uh without um if you don't want to use like you know the terminal app or the ID integration or GitHub you can just roll your own integration you can build it however you want people have built all sorts of UIs all sorts of awesome integrations and all this is is you run claw-p uh you can use it programmatically and so like something I use it for for example is for incident triage i'll take my GitHub logs uh or my sorry my GCP logs i'll pipe it into cloudp because it's like it's a Unix utility so you can pipe in you can pipe out um and then I'll like jq the result so it's kind of cool like this is a new way to use models this is maybe 10% exported no one has really figured out how to use models as a Unix utility this is another aspect of code as UX that we just don't know yet and so again we just built the simplest possible thing so we can learn and so people can try it out and see what works for you okay I wanted to give a few tips for how to use quad code this is a talk about quad code so this is kind of zooming back in um and uh this is actually true for I think a lot of coding agents but this is kind of accustomed to the way that I personally use quad code so the simplest way to use this um it seems like most of this room is very familiar with cloud code and similar coding agents um but the simplest way to introduce new people that have not used this kind of tool before is do codebased Q&A and so at Enthropic we teach cloud code to every engineer on day one and it's shortened onboarding times from like two or three weeks to like two days maybe and also I don't get bugged about questions anymore people can just ask Quad and honestly like I'll just ask Quad too and then this is something that I do uh pretty much every day on Monday we have a stand up every week i'll just ask Quad what did I ship that week it'll look through my git commits and it'll it'll tell me so I don't have to keep track the second thing is teach Quad how to use your tools and this is something that has not really existed before when you think about the UX of programming um with every IDE there's sort of like a plug-in ecosystem you know for Emacs there's this kind of lispy dialect that you use to make plugins if you use Eclipse or VS Code you have to make plugins for this new kind of coding tool it can just use all your tools so you give it bash tools you give it MCP tools something I'll often say is here's the CLI tool cla run-help take what you learn and then put it in the cloud MD and now Cloud knows how to use the tool that's all it takes you don't have to build a bridge you don't have to build an extension there's nothing fancy like that um of course if you have like groups of tools or if you have fancier functionality like streaming and things like this you can just use MCP as well traditional coding tools focused a lot on actually writing the code and I think the new kinds of coding tools they do a lot more than that and I think this is a lot of where people that are new to these tools struggle to figure out how to use them so there's a few workflows that I've discovered for using quad code most effectively for myself the first one is have quad code explore and make a plan and run it by me before it writes code um you can also ask it to use thinking so typically we see extended thinking work really well if cla already has something in context so have it use tools have it pull things into context and then think if it's thinking up front you're probably just kind of wasting tokens and it's not going to be that useful but if there's a lot of context it does help a bunch the second one is TDD um I know I try to use TDD it's like it's pretty hard to use in practice but I think now with coding tools it actually works really well um and maybe the reason is it's not me doing it it's the model doing it and so the workflow here is tell Claude to write some tests and kind of describe it and just make it really clear like the tests aren't going to pass yet don't try to run the test because it's going to try to run the test tell it like you know it's not going to pass write the test first commit and then write the code and then commit and this kind of a general case of if cla has a target to iterate against it can do much better so if there's some way to verify the output like a unit test integration test uh a way to screenshot in your iOS simulator uh a way to screenshot in puppeteer just some way to see its output um we actually did this for robots like we taught FOD how to use a 3D printer and then it has a little camera to see the output if it can see the output and you let it iterate the result will be much better than if it couldn't iterate the first shot will be all right but the second or third shot will be pretty good so give it some kind of target to iterate against today we launched plan mode in quad code and this is a way to do the first kind of workflow more easily so anytime hit shift tab and cloud will switch to plan mode so you can ask it to do something but it won't actually do that yet it'll just make a plan and it'll wait for approval so restart quad to get the update run shift tab okay and then the final tip is uh give quad more context there's a bunch of ways to do this quadm is the easiest way so take a this file called quadd put it in the root of your repo you can also put in subfolders those will get pulled in on demand you can put in your home folder this will get pulled in as well um and then you can also use flash commands um so if you put files like just regular markdown files in these special folders commands it'll be available under the slash menu so pretty cool this is useful for res uh reusable workflows and then to add stuff to quadm um you can always type the pound sign to ask quad to memorize something and it'll prompt you which memory they should be added to and you can see this is us trying to figure out how to use memory how to use this new concept that is new to coding models did not exist in previous IDEs how to make the UX of this work and you can tell this is still pretty rough this is our first version but it's the first version that works and so we're going to be iterating on this and we really want to hear feedback about what works about this UX and what doesn't thanks [Applause] Fortunately we only have one minute left so someone sent a question on Slack the question is as I delegate more and more to cloud code as it runs for 10 minutes and I have 10 of these active how do I use the tool you got 50 seconds [Laughter] yeah this is it's pretty cool i think this is something that we actually see in a lot of our power users that they tend to like multi-cloud you don't just have a single quad open but you have a couple terminal tabs either with a few checkouts of cloud or uh or of your codebase or it's the same codebase but with different work trees and you have quad doing stuff in parallel this is also a lot easier with GitHub actions because you can just spawn a bunch of actions and get quad to do a bunch of stuff typically we don't like need to coordinate between these quads I think for most use cases if you don't want to coordinate the best way is just ask them to write to a markdown file um and that's it
 awesome
 yeah well both thing works thank you so much and once again give it up for Boris from Enthropic [Music] 