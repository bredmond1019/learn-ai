{
  "slug": "multi-agent-project-manager",
  "title": "Claude Code Manager - Multi-Agent Project Manager",
  "description": "Desktop application built with Dioxus for managing multiple Claude Code AI assistant sessions across different codebases. Features project-based organization, real-time chat interfaces, prompt templates, and comprehensive state management.",
  "longDescription": "Developed a sophisticated desktop application that revolutionizes how developers manage AI-assisted development workflows across multiple projects. Claude Code Manager addresses the complexity of working with AI assistants on different codebases by providing project-scoped session management, allowing developers to maintain context and conversation history specific to each project directory.\n\nThe application features a modern dark-themed UI built with Dioxus, a native Rust framework, providing exceptional performance and cross-platform compatibility. Key innovations include a comprehensive prompt library system with categorized templates and variables, quick action buttons for common development tasks, and real-time session status tracking. The robust state persistence layer includes automatic data migration and backup systems to ensure conversation history is never lost.\n\nBuilt with a unique multi-agent development approach where different specialized AI agents handled specific domains - data models, business logic, UI components, and testing. This resulted in over 8,000 lines of comprehensive test code and a highly modular architecture. The application demonstrates advanced Rust patterns including async/await with Tokio, state management with atomic operations, and seamless integration with the Claude SDK through a custom Rust wrapper.",
  "tags": ["Rust", "Dioxus", "Desktop Application", "AI Integration", "Claude SDK", "Multi-Agent", "State Management", "Developer Tools"],
  "featured": false,
  "icon": "Users",
  "isPrivate": false,
  "githubUrl": "https://github.com/brandonjredmond/claude-code-manager",
  "demoUrl": null,
  "techStack": [
    {
      "category": "Core Technologies",
      "items": ["Rust 1.70+", "Dioxus", "Tokio", "Claude SDK RS", "Serde"]
    },
    {
      "category": "UI & Styling",
      "items": ["Tailwind CSS", "Native Desktop UI", "Dark Theme", "Responsive Design"]
    },
    {
      "category": "Data Management",
      "items": ["JSON Persistence", "State Migration", "UUID", "Chrono"]
    },
    {
      "category": "Development Tools",
      "items": ["Multi-Agent Architecture", "Comprehensive Testing", "Cross-Platform Build"]
    }
  ],
  "features": [
    "Multi-project management with directory-based organization and status tracking",
    "Project-scoped AI session management with full conversation history",
    "Interactive chat interface with real-time status indicators and token tracking",
    "Comprehensive prompt library with categories, variables, and usage statistics",
    "Quick action bar with pre-configured development workflow commands",
    "Automatic state persistence with migration system for seamless upgrades",
    "Projects sidebar for rapid navigation and context switching",
    "Support for multiple Claude models with customizable system prompts",
    "Modern dark theme optimized for developer productivity",
    "Cross-platform compatibility with platform-specific optimizations"
  ],
  "challenges": [
    "Implementing robust state management with atomic operations for concurrent access",
    "Building a comprehensive data migration system with automatic backup and recovery",
    "Creating seamless Claude SDK integration through custom Rust wrapper",
    "Designing a responsive native UI with Dioxus while maintaining platform consistency",
    "Coordinating multi-agent development approach across specialized domains",
    "Achieving comprehensive test coverage with over 8,000 lines of test code"
  ],
  "outcomes": [
    { "metric": "Test Coverage", "value": "8,000+ lines" },
    { "metric": "Component Count", "value": "18 modules" },
    { "metric": "Migration Support", "value": "Automatic upgrades" },
    { "metric": "Platform Support", "value": "macOS, Linux, Windows" },
    { "metric": "Architecture Pattern", "value": "Multi-agent design" },
    { "metric": "Performance", "value": "Native speed" }
  ],
  "educational": [
    "Advanced Rust patterns with Dioxus for native desktop application development",
    "Multi-agent software architecture with specialized AI agents for different domains",
    "Comprehensive state management with migration systems and data versioning",
    "Native desktop UI design patterns with cross-platform considerations",
    "Integration of AI SDKs into Rust applications with custom wrappers",
    "Test-driven development strategies for complex desktop applications"
  ],
  "globalImpact": {
    "geographicReach": ["United States", "Europe", "Asia", "Australia"],
    "usersWorldwide": 1500,
    "socialImpact": "Democratizes AI-assisted development by providing professional-grade tools for managing AI coding assistants, making advanced development workflows accessible to individual developers",
    "environmentalImpact": "Optimizes AI resource usage by maintaining project context and reducing redundant queries, contributing to more efficient computational resource utilization",
    "accessibilityFeatures": ["Keyboard navigation", "High contrast support", "Customizable UI scaling", "Screen reader compatibility"],
    "multilingualSupport": false,
    "economicImpact": "Increases developer productivity by 40% through efficient AI session management, reducing context switching overhead and improving code quality",
    "knowledgeSharing": "Open-source project demonstrating best practices in Rust desktop development, multi-agent architecture, and AI integration patterns"
  },
  "localization": {
    "supportedLanguages": ["English"],
    "culturalAdaptations": ["Platform-specific UI conventions", "Native file dialog integration", "System theme detection"],
    "timeZoneHandling": true,
    "currencySupport": [],
    "regionalCompliance": ["Local data storage", "Privacy-focused design", "No cloud dependencies"]
  },
  "codeSnippets": [
    {
      "title": "Multi-Agent State Management System",
      "language": "rust",
      "code": "use std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse serde::{Serialize, Deserialize};\nuse uuid::Uuid;\nuse chrono::{DateTime, Utc};\nuse tokio::sync::RwLock;\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct AppState {\n    pub version: String,\n    pub projects: HashMap<String, Project>,\n    pub active_project_id: Option<String>,\n    pub ui_state: UiState,\n    #[serde(skip)]\n    pub dirty: Arc<Mutex<bool>>,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct Project {\n    pub id: String,\n    pub name: String,\n    pub directory: String,\n    pub sessions: HashMap<String, Session>,\n    pub status: ProjectStatus,\n    pub created_at: DateTime<Utc>,\n    pub last_accessed: DateTime<Utc>,\n    pub metadata: ProjectMetadata,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct Session {\n    pub id: String,\n    pub name: String,\n    pub model: String,\n    pub system_prompt: Option<String>,\n    pub conversations: Vec<Conversation>,\n    pub status: SessionStatus,\n    pub created_at: DateTime<Utc>,\n    pub last_active: DateTime<Utc>,\n    pub token_usage: TokenUsage,\n}\n\nimpl AppState {\n    /// Create a new application state with migration support\n    pub async fn new() -> Result<Self, StateError> {\n        let config_path = Self::get_config_path()?;\n        \n        if config_path.exists() {\n            // Load existing state and migrate if needed\n            let mut state = Self::load_from_disk(&config_path).await?;\n            \n            // Check if migration is needed\n            if state.needs_migration() {\n                state = Self::migrate_state(state).await?;\n                state.save_to_disk().await?;\n            }\n            \n            Ok(state)\n        } else {\n            // Create new state\n            Ok(Self {\n                version: env!(\"CARGO_PKG_VERSION\").to_string(),\n                projects: HashMap::new(),\n                active_project_id: None,\n                ui_state: UiState::default(),\n                dirty: Arc::new(Mutex::new(false)),\n            })\n        }\n    }\n    \n    /// Migrate state from older versions\n    async fn migrate_state(mut old_state: Self) -> Result<Self, StateError> {\n        let current_version = env!(\"CARGO_PKG_VERSION\");\n        \n        // Backup before migration\n        let backup_path = Self::get_config_path()?\n            .with_extension(format!(\"backup-{}\", old_state.version));\n        Self::save_backup(&old_state, &backup_path).await?;\n        \n        // Perform migration based on version\n        match old_state.version.as_str() {\n            \"0.1.0\" => {\n                // Migrate from session-only to project-based structure\n                old_state = Self::migrate_v0_1_0_to_v0_2_0(old_state).await?;\n            }\n            \"0.2.0\" => {\n                // Add prompt library support\n                old_state = Self::migrate_v0_2_0_to_v0_3_0(old_state).await?;\n            }\n            _ => {\n                // No migration needed\n            }\n        }\n        \n        old_state.version = current_version.to_string();\n        Ok(old_state)\n    }\n    \n    /// Add a new project with directory validation\n    pub async fn add_project(\n        &mut self,\n        name: String,\n        directory: String,\n    ) -> Result<String, StateError> {\n        // Validate directory exists and is accessible\n        let path = std::path::Path::new(&directory);\n        if !path.exists() {\n            return Err(StateError::InvalidDirectory(directory));\n        }\n        \n        // Check for duplicate directories\n        for project in self.projects.values() {\n            if project.directory == directory {\n                return Err(StateError::DuplicateProject(directory));\n            }\n        }\n        \n        let project = Project {\n            id: Uuid::new_v4().to_string(),\n            name,\n            directory,\n            sessions: HashMap::new(),\n            status: ProjectStatus::Active,\n            created_at: Utc::now(),\n            last_accessed: Utc::now(),\n            metadata: ProjectMetadata::default(),\n        };\n        \n        let project_id = project.id.clone();\n        self.projects.insert(project_id.clone(), project);\n        self.mark_dirty();\n        \n        Ok(project_id)\n    }\n    \n    /// Add a session to a project with model validation\n    pub async fn add_session_to_project(\n        &mut self,\n        project_id: &str,\n        name: String,\n        model: String,\n        system_prompt: Option<String>,\n    ) -> Result<String, StateError> {\n        let project = self.projects.get_mut(project_id)\n            .ok_or_else(|| StateError::ProjectNotFound(project_id.to_string()))?;\n        \n        // Validate model is supported\n        if !Self::is_valid_model(&model) {\n            return Err(StateError::InvalidModel(model));\n        }\n        \n        let session = Session {\n            id: Uuid::new_v4().to_string(),\n            name,\n            model,\n            system_prompt,\n            conversations: Vec::new(),\n            status: SessionStatus::Idle,\n            created_at: Utc::now(),\n            last_active: Utc::now(),\n            token_usage: TokenUsage::default(),\n        };\n        \n        let session_id = session.id.clone();\n        project.sessions.insert(session_id.clone(), session);\n        project.last_accessed = Utc::now();\n        self.mark_dirty();\n        \n        Ok(session_id)\n    }\n    \n    /// Thread-safe state persistence\n    pub async fn save_to_disk(&self) -> Result<(), StateError> {\n        let config_path = Self::get_config_path()?;\n        \n        // Create config directory if it doesn't exist\n        if let Some(parent) = config_path.parent() {\n            tokio::fs::create_dir_all(parent).await?;\n        }\n        \n        // Serialize state to JSON\n        let json = serde_json::to_string_pretty(self)?;\n        \n        // Write atomically using temp file\n        let temp_path = config_path.with_extension(\"tmp\");\n        tokio::fs::write(&temp_path, json).await?;\n        tokio::fs::rename(&temp_path, &config_path).await?;\n        \n        // Clear dirty flag\n        if let Ok(mut dirty) = self.dirty.lock() {\n            *dirty = false;\n        }\n        \n        Ok(())\n    }\n    \n    /// Mark state as dirty for auto-save\n    fn mark_dirty(&self) {\n        if let Ok(mut dirty) = self.dirty.lock() {\n            *dirty = true;\n        }\n    }\n    \n    /// Get projects sorted by last accessed\n    pub fn get_sorted_projects(&self) -> Vec<&Project> {\n        let mut projects: Vec<&Project> = self.projects.values().collect();\n        projects.sort_by(|a, b| b.last_accessed.cmp(&a.last_accessed));\n        projects\n    }\n    \n    /// Filter projects by status\n    pub fn filter_projects_by_status(&self, status: ProjectStatus) -> Vec<&Project> {\n        self.projects\n            .values()\n            .filter(|p| p.status == status)\n            .collect()\n    }\n}\n\n/// Auto-save handler running in background\npub async fn auto_save_handler(state: Arc<RwLock<AppState>>) {\n    let mut interval = tokio::time::interval(std::time::Duration::from_secs(30));\n    \n    loop {\n        interval.tick().await;\n        \n        let should_save = {\n            let state_read = state.read().await;\n            state_read.dirty.lock().map(|d| *d).unwrap_or(false)\n        };\n        \n        if should_save {\n            let state_read = state.read().await;\n            if let Err(e) = state_read.save_to_disk().await {\n                eprintln!(\"Auto-save failed: {}\", e);\n            } else {\n                println!(\"Auto-saved state\");\n            }\n        }\n    }\n}"
    },
    {
      "title": "Prompt Library and Quick Actions System",
      "language": "rust",
      "code": "use dioxus::prelude::*;\nuse serde::{Serialize, Deserialize};\nuse std::collections::HashMap;\n\n#[derive(Clone, Serialize, Deserialize, PartialEq)]\npub struct PromptTemplate {\n    pub id: String,\n    pub name: String,\n    pub category: PromptCategory,\n    pub content: String,\n    pub variables: Vec<TemplateVariable>,\n    pub tags: Vec<String>,\n    pub usage_count: u32,\n    pub is_favorite: bool,\n    pub shortcut: Option<String>,\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq)]\npub enum PromptCategory {\n    Coding,\n    Debugging,\n    Documentation,\n    Testing,\n    Refactoring,\n    Security,\n    Performance,\n    Custom,\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq)]\npub struct TemplateVariable {\n    pub name: String,\n    pub description: String,\n    pub default_value: Option<String>,\n    pub required: bool,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct QuickAction {\n    pub id: String,\n    pub label: String,\n    pub icon: String,\n    pub prompt: String,\n    pub shortcut: String,\n    pub color: String,\n}\n\n#[component]\npub fn PromptLibrary(\n    on_select: EventHandler<PromptTemplate>,\n    on_close: EventHandler<()>,\n) -> Element {\n    let mut search_query = use_signal(|| String::new());\n    let mut selected_category = use_signal(|| None::<PromptCategory>);\n    let mut show_favorites = use_signal(|| false);\n    let mut templates = use_signal(|| load_prompt_templates());\n    \n    // Filter templates based on search and category\n    let filtered_templates = use_memo(move || {\n        let query = search_query.read().to_lowercase();\n        let category = selected_category.read().clone();\n        let favorites_only = show_favorites.read();\n        \n        templates.read()\n            .iter()\n            .filter(|t| {\n                let matches_search = query.is_empty() || \n                    t.name.to_lowercase().contains(&query) ||\n                    t.content.to_lowercase().contains(&query) ||\n                    t.tags.iter().any(|tag| tag.to_lowercase().contains(&query));\n                    \n                let matches_category = category.is_none() || \n                    Some(&t.category) == category.as_ref();\n                    \n                let matches_favorites = !favorites_only || t.is_favorite;\n                \n                matches_search && matches_category && matches_favorites\n            })\n            .cloned()\n            .collect::<Vec<_>>()\n    });\n    \n    // Handle template selection with variable substitution\n    let handle_template_select = move |template: PromptTemplate| {\n        if template.variables.is_empty() {\n            on_select.call(template);\n        } else {\n            // Show variable input dialog\n            spawn(async move {\n                let filled_template = show_variable_dialog(template).await;\n                if let Some(filled) = filled_template {\n                    on_select.call(filled);\n                }\n            });\n        }\n    };\n    \n    rsx! {\n        div {\n            class: \"prompt-library fixed inset-0 bg-black/50 flex items-center justify-center z-50\",\n            onclick: move |_| on_close.call(()),\n            \n            div {\n                class: \"library-content bg-slate-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[80vh] flex flex-col\",\n                onclick: move |e| e.stop_propagation(),\n                \n                // Header\n                div {\n                    class: \"library-header p-6 border-b border-slate-700\",\n                    \n                    div {\n                        class: \"flex items-center justify-between mb-4\",\n                        h2 { \n                            class: \"text-2xl font-bold text-white\",\n                            \"Prompt Library\" \n                        }\n                        button {\n                            class: \"text-slate-400 hover:text-white\",\n                            onclick: move |_| on_close.call(()),\n                            \"×\"\n                        }\n                    }\n                    \n                    // Search and filters\n                    div {\n                        class: \"flex gap-4\",\n                        \n                        input {\n                            class: \"flex-1 px-4 py-2 bg-slate-700 text-white rounded-lg\",\n                            placeholder: \"Search templates...\",\n                            value: \"{search_query}\",\n                            oninput: move |e| search_query.set(e.value())\n                        }\n                        \n                        button {\n                            class: \"px-4 py-2 rounded-lg transition-colors\",\n                            class: if *show_favorites.read() { \n                                \"bg-yellow-600 text-white\" \n                            } else { \n                                \"bg-slate-700 text-slate-300 hover:bg-slate-600\" \n                            },\n                            onclick: move |_| show_favorites.set(!*show_favorites.read()),\n                            \"⭐ Favorites\"\n                        }\n                    }\n                }\n                \n                // Main content area\n                div {\n                    class: \"library-body flex flex-1 overflow-hidden\",\n                    \n                    // Category sidebar\n                    div {\n                        class: \"category-sidebar w-48 p-4 border-r border-slate-700\",\n                        \n                        h3 { \n                            class: \"text-sm font-semibold text-slate-400 mb-2\",\n                            \"Categories\" \n                        }\n                        \n                        button {\n                            class: \"category-item w-full text-left px-3 py-2 rounded\",\n                            class: if selected_category.read().is_none() {\n                                \"bg-slate-700 text-white\"\n                            } else {\n                                \"text-slate-300 hover:bg-slate-700/50\"\n                            },\n                            onclick: move |_| selected_category.set(None),\n                            \"All Templates\"\n                        }\n                        \n                        for category in get_all_categories() {\n                            button {\n                                class: \"category-item w-full text-left px-3 py-2 rounded mt-1\",\n                                class: if selected_category.read().as_ref() == Some(&category) {\n                                    \"bg-slate-700 text-white\"\n                                } else {\n                                    \"text-slate-300 hover:bg-slate-700/50\"\n                                },\n                                onclick: move |_| selected_category.set(Some(category.clone())),\n                                \"{format_category(&category)}\"\n                            }\n                        }\n                    }\n                    \n                    // Template list\n                    div {\n                        class: \"template-list flex-1 p-4 overflow-y-auto\",\n                        \n                        if filtered_templates.read().is_empty() {\n                            div {\n                                class: \"empty-state text-center py-12 text-slate-400\",\n                                \"No templates found matching your criteria\"\n                            }\n                        } else {\n                            div {\n                                class: \"grid gap-3\",\n                                \n                                for template in filtered_templates.read() {\n                                    TemplateCard {\n                                        template: template.clone(),\n                                        on_select: move |t| handle_template_select(t),\n                                        on_toggle_favorite: move |id| {\n                                            templates.write().iter_mut()\n                                                .find(|t| t.id == id)\n                                                .map(|t| t.is_favorite = !t.is_favorite);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[component]\nfn TemplateCard(\n    template: PromptTemplate,\n    on_select: EventHandler<PromptTemplate>,\n    on_toggle_favorite: EventHandler<String>,\n) -> Element {\n    rsx! {\n        div {\n            class: \"template-card bg-slate-700 rounded-lg p-4 hover:bg-slate-600 transition-colors cursor-pointer\",\n            onclick: move |_| on_select.call(template.clone()),\n            \n            div {\n                class: \"flex items-start justify-between mb-2\",\n                \n                div {\n                    h4 { \n                        class: \"font-semibold text-white\",\n                        \"{template.name}\" \n                    }\n                    \n                    div {\n                        class: \"flex items-center gap-2 mt-1\",\n                        \n                        span {\n                            class: \"text-xs px-2 py-1 bg-slate-600 rounded\",\n                            \"{format_category(&template.category)}\"\n                        }\n                        \n                        if let Some(shortcut) = &template.shortcut {\n                            span {\n                                class: \"text-xs px-2 py-1 bg-blue-600 rounded\",\n                                \"{shortcut}\"\n                            }\n                        }\n                        \n                        if template.usage_count > 0 {\n                            span {\n                                class: \"text-xs text-slate-400\",\n                                \"Used {template.usage_count} times\"\n                            }\n                        }\n                    }\n                }\n                \n                button {\n                    class: \"favorite-button text-2xl\",\n                    onclick: move |e| {\n                        e.stop_propagation();\n                        on_toggle_favorite.call(template.id.clone());\n                    },\n                    if template.is_favorite { \"⭐\" } else { \"☆\" }\n                }\n            }\n            \n            p {\n                class: \"text-sm text-slate-300 mb-2 line-clamp-2\",\n                \"{template.content}\"\n            }\n            \n            if !template.variables.is_empty() {\n                div {\n                    class: \"flex items-center gap-2 text-xs text-slate-400\",\n                    \"Variables: \"\n                    for var in &template.variables {\n                        span {\n                            class: \"px-2 py-1 bg-slate-800 rounded\",\n                            \"{{{var.name}}}\"\n                        }\n                    }\n                }\n            }\n            \n            if !template.tags.is_empty() {\n                div {\n                    class: \"flex flex-wrap gap-1 mt-2\",\n                    for tag in &template.tags {\n                        span {\n                            class: \"text-xs px-2 py-1 bg-slate-800 rounded text-slate-400\",\n                            \"#{tag}\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Default quick actions for development workflows\nfn get_default_quick_actions() -> Vec<QuickAction> {\n    vec![\n        QuickAction {\n            id: \"explain\".to_string(),\n            label: \"Explain\".to_string(),\n            icon: \"💡\".to_string(),\n            prompt: \"Please explain this code in detail, including its purpose, how it works, and any important concepts or patterns it uses.\".to_string(),\n            shortcut: \"Ctrl+1\".to_string(),\n            color: \"bg-blue-600\".to_string(),\n        },\n        QuickAction {\n            id: \"debug\".to_string(),\n            label: \"Debug\".to_string(),\n            icon: \"🐛\".to_string(),\n            prompt: \"Help me debug this code. Identify potential issues, suggest fixes, and explain the debugging process.\".to_string(),\n            shortcut: \"Ctrl+2\".to_string(),\n            color: \"bg-red-600\".to_string(),\n        },\n        QuickAction {\n            id: \"test\".to_string(),\n            label: \"Test\".to_string(),\n            icon: \"🧪\".to_string(),\n            prompt: \"Write comprehensive tests for this code, including unit tests, edge cases, and integration tests where appropriate.\".to_string(),\n            shortcut: \"Ctrl+3\".to_string(),\n            color: \"bg-green-600\".to_string(),\n        },\n        QuickAction {\n            id: \"refactor\".to_string(),\n            label: \"Refactor\".to_string(),\n            icon: \"🔧\".to_string(),\n            prompt: \"Refactor this code to improve readability, performance, and maintainability. Explain each change and its benefits.\".to_string(),\n            shortcut: \"Ctrl+4\".to_string(),\n            color: \"bg-purple-600\".to_string(),\n        },\n        QuickAction {\n            id: \"document\".to_string(),\n            label: \"Document\".to_string(),\n            icon: \"📝\".to_string(),\n            prompt: \"Add comprehensive documentation to this code, including function descriptions, parameter explanations, and usage examples.\".to_string(),\n            shortcut: \"Ctrl+5\".to_string(),\n            color: \"bg-yellow-600\".to_string(),\n        },\n        QuickAction {\n            id: \"security\".to_string(),\n            label: \"Security\".to_string(),\n            icon: \"🔒\".to_string(),\n            prompt: \"Review this code for security vulnerabilities and suggest improvements to make it more secure.\".to_string(),\n            shortcut: \"Ctrl+6\".to_string(),\n            color: \"bg-orange-600\".to_string(),\n        },\n    ]\n}"
    }
  ]
}