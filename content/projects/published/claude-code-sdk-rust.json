{
  "slug": "claude-code-sdk-rust",
  "title": "Claude Code SDK for Rust",
  "description": "Type-safe, async-first Rust SDK wrapping Claude Code CLI with advanced security features, achieving 100% safe abstractions while enabling powerful AI integrations.",
  "longDescription": "Developed a comprehensive Rust SDK that democratizes access to Claude AI by providing a type-safe, performant wrapper around the Claude Code CLI. This project represents Brandon's commitment to both technical excellence and developer education, creating an SDK that serves as both a powerful tool and a learning resource for the Rust community.\n\nThe SDK features advanced security controls with four configurable validation levels, granular tool permissions, and context-aware filtering that distinguishes legitimate queries from potential attacks. Built with Rust's ownership model and async/await patterns, it provides zero-cost abstractions while maintaining memory safety and preventing common vulnerabilities.\n\nBeyond its technical merits, the SDK includes comprehensive documentation, working examples for every feature, and educational patterns that help developers understand both Rust best practices and AI integration patterns. The project has gained traction in the Rust community as a model for building safe, efficient AI tooling.",
  "tags": ["Rust", "SDK", "Claude AI", "Security", "Async", "Type Safety"],
  "featured": true,
  "icon": "Code2",
  "isPrivate": false,
  "githubUrl": "https://github.com/bredmond1019/claude-sdk-rust",
  "demoUrl": "https://crates.io/crates/claude-sdk-rs",
  "techStack": [
    {
      "category": "Core Technologies",
      "items": ["Rust 1.70+", "Tokio Async Runtime", "Serde JSON", "Type-Safe API", "Zero-Cost Abstractions"]
    },
    {
      "category": "Security Features",
      "items": ["Configurable Validation Levels", "Command Injection Protection", "Context-Aware Filtering", "Granular Permissions", "Process Isolation"]
    },
    {
      "category": "Integration Capabilities",
      "items": ["Model Context Protocol", "Tool Discovery", "Session Management", "Streaming Support", "SQLite Persistence"]
    },
    {
      "category": "Developer Experience",
      "items": ["Builder Pattern API", "Feature Flags", "Comprehensive Examples", "CI/CD Pipeline", "Benchmarking Suite"]
    }
  ],
  "features": [
    "Type-safe API with compile-time guarantees and builder patterns",
    "Four security levels from strict to relaxed validation",
    "Async/await support built on Tokio for efficient concurrency",
    "Multiple response modes: simple text, full metadata, or streaming",
    "Automatic session management with context preservation",
    "Granular tool permissions for Bash commands and MCP tools",
    "Feature flags for minimal dependencies and custom builds",
    "Comprehensive error handling with actionable messages"
  ],
  "challenges": [
    "Designing a security system that balances safety with usability",
    "Creating zero-cost abstractions over CLI processes",
    "Implementing context-aware validation for legitimate queries",
    "Building an intuitive API that feels native to Rust",
    "Managing async streaming with proper backpressure handling"
  ],
  "outcomes": [
    { "metric": "API Safety", "value": "100% type-safe" },
    { "metric": "Performance", "value": "Zero-cost abstractions" },
    { "metric": "Documentation", "value": "8 examples" },
    { "metric": "Test Coverage", "value": "Comprehensive" },
    { "metric": "Security Levels", "value": "4 configurable" }
  ],
  "educational": [
    "Demonstrates Rust best practices for SDK development",
    "Shows how to build type-safe wrappers around CLI tools",
    "Teaches async/await patterns with Tokio runtime",
    "Illustrates security design with configurable validation",
    "Provides examples of builder patterns and feature flags",
    "Explains error handling strategies in production Rust code"
  ],
  "globalImpact": {
    "geographicReach": ["United States", "Europe", "Asia", "Canada", "Australia"],
    "usersWorldwide": 250,
    "socialImpact": "Makes Claude AI accessible to Rust developers worldwide, enabling them to build AI-powered applications with memory safety and performance guarantees",
    "environmentalImpact": "Rust's efficiency reduces computational overhead compared to interpreted languages, lowering energy consumption for AI operations",
    "accessibilityFeatures": ["Comprehensive documentation", "Multiple API patterns for different skill levels", "Detailed error messages"],
    "multilingualSupport": false,
    "economicImpact": "Enables Rust developers to integrate AI capabilities without switching languages, reducing development costs and time-to-market",
    "knowledgeSharing": "Open-source project with extensive examples, documentation, and architectural guides for the Rust community"
  },
  "localization": {
    "supportedLanguages": ["English"],
    "culturalAdaptations": ["Examples cover diverse use cases"],
    "timeZoneHandling": false,
    "currencySupport": [],
    "regionalCompliance": ["MIT License for global use"]
  },
  "codeSnippets": [
    {
      "title": "Type-Safe SDK with Security Configuration",
      "language": "rust",
      "code": "use claude_sdk_rs::{Client, Config, SecurityLevel, ToolPermission, Error};\nuse std::time::Duration;\n\n#[derive(Debug)]\npub struct SecureClaudeClient {\n    client: Client,\n    audit_log: Vec<AuditEntry>,\n}\n\n#[derive(Debug)]\nstruct AuditEntry {\n    timestamp: std::time::Instant,\n    query: String,\n    security_level: SecurityLevel,\n    outcome: Result<(), String>,\n}\n\nimpl SecureClaudeClient {\n    /// Create a new client with configurable security\n    pub fn new(security_level: SecurityLevel) -> Self {\n        let client = Client::builder()\n            .model(\"claude-3-sonnet-20240229\")\n            .system_prompt(\"You are a helpful assistant with security awareness\")\n            .security_level(security_level)\n            .timeout_secs(30)\n            .max_turns(10)\n            .disallowed_tools(vec![\n                ToolPermission::bash(\"rm\").to_cli_format(),\n                ToolPermission::bash(\"sudo\").to_cli_format(),\n                \"mcp__system__delete\".to_string(),\n            ])\n            .build();\n            \n        Self {\n            client,\n            audit_log: Vec::new(),\n        }\n    }\n    \n    /// Send a query with automatic security validation and logging\n    pub async fn query_with_audit(\n        &mut self,\n        query: &str,\n    ) -> Result<String, Error> {\n        let start = std::time::Instant::now();\n        \n        // Validate query based on security level\n        if let Err(e) = self.validate_query(query) {\n            self.audit_log.push(AuditEntry {\n                timestamp: start,\n                query: query.to_string(),\n                security_level: self.client.config().security_level,\n                outcome: Err(format!(\"Validation failed: {}\", e)),\n            });\n            return Err(Error::ValidationError(e.to_string()));\n        }\n        \n        // Execute query with the configured client\n        let result = self.client\n            .query(query)\n            .send()\n            .await;\n            \n        // Log the outcome\n        self.audit_log.push(AuditEntry {\n            timestamp: start,\n            query: query.to_string(),\n            security_level: self.client.config().security_level,\n            outcome: result.as_ref().map(|_| ()).map_err(|e| e.to_string()),\n        });\n        \n        result\n    }\n    \n    fn validate_query(&self, query: &str) -> Result<(), &'static str> {\n        match self.client.config().security_level {\n            SecurityLevel::Strict => {\n                // Block queries with special characters\n                if query.chars().any(|c| \"$`\\\\|;&<>()\".contains(c)) {\n                    return Err(\"Special characters not allowed in strict mode\");\n                }\n            }\n            SecurityLevel::Balanced => {\n                // Context-aware validation\n                if self.is_likely_attack(query) {\n                    return Err(\"Query appears to contain malicious patterns\");\n                }\n            }\n            SecurityLevel::Relaxed => {\n                // Only block obvious attacks\n                if query.contains(\"rm -rf /\") || query.contains(\"DROP TABLE\") {\n                    return Err(\"Dangerous command detected\");\n                }\n            }\n            SecurityLevel::Disabled => {\n                // No validation\n            }\n        }\n        Ok(())\n    }\n    \n    fn is_likely_attack(&self, query: &str) -> bool {\n        // Context-aware patterns that distinguish attacks from legitimate queries\n        let attack_patterns = [\n            r\"\\$\\(.*\\)\",           // Command substitution\n            r\"`;.*`\",               // Backtick execution\n            r\"\\|\\|.*&&\",           // Shell operators\n            r\"\\\\x[0-9a-fA-F]{2}\",  // Hex encoding\n        ];\n        \n        let legitimate_contexts = [\n            r\"create.*\\.md\",       // Creating markdown files\n            r\"git (add|commit|push)\", // Git commands\n            r\"cargo (build|test|run)\", // Cargo commands\n        ];\n        \n        // Check if query matches legitimate patterns first\n        for pattern in &legitimate_contexts {\n            if regex::Regex::new(pattern).unwrap().is_match(query) {\n                return false;\n            }\n        }\n        \n        // Then check for attack patterns\n        for pattern in &attack_patterns {\n            if regex::Regex::new(pattern).unwrap().is_match(query) {\n                return true;\n            }\n        }\n        \n        false\n    }\n    \n    /// Get audit log for security analysis\n    pub fn audit_log(&self) -> &[AuditEntry] {\n        &self.audit_log\n    }\n}\n\n// Example usage showing different security levels\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Strict mode for untrusted input\n    let mut strict_client = SecureClaudeClient::new(SecurityLevel::Strict);\n    \n    // This will fail in strict mode\n    match strict_client.query_with_audit(\"List files with ls | grep .rs\").await {\n        Ok(_) => println!(\"Query succeeded\"),\n        Err(e) => println!(\"Expected error in strict mode: {}\", e),\n    }\n    \n    // Balanced mode for general use\n    let mut balanced_client = SecureClaudeClient::new(SecurityLevel::Balanced);\n    \n    // This legitimate query will succeed\n    let response = balanced_client\n        .query_with_audit(\"Create a file called project-notes.md\")\n        .await?;\n    println!(\"Claude says: {}\", response);\n    \n    // But this attack will be blocked\n    match balanced_client.query_with_audit(\"Run $(rm -rf /)\").await {\n        Ok(_) => println!(\"This shouldn't happen!\"),\n        Err(e) => println!(\"Attack blocked: {}\", e),\n    }\n    \n    // Print audit log\n    println!(\"\\nAudit Log:\");\n    for entry in balanced_client.audit_log() {\n        println!(\"{:?}\", entry);\n    }\n    \n    Ok(())\n}"
    },
    {
      "title": "Async Streaming with Session Management",
      "language": "rust",
      "code": "use claude_sdk_rs::{Client, StreamFormat, StreamMessage};\nuse futures::StreamExt;\nuse std::collections::HashMap;\nuse tokio::sync::mpsc;\n\n/// Manages Claude sessions with streaming support\npub struct SessionManager {\n    client: Client,\n    sessions: HashMap<String, SessionState>,\n    event_sender: mpsc::Sender<SessionEvent>,\n}\n\n#[derive(Debug, Clone)]\nstruct SessionState {\n    id: String,\n    created_at: std::time::Instant,\n    message_count: usize,\n    total_tokens: usize,\n    context: Vec<String>,\n}\n\n#[derive(Debug)]\nenum SessionEvent {\n    MessageReceived { session_id: String, content: String },\n    TokensUsed { session_id: String, count: usize },\n    StreamComplete { session_id: String },\n    Error { session_id: String, error: String },\n}\n\nimpl SessionManager {\n    pub fn new() -> (Self, mpsc::Receiver<SessionEvent>) {\n        let (event_sender, event_receiver) = mpsc::channel(100);\n        \n        let client = Client::builder()\n            .stream_format(StreamFormat::Json)\n            .append_system_prompt(\"Track conversation context and provide coherent responses.\")\n            .build();\n            \n        let manager = Self {\n            client,\n            sessions: HashMap::new(),\n            event_sender,\n        };\n        \n        (manager, event_receiver)\n    }\n    \n    /// Create a new session\n    pub fn create_session(&mut self, session_id: String) -> &SessionState {\n        let state = SessionState {\n            id: session_id.clone(),\n            created_at: std::time::Instant::now(),\n            message_count: 0,\n            total_tokens: 0,\n            context: Vec::new(),\n        };\n        \n        self.sessions.insert(session_id.clone(), state);\n        self.sessions.get(&session_id).unwrap()\n    }\n    \n    /// Stream a response for a given session\n    pub async fn stream_query(\n        &mut self,\n        session_id: &str,\n        query: &str,\n    ) -> Result<String, claude_sdk_rs::Error> {\n        // Get or create session\n        if !self.sessions.contains_key(session_id) {\n            self.create_session(session_id.to_string());\n        }\n        \n        // Update session context\n        if let Some(session) = self.sessions.get_mut(session_id) {\n            session.context.push(format!(\"User: {}\", query));\n            session.message_count += 1;\n        }\n        \n        // Build query with context\n        let context = self.sessions.get(session_id)\n            .map(|s| s.context.join(\"\\n\"))\n            .unwrap_or_default();\n            \n        let contextualized_query = if context.is_empty() {\n            query.to_string()\n        } else {\n            format!(\"Previous context:\\n{}\\n\\nCurrent query: {}\", context, query)\n        };\n        \n        // Stream the response\n        let mut stream = self.client\n            .query(&contextualized_query)\n            .stream()\n            .await?;\n            \n        let mut full_response = String::new();\n        let mut token_count = 0;\n        \n        while let Some(chunk) = stream.next().await {\n            match chunk {\n                Ok(StreamMessage { content: Some(text), metadata, .. }) => {\n                    full_response.push_str(&text);\n                    \n                    // Track tokens if available\n                    if let Some(meta) = metadata {\n                        if let Some(tokens) = meta.tokens_used {\n                            token_count += tokens.total.unwrap_or(0);\n                        }\n                    }\n                    \n                    // Send event\n                    let _ = self.event_sender.send(SessionEvent::MessageReceived {\n                        session_id: session_id.to_string(),\n                        content: text,\n                    }).await;\n                }\n                Ok(_) => {}, // Other message types\n                Err(e) => {\n                    let _ = self.event_sender.send(SessionEvent::Error {\n                        session_id: session_id.to_string(),\n                        error: e.to_string(),\n                    }).await;\n                    return Err(e);\n                }\n            }\n        }\n        \n        // Update session state\n        if let Some(session) = self.sessions.get_mut(session_id) {\n            session.context.push(format!(\"Assistant: {}\", full_response));\n            session.total_tokens += token_count;\n        }\n        \n        // Send completion event\n        let _ = self.event_sender.send(SessionEvent::StreamComplete {\n            session_id: session_id.to_string(),\n        }).await;\n        \n        let _ = self.event_sender.send(SessionEvent::TokensUsed {\n            session_id: session_id.to_string(),\n            count: token_count,\n        }).await;\n        \n        Ok(full_response)\n    }\n    \n    /// Get session statistics\n    pub fn get_session_stats(&self, session_id: &str) -> Option<SessionStats> {\n        self.sessions.get(session_id).map(|session| SessionStats {\n            duration: session.created_at.elapsed(),\n            message_count: session.message_count,\n            total_tokens: session.total_tokens,\n            avg_tokens_per_message: if session.message_count > 0 {\n                session.total_tokens / session.message_count\n            } else {\n                0\n            },\n        })\n    }\n}\n\n#[derive(Debug)]\npub struct SessionStats {\n    pub duration: std::time::Duration,\n    pub message_count: usize,\n    pub total_tokens: usize,\n    pub avg_tokens_per_message: usize,\n}\n\n// Example usage with concurrent sessions\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let (mut manager, mut event_receiver) = SessionManager::new();\n    \n    // Spawn event handler\n    tokio::spawn(async move {\n        while let Some(event) = event_receiver.recv().await {\n            match event {\n                SessionEvent::MessageReceived { session_id, content } => {\n                    print!(\"{}\", content); // Real-time output\n                }\n                SessionEvent::StreamComplete { session_id } => {\n                    println!(\"\\n[Session {} complete]\", session_id);\n                }\n                SessionEvent::TokensUsed { session_id, count } => {\n                    println!(\"[Session {} used {} tokens]\", session_id, count);\n                }\n                SessionEvent::Error { session_id, error } => {\n                    eprintln!(\"[Session {} error: {}]\", session_id, error);\n                }\n            }\n        }\n    });\n    \n    // Create multiple concurrent sessions\n    let sessions = vec![\"alice\", \"bob\", \"charlie\"];\n    \n    for session_id in sessions {\n        let response = manager.stream_query(\n            session_id,\n            \"Hello! What's your name?\"\n        ).await?;\n        \n        // Follow-up that requires context\n        let follow_up = manager.stream_query(\n            session_id,\n            \"Can you remind me what we just talked about?\"\n        ).await?;\n        \n        // Print session stats\n        if let Some(stats) = manager.get_session_stats(session_id) {\n            println!(\"\\nSession {} stats: {:?}\", session_id, stats);\n        }\n    }\n    \n    Ok(())\n}"
    }
  ]
}