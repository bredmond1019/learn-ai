{
  "slug": "claude-code-sdk-rust",
  "title": "Claude Code SDK para Rust",
  "description": "SDK type-safe e async-first para Rust que encapsula o Claude Code CLI com recursos avançados de segurança, alcançando 100% de abstrações seguras enquanto permite integrações poderosas com IA.",
  "longDescription": "Desenvolvi um SDK abrangente para Rust que democratiza o acesso ao Claude AI fornecendo um wrapper type-safe e performático ao redor do Claude Code CLI. Este projeto representa o compromisso de Brandon com excelência técnica e educação de desenvolvedores, criando um SDK que serve tanto como ferramenta poderosa quanto como recurso de aprendizado para a comunidade Rust.\n\nO SDK apresenta controles de segurança avançados com quatro níveis de validação configuráveis, permissões granulares de ferramentas e filtragem sensível ao contexto que distingue consultas legítimas de potenciais ataques. Construído com o modelo de ownership do Rust e padrões async/await, fornece abstrações de custo zero mantendo segurança de memória e prevenindo vulnerabilidades comuns.\n\nAlém de seus méritos técnicos, o SDK inclui documentação abrangente, exemplos funcionais para cada recurso e padrões educacionais que ajudam desenvolvedores a entender tanto as melhores práticas do Rust quanto padrões de integração com IA. O projeto ganhou tração na comunidade Rust como modelo para construir ferramentas de IA seguras e eficientes.",
  "tags": ["Rust", "SDK", "Claude AI", "Segurança", "Async", "Type Safety"],
  "featured": false,
  "icon": "Code2",
  "isPrivate": false,
  "githubUrl": "https://github.com/bredmond1019/claude-sdk-rust",
  "demoUrl": "https://crates.io/crates/claude-sdk-rs",
  "techStack": [
    {
      "category": "Tecnologias Principais",
      "items": ["Rust 1.70+", "Tokio Async Runtime", "Serde JSON", "API Type-Safe", "Abstrações de Custo Zero"]
    },
    {
      "category": "Recursos de Segurança",
      "items": ["Níveis de Validação Configuráveis", "Proteção contra Injeção de Comandos", "Filtragem Sensível ao Contexto", "Permissões Granulares", "Isolamento de Processos"]
    },
    {
      "category": "Capacidades de Integração",
      "items": ["Model Context Protocol", "Descoberta de Ferramentas", "Gerenciamento de Sessão", "Suporte a Streaming", "Persistência SQLite"]
    },
    {
      "category": "Experiência do Desenvolvedor",
      "items": ["API com Builder Pattern", "Feature Flags", "Exemplos Abrangentes", "Pipeline CI/CD", "Suite de Benchmarking"]
    }
  ],
  "features": [
    "API type-safe com garantias em tempo de compilação e builder patterns",
    "Quatro níveis de segurança desde validação estrita até relaxada",
    "Suporte async/await construído sobre Tokio para concorrência eficiente",
    "Múltiplos modos de resposta: texto simples, metadados completos ou streaming",
    "Gerenciamento automático de sessão com preservação de contexto",
    "Permissões granulares de ferramentas para comandos Bash e ferramentas MCP",
    "Feature flags para dependências mínimas e builds customizadas",
    "Tratamento abrangente de erros com mensagens acionáveis"
  ],
  "challenges": [
    "Projetar um sistema de segurança que equilibre segurança com usabilidade",
    "Criar abstrações de custo zero sobre processos CLI",
    "Implementar validação sensível ao contexto para consultas legítimas",
    "Construir uma API intuitiva que pareça nativa ao Rust",
    "Gerenciar streaming assíncrono com tratamento adequado de backpressure"
  ],
  "outcomes": [
    { "metric": "Segurança da API", "value": "100% type-safe" },
    { "metric": "Performance", "value": "Abstrações de custo zero" },
    { "metric": "Documentação", "value": "8 exemplos" },
    { "metric": "Cobertura de Testes", "value": "Abrangente" },
    { "metric": "Níveis de Segurança", "value": "4 configuráveis" }
  ],
  "educational": [
    "Demonstra melhores práticas do Rust para desenvolvimento de SDK",
    "Mostra como construir wrappers type-safe ao redor de ferramentas CLI",
    "Ensina padrões async/await com runtime Tokio",
    "Ilustra design de segurança com validação configurável",
    "Fornece exemplos de builder patterns e feature flags",
    "Explica estratégias de tratamento de erros em código Rust de produção"
  ],
  "globalImpact": {
    "geographicReach": ["Estados Unidos", "Europa", "Ásia", "Canadá", "Austrália"],
    "usersWorldwide": 250,
    "socialImpact": "Torna o Claude AI acessível para desenvolvedores Rust em todo o mundo, permitindo que construam aplicações com IA com garantias de segurança de memória e performance",
    "environmentalImpact": "A eficiência do Rust reduz o overhead computacional comparado a linguagens interpretadas, diminuindo o consumo de energia para operações de IA",
    "accessibilityFeatures": ["Documentação abrangente", "Múltiplos padrões de API para diferentes níveis de habilidade", "Mensagens de erro detalhadas"],
    "multilingualSupport": false,
    "economicImpact": "Permite que desenvolvedores Rust integrem capacidades de IA sem trocar de linguagem, reduzindo custos de desenvolvimento e time-to-market",
    "knowledgeSharing": "Projeto open-source com extensos exemplos, documentação e guias arquiteturais para a comunidade Rust"
  },
  "localization": {
    "supportedLanguages": ["Inglês"],
    "culturalAdaptations": ["Exemplos cobrem diversos casos de uso"],
    "timeZoneHandling": false,
    "currencySupport": [],
    "regionalCompliance": ["Licença MIT para uso global"]
  },
  "codeSnippets": [
    {
      "title": "SDK Type-Safe com Configuração de Segurança",
      "language": "rust",
      "code": "use claude_sdk_rs::{Client, Config, SecurityLevel, ToolPermission, Error};\nuse std::time::Duration;\n\n#[derive(Debug)]\npub struct SecureClaudeClient {\n    client: Client,\n    audit_log: Vec<AuditEntry>,\n}\n\n#[derive(Debug)]\nstruct AuditEntry {\n    timestamp: std::time::Instant,\n    query: String,\n    security_level: SecurityLevel,\n    outcome: Result<(), String>,\n}\n\nimpl SecureClaudeClient {\n    /// Create a new client with configurable security\n    pub fn new(security_level: SecurityLevel) -> Self {\n        let client = Client::builder()\n            .model(\"claude-3-sonnet-20240229\")\n            .system_prompt(\"You are a helpful assistant with security awareness\")\n            .security_level(security_level)\n            .timeout_secs(30)\n            .max_turns(10)\n            .disallowed_tools(vec![\n                ToolPermission::bash(\"rm\").to_cli_format(),\n                ToolPermission::bash(\"sudo\").to_cli_format(),\n                \"mcp__system__delete\".to_string(),\n            ])\n            .build();\n            \n        Self {\n            client,\n            audit_log: Vec::new(),\n        }\n    }\n    \n    /// Send a query with automatic security validation and logging\n    pub async fn query_with_audit(\n        &mut self,\n        query: &str,\n    ) -> Result<String, Error> {\n        let start = std::time::Instant::now();\n        \n        // Validate query based on security level\n        if let Err(e) = self.validate_query(query) {\n            self.audit_log.push(AuditEntry {\n                timestamp: start,\n                query: query.to_string(),\n                security_level: self.client.config().security_level,\n                outcome: Err(format!(\"Validation failed: {}\", e)),\n            });\n            return Err(Error::ValidationError(e.to_string()));\n        }\n        \n        // Execute query with the configured client\n        let result = self.client\n            .query(query)\n            .send()\n            .await;\n            \n        // Log the outcome\n        self.audit_log.push(AuditEntry {\n            timestamp: start,\n            query: query.to_string(),\n            security_level: self.client.config().security_level,\n            outcome: result.as_ref().map(|_| ()).map_err(|e| e.to_string()),\n        });\n        \n        result\n    }\n    \n    fn validate_query(&self, query: &str) -> Result<(), &'static str> {\n        match self.client.config().security_level {\n            SecurityLevel::Strict => {\n                // Block queries with special characters\n                if query.chars().any(|c| \"$`\\\\|;&<>()\".contains(c)) {\n                    return Err(\"Special characters not allowed in strict mode\");\n                }\n            }\n            SecurityLevel::Balanced => {\n                // Context-aware validation\n                if self.is_likely_attack(query) {\n                    return Err(\"Query appears to contain malicious patterns\");\n                }\n            }\n            SecurityLevel::Relaxed => {\n                // Only block obvious attacks\n                if query.contains(\"rm -rf /\") || query.contains(\"DROP TABLE\") {\n                    return Err(\"Dangerous command detected\");\n                }\n            }\n            SecurityLevel::Disabled => {\n                // No validation\n            }\n        }\n        Ok(())\n    }\n    \n    fn is_likely_attack(&self, query: &str) -> bool {\n        // Context-aware patterns that distinguish attacks from legitimate queries\n        let attack_patterns = [\n            r\"\\$\\(.*\\)\",           // Command substitution\n            r\"`;.*`\",               // Backtick execution\n            r\"\\|\\|.*&&\",           // Shell operators\n            r\"\\\\x[0-9a-fA-F]{2}\",  // Hex encoding\n        ];\n        \n        let legitimate_contexts = [\n            r\"create.*\\.md\",       // Creating markdown files\n            r\"git (add|commit|push)\", // Git commands\n            r\"cargo (build|test|run)\", // Cargo commands\n        ];\n        \n        // Check if query matches legitimate patterns first\n        for pattern in &legitimate_contexts {\n            if regex::Regex::new(pattern).unwrap().is_match(query) {\n                return false;\n            }\n        }\n        \n        // Then check for attack patterns\n        for pattern in &attack_patterns {\n            if regex::Regex::new(pattern).unwrap().is_match(query) {\n                return true;\n            }\n        }\n        \n        false\n    }\n    \n    /// Get audit log for security analysis\n    pub fn audit_log(&self) -> &[AuditEntry] {\n        &self.audit_log\n    }\n}\n\n// Example usage showing different security levels\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Strict mode for untrusted input\n    let mut strict_client = SecureClaudeClient::new(SecurityLevel::Strict);\n    \n    // This will fail in strict mode\n    match strict_client.query_with_audit(\"List files with ls | grep .rs\").await {\n        Ok(_) => println!(\"Query succeeded\"),\n        Err(e) => println!(\"Expected error in strict mode: {}\", e),\n    }\n    \n    // Balanced mode for general use\n    let mut balanced_client = SecureClaudeClient::new(SecurityLevel::Balanced);\n    \n    // This legitimate query will succeed\n    let response = balanced_client\n        .query_with_audit(\"Create a file called project-notes.md\")\n        .await?;\n    println!(\"Claude says: {}\", response);\n    \n    // But this attack will be blocked\n    match balanced_client.query_with_audit(\"Run $(rm -rf /)\").await {\n        Ok(_) => println!(\"This shouldn't happen!\"),\n        Err(e) => println!(\"Attack blocked: {}\", e),\n    }\n    \n    // Print audit log\n    println!(\"\\nAudit Log:\");\n    for entry in balanced_client.audit_log() {\n        println!(\"{:?}\", entry);\n    }\n    \n    Ok(())\n}"
    },
    {
      "title": "Streaming Assíncrono com Gerenciamento de Sessão",
      "language": "rust",
      "code": "use claude_sdk_rs::{Client, StreamFormat, StreamMessage};\nuse futures::StreamExt;\nuse std::collections::HashMap;\nuse tokio::sync::mpsc;\n\n/// Manages Claude sessions with streaming support\npub struct SessionManager {\n    client: Client,\n    sessions: HashMap<String, SessionState>,\n    event_sender: mpsc::Sender<SessionEvent>,\n}\n\n#[derive(Debug, Clone)]\nstruct SessionState {\n    id: String,\n    created_at: std::time::Instant,\n    message_count: usize,\n    total_tokens: usize,\n    context: Vec<String>,\n}\n\n#[derive(Debug)]\nenum SessionEvent {\n    MessageReceived { session_id: String, content: String },\n    TokensUsed { session_id: String, count: usize },\n    StreamComplete { session_id: String },\n    Error { session_id: String, error: String },\n}\n\nimpl SessionManager {\n    pub fn new() -> (Self, mpsc::Receiver<SessionEvent>) {\n        let (event_sender, event_receiver) = mpsc::channel(100);\n        \n        let client = Client::builder()\n            .stream_format(StreamFormat::Json)\n            .append_system_prompt(\"Track conversation context and provide coherent responses.\")\n            .build();\n            \n        let manager = Self {\n            client,\n            sessions: HashMap::new(),\n            event_sender,\n        };\n        \n        (manager, event_receiver)\n    }\n    \n    /// Create a new session\n    pub fn create_session(&mut self, session_id: String) -> &SessionState {\n        let state = SessionState {\n            id: session_id.clone(),\n            created_at: std::time::Instant::now(),\n            message_count: 0,\n            total_tokens: 0,\n            context: Vec::new(),\n        };\n        \n        self.sessions.insert(session_id.clone(), state);\n        self.sessions.get(&session_id).unwrap()\n    }\n    \n    /// Stream a response for a given session\n    pub async fn stream_query(\n        &mut self,\n        session_id: &str,\n        query: &str,\n    ) -> Result<String, claude_sdk_rs::Error> {\n        // Get or create session\n        if !self.sessions.contains_key(session_id) {\n            self.create_session(session_id.to_string());\n        }\n        \n        // Update session context\n        if let Some(session) = self.sessions.get_mut(session_id) {\n            session.context.push(format!(\"User: {}\", query));\n            session.message_count += 1;\n        }\n        \n        // Build query with context\n        let context = self.sessions.get(session_id)\n            .map(|s| s.context.join(\"\\n\"))\n            .unwrap_or_default();\n            \n        let contextualized_query = if context.is_empty() {\n            query.to_string()\n        } else {\n            format!(\"Previous context:\\n{}\\n\\nCurrent query: {}\", context, query)\n        };\n        \n        // Stream the response\n        let mut stream = self.client\n            .query(&contextualized_query)\n            .stream()\n            .await?;\n            \n        let mut full_response = String::new();\n        let mut token_count = 0;\n        \n        while let Some(chunk) = stream.next().await {\n            match chunk {\n                Ok(StreamMessage { content: Some(text), metadata, .. }) => {\n                    full_response.push_str(&text);\n                    \n                    // Track tokens if available\n                    if let Some(meta) = metadata {\n                        if let Some(tokens) = meta.tokens_used {\n                            token_count += tokens.total.unwrap_or(0);\n                        }\n                    }\n                    \n                    // Send event\n                    let _ = self.event_sender.send(SessionEvent::MessageReceived {\n                        session_id: session_id.to_string(),\n                        content: text,\n                    }).await;\n                }\n                Ok(_) => {}, // Other message types\n                Err(e) => {\n                    let _ = self.event_sender.send(SessionEvent::Error {\n                        session_id: session_id.to_string(),\n                        error: e.to_string(),\n                    }).await;\n                    return Err(e);\n                }\n            }\n        }\n        \n        // Update session state\n        if let Some(session) = self.sessions.get_mut(session_id) {\n            session.context.push(format!(\"Assistant: {}\", full_response));\n            session.total_tokens += token_count;\n        }\n        \n        // Send completion event\n        let _ = self.event_sender.send(SessionEvent::StreamComplete {\n            session_id: session_id.to_string(),\n        }).await;\n        \n        let _ = self.event_sender.send(SessionEvent::TokensUsed {\n            session_id: session_id.to_string(),\n            count: token_count,\n        }).await;\n        \n        Ok(full_response)\n    }\n    \n    /// Get session statistics\n    pub fn get_session_stats(&self, session_id: &str) -> Option<SessionStats> {\n        self.sessions.get(session_id).map(|session| SessionStats {\n            duration: session.created_at.elapsed(),\n            message_count: session.message_count,\n            total_tokens: session.total_tokens,\n            avg_tokens_per_message: if session.message_count > 0 {\n                session.total_tokens / session.message_count\n            } else {\n                0\n            },\n        })\n    }\n}\n\n#[derive(Debug)]\npub struct SessionStats {\n    pub duration: std::time::Duration,\n    pub message_count: usize,\n    pub total_tokens: usize,\n    pub avg_tokens_per_message: usize,\n}\n\n// Example usage with concurrent sessions\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let (mut manager, mut event_receiver) = SessionManager::new();\n    \n    // Spawn event handler\n    tokio::spawn(async move {\n        while let Some(event) = event_receiver.recv().await {\n            match event {\n                SessionEvent::MessageReceived { session_id, content } => {\n                    print!(\"{}\", content); // Real-time output\n                }\n                SessionEvent::StreamComplete { session_id } => {\n                    println!(\"\\n[Session {} complete]\", session_id);\n                }\n                SessionEvent::TokensUsed { session_id, count } => {\n                    println!(\"[Session {} used {} tokens]\", session_id, count);\n                }\n                SessionEvent::Error { session_id, error } => {\n                    eprintln!(\"[Session {} error: {}]\", session_id, error);\n                }\n            }\n        }\n    });\n    \n    // Create multiple concurrent sessions\n    let sessions = vec![\"alice\", \"bob\", \"charlie\"];\n    \n    for session_id in sessions {\n        let response = manager.stream_query(\n            session_id,\n            \"Hello! What's your name?\"\n        ).await?;\n        \n        // Follow-up that requires context\n        let follow_up = manager.stream_query(\n            session_id,\n            \"Can you remind me what we just talked about?\"\n        ).await?;\n        \n        // Print session stats\n        if let Some(stats) = manager.get_session_stats(session_id) {\n            println!(\"\\nSession {} stats: {:?}\", session_id, stats);\n        }\n    }\n    \n    Ok(())\n}"
    }
  ]
}