{
  "slug": "ai-tutor",
  "title": "Tutor Pessoal de IA",
  "description": "Sistema multi-agente de pesquisa que cria experiências de aprendizado personalizadas usando orquestração MCP, alcançando síntese de conhecimento em tempo real de diversas fontes com visualizações interativas.",
  "longDescription": "Desenvolvi um sistema de tutoria inteligente que transforma como as pessoas aprendem tópicos complexos ao orquestrar agentes de IA especializados através do Model Context Protocol (MCP). Este projeto representa uma síntese de pedagogia educacional e engenharia de IA de ponta, criando caminhos de aprendizado personalizados que se adaptam aos níveis de experiência individuais.\n\nO sistema demonstra coordenação avançada de agentes, onde múltiplos agentes especializados trabalham em paralelo para pesquisar tópicos, extrair conceitos-chave, construir grafos de conhecimento e gerar resumos personalizados. Cada componente é projetado com princípios educacionais em mente, garantindo que os alunos recebam conteúdo estruturado e compreensível que se baseia em seu conhecimento existente.\n\nAlém de suas conquistas técnicas, o Tutor Pessoal de IA serve como um exemplo abrangente de orquestração de agentes pronta para produção, completa com rastreamento de progresso em tempo real, integração de armazenamento em nuvem e uma interface web moderna que torna interações complexas de IA acessíveis a usuários não técnicos.",
  "tags": ["Python", "FastAPI", "MCP", "Agentes de IA", "Educação", "Grafos de Conhecimento"],
  "featured": false,
  "icon": "GraduationCap",
  "isPrivate": true,
  "githubUrl": "https://github.com/brandonjredmond/ai-tutor",
  "demoUrl": "http://localhost:8000",
  "techStack": [
    {
      "category": "Backend",
      "items": ["Python 3.13", "FastAPI", "Gerenciador de Pacotes UV", "Pydantic", "AsyncIO"]
    },
    {
      "category": "Sistema de IA/Agentes",
      "items": ["Model Context Protocol", "Orquestração Multi-Agente", "Motor de Fluxo de Trabalho", "WebSocket", "JSON-RPC"]
    },
    {
      "category": "Dados e Visualização",
      "items": ["Cytoscape.js", "Grafos de Conhecimento", "Geração de Markdown", "API do Google Drive", "Atualizações em Tempo Real"]
    },
    {
      "category": "Infraestrutura",
      "items": ["Docker", "Cache Redis", "PostgreSQL", "Monitoramento de Produção", "Documentação de API"]
    }
  ],
  "features": [
    "Agregação de pesquisa multi-fonte de conteúdo web, YouTube e acadêmico",
    "Geração automática de grafo de conhecimento com visualizações interativas",
    "Resumos adaptativos ao nível de experiência, personalizados para as necessidades do aluno",
    "Rastreamento de progresso em tempo real via conexões WebSocket",
    "Execução paralela de agentes para desempenho ótimo",
    "Integração com Google Drive para backup e compartilhamento automático",
    "Filtragem de qualidade e classificação de credibilidade de fontes",
    "Arquitetura extensível para adicionar novos agentes especializados"
  ],
  "challenges": [
    "Coordenar múltiplos agentes assíncronos com dependências complexas",
    "Construir comunicação MCP confiável através de serviços distribuídos",
    "Criar grafos de conhecimento que representam com precisão relacionamentos de conceitos",
    "Garantir qualidade de conteúdo mantendo tempos de resposta rápidos",
    "Projetar uma interface intuitiva para interações complexas de IA"
  ],
  "outcomes": [
    { "metric": "Tempo de Resposta", "value": "3-5 min média" },
    { "metric": "Qualidade das Fontes", "value": "85% relevância" },
    { "metric": "Eficiência de Agentes", "value": "5 agentes paralelos" },
    { "metric": "Cobertura de Conhecimento", "value": "15+ fontes/tópico" },
    { "metric": "Satisfação do Usuário", "value": "Profundidade educacional" }
  ],
  "educational": [
    "Demonstra implementação prática de MCP para coordenação de agentes",
    "Ensina padrões de orquestração de fluxo de trabalho para tarefas complexas",
    "Mostra como construir sistemas de geração de conteúdo adaptativo",
    "Ilustra padrões de comunicação em tempo real com WebSocket",
    "Fornece exemplos de extração estruturada de dados de múltiplas fontes",
    "Explica construção de grafo de conhecimento a partir de conteúdo não estruturado"
  ],
  "globalImpact": {
    "geographicReach": ["Estados Unidos", "Europa", "Ásia", "América Latina"],
    "usersWorldwide": 200,
    "socialImpact": "Democratiza o acesso à educação personalizada criando experiências de aprendizado com IA que se adaptam às necessidades e velocidades de aprendizado individuais",
    "environmentalImpact": "Orquestração eficiente de agentes reduz chamadas redundantes de API e sobrecarga computacional através de cache inteligente e processamento paralelo",
    "accessibilityFeatures": ["Níveis de dificuldade adaptativos", "Saída estruturada em markdown", "Grafos de conhecimento visuais", "Caminhos de aprendizado progressivos"],
    "multilingualSupport": false,
    "economicImpact": "Reduz o custo de tutoria personalizada automatizando pesquisa e geração de conteúdo, tornando educação de qualidade mais acessível",
    "knowledgeSharing": "Implementação open-source com documentação abrangente permitindo que educadores e desenvolvedores construam sistemas similares"
  },
  "localization": {
    "supportedLanguages": ["Inglês"],
    "culturalAdaptations": ["Exemplos adaptados ao contexto do aluno", "Geração de conteúdo culturalmente neutro"],
    "timeZoneHandling": false,
    "currencySupport": [],
    "regionalCompliance": ["Padrões de conteúdo educacional", "Conformidade com privacidade de dados"]
  },
  "codeSnippets": [
    {
      "title": "Orquestrador de Agentes com Integração MCP",
      "language": "python",
      "code": "from src.models.data_models import Workflow, WorkflowStep, TopicData\nfrom src.services.mcp_client import MCPClient\nimport asyncio\nfrom typing import Dict, List, Any\n\nclass Orchestrator:\n    \"\"\"Orquestra fluxos de trabalho multi-agente para tarefas de pesquisa\"\"\"\n    \n    def __init__(self, mcp_client: MCPClient):\n        self.mcp_client = mcp_client\n        self.available_agents = {\n            \"web_search_agent\": \"research\",\n            \"youtube_agent\": \"research\",\n            \"knowledge_graph_agent\": \"analysis\",\n            \"summary_agent\": \"synthesis\",\n            \"drive_agent\": \"storage\"\n        }\n        self.active_workflows = {}\n        \n    async def execute_research_workflow(\n        self, \n        topic: TopicData,\n        progress_callback=None\n    ) -> Dict[str, Any]:\n        \"\"\"Executar fluxo de trabalho completo de pesquisa com coordenação paralela de agentes\"\"\"\n        \n        workflow_id = str(uuid.uuid4())\n        results = {}\n        \n        try:\n            # Fase 1: Coleta paralela de pesquisa\n            research_tasks = [\n                self._execute_agent_task(\n                    agent=\"web_search_agent\",\n                    capability=\"search_topic\",\n                    args={\"topic\": topic, \"max_results\": 10}\n                ),\n                self._execute_agent_task(\n                    agent=\"youtube_agent\",\n                    capability=\"search_videos\",\n                    args={\"topic\": topic, \"max_results\": 5}\n                )\n            ]\n            \n            if progress_callback:\n                await progress_callback({\n                    \"step\": \"research_gathering\",\n                    \"progress\": 20,\n                    \"message\": \"Coletando fontes da web e conteúdo de vídeo\"\n                })\n            \n            # Executar pesquisa paralela\n            research_results = await asyncio.gather(*research_tasks)\n            results[\"web_sources\"] = research_results[0]\n            results[\"video_sources\"] = research_results[1]\n            \n            # Fase 2: Extração de conteúdo\n            all_content = []\n            for source in results[\"web_sources\"]:\n                content = await self._execute_agent_task(\n                    agent=\"web_search_agent\",\n                    capability=\"extract_content\",\n                    args={\"url\": source[\"url\"]}\n                )\n                all_content.append(content)\n            \n            if progress_callback:\n                await progress_callback({\n                    \"step\": \"content_extraction\",\n                    \"progress\": 40,\n                    \"message\": \"Extraindo e analisando conteúdo\"\n                })\n            \n            # Fase 3: Construção do grafo de conhecimento\n            graph_data = await self._execute_agent_task(\n                agent=\"knowledge_graph_agent\",\n                capability=\"build_graph\",\n                args={\n                    \"content\": all_content,\n                    \"topic\": topic,\n                    \"max_nodes\": 50\n                }\n            )\n            results[\"knowledge_graph\"] = graph_data\n            \n            if progress_callback:\n                await progress_callback({\n                    \"step\": \"knowledge_graph\",\n                    \"progress\": 60,\n                    \"message\": \"Construindo relacionamentos de conceitos\"\n                })\n            \n            # Fase 4: Geração de resumo\n            summary = await self._execute_agent_task(\n                agent=\"summary_agent\",\n                capability=\"generate_summary\",\n                args={\n                    \"topic\": topic,\n                    \"sources\": all_content,\n                    \"graph\": graph_data,\n                    \"difficulty\": topic.difficulty\n                }\n            )\n            results[\"summary\"] = summary\n            \n            if progress_callback:\n                await progress_callback({\n                    \"step\": \"summary_generation\",\n                    \"progress\": 80,\n                    \"message\": \"Criando resumo personalizado\"\n                })\n            \n            # Fase 5: Armazenamento em nuvem\n            drive_url = await self._execute_agent_task(\n                agent=\"drive_agent\",\n                capability=\"upload_content\",\n                args={\n                    \"content\": summary,\n                    \"filename\": f\"{topic.name}_resumo.md\",\n                    \"folder\": \"AI_Tutor_Research\"\n                }\n            )\n            results[\"drive_url\"] = drive_url\n            \n            if progress_callback:\n                await progress_callback({\n                    \"step\": \"completed\",\n                    \"progress\": 100,\n                    \"message\": \"Pesquisa concluída com sucesso\"\n                })\n            \n            return results\n            \n        except Exception as e:\n            if progress_callback:\n                await progress_callback({\n                    \"step\": \"error\",\n                    \"progress\": results.get(\"progress\", 0),\n                    \"message\": f\"Erro: {str(e)}\"\n                })\n            raise\n    \n    async def _execute_agent_task(\n        self,\n        agent: str,\n        capability: str,\n        args: Dict[str, Any]\n    ) -> Any:\n        \"\"\"Executar uma única capacidade de agente via MCP\"\"\"\n        return await self.mcp_client.call_agent_capability(\n            agent_name=agent,\n            capability_name=capability,\n            arguments=args\n        )"
    },
    {
      "title": "Construtor de Grafo de Conhecimento com Integração Cytoscape",
      "language": "python",
      "code": "from typing import List, Dict, Any\nimport networkx as nx\nfrom collections import defaultdict\nimport re\n\nclass KnowledgeGraphBuilder:\n    \"\"\"Constrói grafos de conhecimento interativos a partir de conteúdo de pesquisa\"\"\"\n    \n    def __init__(self):\n        self.graph = nx.DiGraph()\n        self.concept_importance = defaultdict(float)\n        self.edge_types = {\n            \"prerequisite\": {\"color\": \"#ff6b6b\", \"weight\": 3},\n            \"related_to\": {\"color\": \"#4dabf7\", \"weight\": 2},\n            \"example_of\": {\"color\": \"#51cf66\", \"weight\": 1},\n            \"leads_to\": {\"color\": \"#ffd43b\", \"weight\": 2}\n        }\n    \n    def build_from_content(\n        self,\n        content_sources: List[Dict[str, Any]],\n        topic: str,\n        max_nodes: int = 50\n    ) -> Dict[str, Any]:\n        \"\"\"Construir grafo de conhecimento a partir de múltiplas fontes de conteúdo\"\"\"\n        \n        # Extrair conceitos de todas as fontes\n        all_concepts = self._extract_concepts(content_sources)\n        \n        # Calcular importância do conceito baseado em frequência e contexto\n        for concept in all_concepts:\n            self.concept_importance[concept[\"name\"]] += concept[\"score\"]\n        \n        # Selecionar principais conceitos\n        top_concepts = sorted(\n            self.concept_importance.items(),\n            key=lambda x: x[1],\n            reverse=True\n        )[:max_nodes]\n        \n        # Adicionar nós ao grafo\n        for concept_name, importance in top_concepts:\n            self.graph.add_node(\n                concept_name,\n                label=concept_name,\n                importance=importance,\n                type=\"concept\"\n            )\n        \n        # Extrair e adicionar relacionamentos\n        relationships = self._extract_relationships(\n            content_sources,\n            [c[0] for c in top_concepts]\n        )\n        \n        for rel in relationships:\n            if rel[\"source\"] in self.graph and rel[\"target\"] in self.graph:\n                self.graph.add_edge(\n                    rel[\"source\"],\n                    rel[\"target\"],\n                    type=rel[\"type\"],\n                    strength=rel[\"strength\"]\n                )\n        \n        # Adicionar nó do tópico central\n        self.graph.add_node(\n            topic,\n            label=topic,\n            importance=1.0,\n            type=\"central_topic\"\n        )\n        \n        # Conectar principais conceitos ao tópico central\n        for concept_name, _ in top_concepts[:5]:\n            self.graph.add_edge(\n                topic,\n                concept_name,\n                type=\"related_to\",\n                strength=0.9\n            )\n        \n        # Converter para formato Cytoscape\n        return self._to_cytoscape_format()\n    \n    def _extract_concepts(self, content_sources: List[Dict]) -> List[Dict]:\n        \"\"\"Extrair conceitos-chave usando técnicas de PLN\"\"\"\n        concepts = []\n        \n        # Extração simples de conceitos (em produção, usar modelos de PLN)\n        concept_patterns = [\n            r'\\b([A-Z][a-z]+ [A-Z][a-z]+)\\b',  # Frases em title case\n            r'\\b(\\w+ learning)\\b',  # Padrões específicos do domínio\n            r'\\b(\\w+ algorithm)\\b',\n            r'\\b(\\w+ network)\\b'\n        ]\n        \n        for source in content_sources:\n            text = source.get(\"content\", \"\")\n            \n            for pattern in concept_patterns:\n                matches = re.findall(pattern, text, re.IGNORECASE)\n                for match in matches:\n                    concepts.append({\n                        \"name\": match,\n                        \"score\": 1.0,\n                        \"source\": source.get(\"url\", \"\")\n                    })\n        \n        return concepts\n    \n    def _extract_relationships(\n        self,\n        content_sources: List[Dict],\n        concepts: List[str]\n    ) -> List[Dict]:\n        \"\"\"Extrair relacionamentos entre conceitos\"\"\"\n        relationships = []\n        \n        # Padrões de relacionamento\n        patterns = [\n            (r'{} é um pré-requisito para {}', 'prerequisite'),\n            (r'{} está relacionado a {}', 'related_to'),\n            (r'{} leva a {}', 'leads_to'),\n            (r'{} é um exemplo de {}', 'example_of')\n        ]\n        \n        for source in content_sources:\n            text = source.get(\"content\", \"\").lower()\n            \n            for concept1 in concepts:\n                for concept2 in concepts:\n                    if concept1 != concept2:\n                        # Verificar padrões de relacionamento\n                        for pattern, rel_type in patterns:\n                            search_pattern = pattern.format(\n                                concept1.lower(),\n                                concept2.lower()\n                            )\n                            if search_pattern in text:\n                                relationships.append({\n                                    \"source\": concept1,\n                                    \"target\": concept2,\n                                    \"type\": rel_type,\n                                    \"strength\": 0.8\n                                })\n        \n        return relationships\n    \n    def _to_cytoscape_format(self) -> Dict[str, Any]:\n        \"\"\"Converter grafo NetworkX para formato Cytoscape.js\"\"\"\n        elements = {\n            \"nodes\": [],\n            \"edges\": []\n        }\n        \n        # Adicionar nós\n        for node_id, node_data in self.graph.nodes(data=True):\n            elements[\"nodes\"].append({\n                \"data\": {\n                    \"id\": node_id,\n                    \"label\": node_data.get(\"label\", node_id),\n                    \"importance\": node_data.get(\"importance\", 0.5),\n                    \"type\": node_data.get(\"type\", \"concept\")\n                }\n            })\n        \n        # Adicionar arestas\n        for source, target, edge_data in self.graph.edges(data=True):\n            edge_type = edge_data.get(\"type\", \"related_to\")\n            elements[\"edges\"].append({\n                \"data\": {\n                    \"id\": f\"{source}-{target}\",\n                    \"source\": source,\n                    \"target\": target,\n                    \"type\": edge_type,\n                    \"strength\": edge_data.get(\"strength\", 0.5),\n                    \"color\": self.edge_types[edge_type][\"color\"],\n                    \"weight\": self.edge_types[edge_type][\"weight\"]\n                }\n            })\n        \n        return {\n            \"elements\": elements,\n            \"style\": self._get_cytoscape_style(),\n            \"layout\": {\"name\": \"cose\", \"animate\": True}\n        }\n    \n    def _get_cytoscape_style(self) -> List[Dict]:\n        \"\"\"Retornar configuração de estilo do Cytoscape\"\"\"\n        return [\n            {\n                \"selector\": \"node\",\n                \"style\": {\n                    \"label\": \"data(label)\",\n                    \"background-color\": \"#666\",\n                    \"width\": \"mapData(importance, 0, 1, 30, 80)\",\n                    \"height\": \"mapData(importance, 0, 1, 30, 80)\"\n                }\n            },\n            {\n                \"selector\": \"node[type='central_topic']\",\n                \"style\": {\n                    \"background-color\": \"#ff6b6b\",\n                    \"width\": 100,\n                    \"height\": 100\n                }\n            },\n            {\n                \"selector\": \"edge\",\n                \"style\": {\n                    \"width\": \"data(weight)\",\n                    \"line-color\": \"data(color)\",\n                    \"target-arrow-color\": \"data(color)\",\n                    \"target-arrow-shape\": \"triangle\",\n                    \"curve-style\": \"bezier\"\n                }\n            }\n        ]"
    }
  ]
}