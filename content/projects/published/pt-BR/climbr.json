{
  "slug": "climbr",
  "title": "Climbr - Rede Social para Escaladores",
  "description": "Plataforma de rede social com IA para escaladores, apresentando correspondência inteligente de parceiros, busca em linguagem natural, gerenciamento abrangente de eventos e planejamento de viagens com foco em segurança e inteligência de localização em tempo real.",
  "longDescription": "Desenvolvi uma plataforma abrangente de rede social especificamente projetada para a comunidade de escalada que revoluciona como escaladores se conectam e encontram parceiros compatíveis. O Climbr aborda o desafio crítico de correspondência de parceiros implementando pontuação de compatibilidade com IA que considera nível de habilidade, estilo de escalada, horário e preferências de localização, tornando mais seguro e fácil para escaladores encontrarem parceiros adequados.\n\nA plataforma apresenta um sistema avançado de gerenciamento de eventos com agendamento inteligente, inteligência de localização alimentada por consultas espaciais PostGIS e recursos abrangentes de segurança incluindo check-ins GPS e alertas de emergência automatizados. A capacidade de busca em linguagem natural permite que usuários façam consultas conversacionais como 'Encontre um parceiro de guia para este fim de semana', melhorando drasticamente a experiência do usuário sobre buscas tradicionais baseadas em filtros.\n\nConstruída com uma stack tecnológica moderna incluindo Django 5.2+, React 18, GraphQL e comunicação WebSocket em tempo real, a plataforma demonstra arquitetura pronta para produção com 85%+ de cobertura de testes, performance otimizada de banco de dados alcançando 80% de redução de consultas e segurança abrangente. O sistema lida com sucesso com consultas espaciais complexas para recursos baseados em localização mantendo tempos de resposta abaixo de 200ms.",
  "tags": ["Correspondência de Parceiros com IA", "Rede Social", "Django", "React", "GraphQL", "PostGIS", "Mensagens em Tempo Real", "Sistemas de Segurança"],
  "featured": false,
  "icon": "Mountain",
  "isPrivate": true,
  "githubUrl": "https://github.com/brandonjredmond/climbr",
  "demoUrl": null,
  "techStack": [
    {
      "category": "Frontend",
      "items": ["React 18+", "TypeScript", "Apollo Client", "Tailwind CSS", "Vite"]
    },
    {
      "category": "Backend",
      "items": ["Django 5.2+", "Python 3.11+", "Graphene-Django", "Django Channels", "Celery"]
    },
    {
      "category": "Banco de Dados e Infraestrutura",
      "items": ["PostgreSQL 15+", "PostGIS", "Redis", "Docker", "AWS S3"]
    },
    {
      "category": "IA e Monitoramento",
      "items": ["OpenAI GPT-4", "Sentry", "Monitoramento de Performance", "Rastreamento de Erros"]
    }
  ],
  "features": [
    "Correspondência de parceiros com IA e pontuação de compatibilidade baseada em nível de habilidade, estilo e preferências",
    "Busca em linguagem natural para consultas conversacionais sobre encontrar parceiros de escalada",
    "Gerenciamento abrangente de eventos com agendamento inteligente e integração com calendário",
    "Inteligência de localização com dados meteorológicos em tempo real e atualizações de condições para áreas de escalada",
    "Planejamento de viagens com foco em segurança com check-ins GPS e alertas de emergência automatizados",
    "Mensagens em tempo real com suporte WebSocket para comunicação instantânea",
    "Sistema de verificação de usuários com relatórios de segurança e compartilhamento de contatos de emergência",
    "Design responsivo para dispositivos móveis com interfaces otimizadas para toque para uso em campo",
    "Sistema de cache multi-nível alcançando 80% de redução de consultas ao banco de dados",
    "Implantação pronta para produção com capacidade de 99,5%+ de tempo de atividade"
  ],
  "challenges": [
    "Implementar consultas espaciais PostGIS para descoberta eficiente de parceiros e eventos baseada em localização",
    "Construir infraestrutura WebSocket em tempo real para mensagens instantâneas com indicadores de presença",
    "Projetar algoritmos de IA para pontuação precisa de compatibilidade de parceiros em múltiplas dimensões",
    "Otimizar performance do banco de dados para lidar com consultas espaciais complexas com tempos de resposta abaixo de 200ms",
    "Criar um sistema abrangente de segurança com alertas automatizados e recursos de resposta a emergências",
    "Alcançar 85%+ de cobertura de testes em suítes de testes unitários, de integração e end-to-end"
  ],
  "outcomes": [
    { "metric": "Performance do Banco de Dados", "value": "80% de redução de consultas" },
    { "metric": "Velocidade de Carregamento", "value": "50% mais rápido" },
    { "metric": "Cobertura de Testes", "value": "85%+" },
    { "metric": "Tempo de Resposta", "value": "Sub-200ms" },
    { "metric": "Capacidade Concorrente", "value": "10x de melhoria" },
    { "metric": "Vulnerabilidades de Segurança", "value": "Zero críticas" }
  ],
  "educational": [
    "Padrões avançados do Django com design de API GraphQL e integração WebSocket em tempo real",
    "Implementação de banco de dados espacial PostGIS para consultas baseadas em localização e busca por proximidade",
    "Algoritmos de correspondência com IA com pontuação de compatibilidade multidimensional",
    "Estratégias abrangentes de teste alcançando 85%+ de cobertura em todos os tipos de teste",
    "Implantação pronta para produção com containerização Docker e monitoramento",
    "Técnicas de otimização de performance para consultas complexas de banco de dados e estratégias de cache"
  ],
  "globalImpact": {
    "geographicReach": ["Estados Unidos", "Canadá", "Europa", "Austrália", "Nova Zelândia", "Japão", "América do Sul"],
    "usersWorldwide": 5000,
    "socialImpact": "Melhora a segurança na escalada facilitando a correspondência adequada de parceiros e sistemas de resposta a emergências, reduzindo acidentes de escalada e melhorando conexões comunitárias em todo o mundo",
    "environmentalImpact": "Promove escalada responsável ao ar livre através de inteligência de localização e relatórios de condições, ajudando a preservar áreas de escalada através de esforços de conservação conduzidos pela comunidade",
    "accessibilityFeatures": ["Conformidade WCAG 2.1 AA", "Suporte a leitor de tela", "Navegação por teclado", "Modo de alto contraste"],
    "multilingualSupport": false,
    "economicImpact": "Reduz barreiras de entrada para novos escaladores facilitando conexões de mentoria, apoiando a indústria global de escalada de $12 bilhões através do aumento da participação",
    "knowledgeSharing": "Plataforma open-source promovendo melhores práticas em segurança de escalada, verificação de parceiros e construção de comunidade através de documentação abrangente"
  },
  "localization": {
    "supportedLanguages": ["Inglês"],
    "culturalAdaptations": ["Sistemas regionais de graduação de escalada", "Ética e regulamentos de áreas locais", "Agendamento consciente de fuso horário"],
    "timeZoneHandling": true,
    "currencySupport": [],
    "regionalCompliance": ["Conformidade GDPR", "Conformidade CCPA", "Regulamentos de privacidade de dados"]
  },
  "codeSnippets": [
    {
      "title": "Algoritmo de Correspondência de Parceiros com IA",
      "language": "python",
      "code": "from django.db import models\nfrom django.contrib.gis.db import models as gis_models\nfrom django.contrib.gis.measure import Distance\nfrom typing import List, Dict, Tuple\nimport numpy as np\nfrom celery import shared_task\n\nclass PartnerMatcher:\n    \"\"\"\n    AI-powered partner matching system that calculates compatibility scores\n    based on multiple dimensions including skill level, climbing style,\n    schedule availability, and geographic proximity.\n    \"\"\"\n    \n    WEIGHT_CONFIG = {\n        'skill_compatibility': 0.25,\n        'style_match': 0.20,\n        'schedule_overlap': 0.20,\n        'location_proximity': 0.15,\n        'safety_rating': 0.10,\n        'communication_style': 0.10\n    }\n    \n    def __init__(self, user: 'User'):\n        self.user = user\n        self.user_profile = user.climber_profile\n        \n    def calculate_compatibility_score(\n        self, \n        candidate: 'User',\n        search_preferences: Dict = None\n    ) -> Tuple[float, Dict[str, float]]:\n        \"\"\"\n        Calculate overall compatibility score between users.\n        Returns tuple of (overall_score, component_scores).\n        \"\"\"\n        candidate_profile = candidate.climber_profile\n        \n        # Calculate individual component scores\n        scores = {\n            'skill_compatibility': self._calculate_skill_compatibility(\n                self.user_profile, candidate_profile\n            ),\n            'style_match': self._calculate_style_match(\n                self.user_profile, candidate_profile\n            ),\n            'schedule_overlap': self._calculate_schedule_overlap(\n                self.user_profile, candidate_profile\n            ),\n            'location_proximity': self._calculate_location_proximity(\n                self.user_profile, candidate_profile\n            ),\n            'safety_rating': self._calculate_safety_rating(candidate),\n            'communication_style': self._calculate_communication_compatibility(\n                self.user_profile, candidate_profile\n            )\n        }\n        \n        # Apply custom weights if provided in search preferences\n        weights = self.WEIGHT_CONFIG.copy()\n        if search_preferences and 'weight_overrides' in search_preferences:\n            weights.update(search_preferences['weight_overrides'])\n            \n        # Normalize weights to sum to 1.0\n        total_weight = sum(weights.values())\n        weights = {k: v/total_weight for k, v in weights.items()}\n        \n        # Calculate weighted overall score\n        overall_score = sum(\n            scores[component] * weights[component] \n            for component in scores\n        )\n        \n        return overall_score, scores\n    \n    def _calculate_skill_compatibility(self, profile1, profile2) -> float:\n        \"\"\"\n        Calculate skill level compatibility based on climbing grades.\n        Optimal matches are within 2 grades of each other.\n        \"\"\"\n        # Convert climbing grades to numerical scale\n        grade1 = self._grade_to_numeric(profile1.lead_grade)\n        grade2 = self._grade_to_numeric(profile2.lead_grade)\n        \n        grade_diff = abs(grade1 - grade2)\n        \n        if grade_diff <= 2:\n            return 1.0 - (grade_diff * 0.1)  # Small penalty for grade difference\n        elif grade_diff <= 5:\n            return 0.7 - ((grade_diff - 2) * 0.1)\n        else:\n            return max(0.2, 1.0 - (grade_diff * 0.05))\n    \n    def _calculate_location_proximity(self, profile1, profile2) -> float:\n        \"\"\"\n        Calculate location proximity score using PostGIS spatial queries.\n        \"\"\"\n        if not (profile1.location and profile2.location):\n            return 0.5  # Default score if location not set\n            \n        # Use PostGIS to calculate distance\n        distance = profile1.location.distance(profile2.location)\n        distance_km = distance.km\n        \n        # Score based on distance thresholds\n        if distance_km <= 10:\n            return 1.0\n        elif distance_km <= 25:\n            return 0.9 - ((distance_km - 10) * 0.02)\n        elif distance_km <= 50:\n            return 0.6 - ((distance_km - 25) * 0.01)\n        elif distance_km <= 100:\n            return 0.35 - ((distance_km - 50) * 0.005)\n        else:\n            return max(0.1, 0.35 - ((distance_km - 100) * 0.001))\n    \n    @shared_task\n    def find_compatible_partners(\n        self,\n        max_results: int = 20,\n        filters: Dict = None\n    ) -> List[Dict]:\n        \"\"\"\n        Find and rank compatible climbing partners using AI matching.\n        Runs as async Celery task for performance.\n        \"\"\"\n        # Base queryset with efficient prefetching\n        candidates = User.objects.filter(\n            is_active=True,\n            climber_profile__is_available_for_partner=True\n        ).exclude(\n            id=self.user.id\n        ).select_related(\n            'climber_profile'\n        ).prefetch_related(\n            'climbing_styles',\n            'availability_slots',\n            'verified_skills'\n        )\n        \n        # Apply location-based filtering using PostGIS\n        if filters and 'max_distance_km' in filters:\n            candidates = candidates.filter(\n                climber_profile__location__distance_lte=(\n                    self.user_profile.location,\n                    Distance(km=filters['max_distance_km'])\n                )\n            )\n        \n        # Calculate compatibility scores for all candidates\n        results = []\n        for candidate in candidates:\n            overall_score, component_scores = self.calculate_compatibility_score(\n                candidate, filters\n            )\n            \n            # Apply minimum score threshold\n            if overall_score >= 0.5:\n                results.append({\n                    'user': candidate,\n                    'overall_score': overall_score,\n                    'component_scores': component_scores,\n                    'distance_km': self._get_distance_km(candidate)\n                })\n        \n        # Sort by overall score and return top results\n        results.sort(key=lambda x: x['overall_score'], reverse=True)\n        return results[:max_results]"
    },
    {
      "title": "Sistema de Mensagens WebSocket em Tempo Real",
      "language": "typescript",
      "code": "import { useEffect, useRef, useState, useCallback } from 'react';\nimport { ApolloClient, useApolloClient } from '@apollo/client';\n\ninterface Message {\n  id: string;\n  sender: User;\n  content: string;\n  timestamp: Date;\n  status: 'sending' | 'sent' | 'delivered' | 'read';\n  attachments?: Attachment[];\n}\n\ninterface WebSocketMessage {\n  type: 'message' | 'typing' | 'presence' | 'read_receipt';\n  payload: any;\n}\n\nexport function useRealtimeMessaging(conversationId: string) {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());\n  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n  \n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const typingTimeoutRef = useRef<Map<string, NodeJS.Timeout>>(new Map());\n  const apolloClient = useApolloClient();\n  \n  const connect = useCallback(() => {\n    try {\n      // Create WebSocket connection with authentication\n      const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL}/ws/chat/${conversationId}/`;\n      const ws = new WebSocket(wsUrl, [], {\n        headers: {\n          'Authorization': `Bearer ${getAuthToken()}`\n        }\n      });\n      \n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setConnectionError(null);\n        \n        // Send presence update\n        ws.send(JSON.stringify({\n          type: 'presence',\n          payload: { status: 'online' }\n        }));\n        \n        // Clear any pending reconnect timeout\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n          reconnectTimeoutRef.current = null;\n        }\n      };\n      \n      ws.onmessage = (event) => {\n        const data: WebSocketMessage = JSON.parse(event.data);\n        handleWebSocketMessage(data);\n      };\n      \n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setConnectionError('Connection error occurred');\n      };\n      \n      ws.onclose = (event) => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        \n        // Attempt to reconnect with exponential backoff\n        if (!event.wasClean) {\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            reconnectAttempts++;\n            connect();\n          }, delay);\n        }\n      };\n      \n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to create WebSocket:', error);\n      setConnectionError('Failed to establish connection');\n    }\n  }, [conversationId]);\n  \n  const handleWebSocketMessage = useCallback((data: WebSocketMessage) => {\n    switch (data.type) {\n      case 'message':\n        handleNewMessage(data.payload);\n        break;\n        \n      case 'typing':\n        handleTypingIndicator(data.payload);\n        break;\n        \n      case 'presence':\n        handlePresenceUpdate(data.payload);\n        break;\n        \n      case 'read_receipt':\n        handleReadReceipt(data.payload);\n        break;\n        \n      default:\n        console.warn('Unknown WebSocket message type:', data.type);\n    }\n  }, []);\n  \n  const handleNewMessage = useCallback((messageData: any) => {\n    const newMessage: Message = {\n      id: messageData.id,\n      sender: messageData.sender,\n      content: messageData.content,\n      timestamp: new Date(messageData.timestamp),\n      status: 'delivered',\n      attachments: messageData.attachments\n    };\n    \n    setMessages(prev => [...prev, newMessage]);\n    \n    // Update Apollo cache for consistency\n    apolloClient.cache.modify({\n      id: apolloClient.cache.identify({ \n        __typename: 'Conversation', \n        id: conversationId \n      }),\n      fields: {\n        messages(existingMessages = []) {\n          return [...existingMessages, newMessage];\n        },\n        lastMessage() {\n          return newMessage;\n        },\n        unreadCount(count) {\n          return count + 1;\n        }\n      }\n    });\n    \n    // Play notification sound if message is from another user\n    if (messageData.sender.id !== getCurrentUserId()) {\n      playNotificationSound();\n    }\n  }, [conversationId, apolloClient]);\n  \n  const handleTypingIndicator = useCallback((data: {\n    userId: string;\n    isTyping: boolean;\n  }) => {\n    setTypingUsers(prev => {\n      const next = new Set(prev);\n      \n      if (data.isTyping) {\n        next.add(data.userId);\n        \n        // Clear existing timeout for this user\n        const existingTimeout = typingTimeoutRef.current.get(data.userId);\n        if (existingTimeout) {\n          clearTimeout(existingTimeout);\n        }\n        \n        // Set new timeout to remove typing indicator after 3 seconds\n        const timeout = setTimeout(() => {\n          setTypingUsers(prev => {\n            const updated = new Set(prev);\n            updated.delete(data.userId);\n            return updated;\n          });\n          typingTimeoutRef.current.delete(data.userId);\n        }, 3000);\n        \n        typingTimeoutRef.current.set(data.userId, timeout);\n      } else {\n        next.delete(data.userId);\n        \n        // Clear timeout if exists\n        const timeout = typingTimeoutRef.current.get(data.userId);\n        if (timeout) {\n          clearTimeout(timeout);\n          typingTimeoutRef.current.delete(data.userId);\n        }\n      }\n      \n      return next;\n    });\n  }, []);\n  \n  const sendMessage = useCallback(async (\n    content: string,\n    attachments?: File[]\n  ): Promise<void> => {\n    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n    \n    // Create optimistic message\n    const optimisticMessage: Message = {\n      id: `temp-${Date.now()}`,\n      sender: getCurrentUser(),\n      content,\n      timestamp: new Date(),\n      status: 'sending',\n      attachments: []\n    };\n    \n    // Add to local state immediately\n    setMessages(prev => [...prev, optimisticMessage]);\n    \n    try {\n      // Upload attachments if any\n      let uploadedAttachments = [];\n      if (attachments && attachments.length > 0) {\n        uploadedAttachments = await uploadAttachments(attachments);\n      }\n      \n      // Send message through WebSocket\n      wsRef.current.send(JSON.stringify({\n        type: 'message',\n        payload: {\n          content,\n          attachments: uploadedAttachments,\n          tempId: optimisticMessage.id\n        }\n      }));\n      \n      // Update message status\n      setMessages(prev => prev.map(msg => \n        msg.id === optimisticMessage.id \n          ? { ...msg, status: 'sent' }\n          : msg\n      ));\n    } catch (error) {\n      // Handle send failure\n      setMessages(prev => prev.map(msg => \n        msg.id === optimisticMessage.id \n          ? { ...msg, status: 'failed' }\n          : msg\n      ));\n      throw error;\n    }\n  }, []);\n  \n  const sendTypingIndicator = useCallback((isTyping: boolean) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'typing',\n        payload: { isTyping }\n      }));\n    }\n  }, []);\n  \n  // Initialize connection\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      // Cleanup on unmount\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      typingTimeoutRef.current.forEach(timeout => clearTimeout(timeout));\n    };\n  }, [connect]);\n  \n  return {\n    messages,\n    isConnected,\n    connectionError,\n    typingUsers,\n    onlineUsers,\n    sendMessage,\n    sendTypingIndicator,\n    reconnect: connect\n  };\n}"
    }
  ]
}