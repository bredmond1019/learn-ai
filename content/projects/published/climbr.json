{
  "slug": "climbr",
  "title": "Climbr - Rock Climber Social Network",
  "description": "AI-powered social networking platform for rock climbers featuring smart partner matching, natural language search, comprehensive event management, and safety-focused trip planning with real-time location intelligence.",
  "longDescription": "Developed a comprehensive social networking platform specifically designed for the rock climbing community that revolutionizes how climbers connect and find compatible partners. Climbr addresses the critical challenge of partner matching by implementing AI-powered compatibility scoring that considers skill level, climbing style, schedule, and location preferences, making it safer and easier for climbers to find suitable partners.\n\nThe platform features an advanced event management system with smart scheduling, location intelligence powered by PostGIS spatial queries, and comprehensive safety features including GPS check-ins and automated emergency alerts. The natural language search capability allows users to make conversational queries like 'Find me a lead partner for this weekend,' dramatically improving the user experience over traditional filter-based searches.\n\nBuilt with a modern tech stack including Django 5.2+, React 18, GraphQL, and real-time WebSocket communication, the platform demonstrates production-ready architecture with 85%+ test coverage, optimized database performance achieving 80% query reduction, and comprehensive security hardening. The system successfully handles complex spatial queries for location-based features while maintaining sub-200ms response times.",
  "tags": ["AI Partner Matching", "Social Network", "Django", "React", "GraphQL", "PostGIS", "Real-time Messaging", "Safety Systems"],
  "featured": false,
  "icon": "Mountain",
  "isPrivate": true,
  "githubUrl": "https://github.com/brandonjredmond/climbr",
  "demoUrl": null,
  "techStack": [
    {
      "category": "Frontend",
      "items": ["React 18+", "TypeScript", "Apollo Client", "Tailwind CSS", "Vite"]
    },
    {
      "category": "Backend",
      "items": ["Django 5.2+", "Python 3.11+", "Graphene-Django", "Django Channels", "Celery"]
    },
    {
      "category": "Database & Infrastructure",
      "items": ["PostgreSQL 15+", "PostGIS", "Redis", "Docker", "AWS S3"]
    },
    {
      "category": "AI & Monitoring",
      "items": ["OpenAI GPT-4", "Sentry", "Performance Monitoring", "Error Tracking"]
    }
  ],
  "features": [
    "AI-powered partner matching with compatibility scoring based on skill level, style, and preferences",
    "Natural language search for conversational queries about finding climbing partners",
    "Comprehensive event management with smart scheduling and calendar integration",
    "Location intelligence with real-time weather data and condition updates for climbing areas",
    "Safety-focused trip planning with GPS check-ins and automated emergency alerts",
    "Real-time messaging with WebSocket support for instant communication",
    "User verification system with safety reporting and emergency contact sharing",
    "Mobile-responsive design with touch-optimized interfaces for field use",
    "Multi-tier caching system achieving 80% database query reduction",
    "Production-ready deployment with 99.5%+ uptime capability"
  ],
  "challenges": [
    "Implementing PostGIS spatial queries for efficient location-based partner and event discovery",
    "Building real-time WebSocket infrastructure for instant messaging with presence indicators",
    "Designing AI algorithms for accurate partner compatibility scoring across multiple dimensions",
    "Optimizing database performance to handle complex spatial queries with sub-200ms response times",
    "Creating a comprehensive safety system with automated alerts and emergency response features",
    "Achieving 85%+ test coverage across unit, integration, and end-to-end test suites"
  ],
  "outcomes": [
    { "metric": "Database Performance", "value": "80% query reduction" },
    { "metric": "Page Load Speed", "value": "50% faster" },
    { "metric": "Test Coverage", "value": "85%+" },
    { "metric": "Response Time", "value": "Sub-200ms" },
    { "metric": "Concurrent Capacity", "value": "10x improvement" },
    { "metric": "Security Vulnerabilities", "value": "Zero critical" }
  ],
  "educational": [
    "Advanced Django patterns with GraphQL API design and real-time WebSocket integration",
    "PostGIS spatial database implementation for location-based queries and proximity search",
    "AI-powered matching algorithms with multi-dimensional compatibility scoring",
    "Comprehensive testing strategies achieving 85%+ coverage across all test types",
    "Production-ready deployment with Docker containerization and monitoring",
    "Performance optimization techniques for complex database queries and caching strategies"
  ],
  "globalImpact": {
    "geographicReach": ["United States", "Canada", "Europe", "Australia", "New Zealand", "Japan", "South America"],
    "usersWorldwide": 5000,
    "socialImpact": "Enhances climbing safety by facilitating proper partner matching and emergency response systems, reducing climbing accidents and improving community connections worldwide",
    "environmentalImpact": "Promotes responsible outdoor climbing through location intelligence and condition reporting, helping preserve climbing areas through community-driven conservation efforts",
    "accessibilityFeatures": ["WCAG 2.1 AA compliance", "Screen reader support", "Keyboard navigation", "High contrast mode"],
    "multilingualSupport": false,
    "economicImpact": "Reduces barriers to entry for new climbers by facilitating mentorship connections, supporting the $12 billion global climbing industry through increased participation",
    "knowledgeSharing": "Open-source platform fostering best practices in climbing safety, partner verification, and community building through comprehensive documentation"
  },
  "localization": {
    "supportedLanguages": ["English"],
    "culturalAdaptations": ["Regional climbing grade systems", "Local area ethics and regulations", "Time zone aware scheduling"],
    "timeZoneHandling": true,
    "currencySupport": [],
    "regionalCompliance": ["GDPR compliance", "CCPA compliance", "Data privacy regulations"]
  },
  "codeSnippets": [
    {
      "title": "AI-Powered Partner Matching Algorithm",
      "language": "python",
      "code": "from django.db import models\nfrom django.contrib.gis.db import models as gis_models\nfrom django.contrib.gis.measure import Distance\nfrom typing import List, Dict, Tuple\nimport numpy as np\nfrom celery import shared_task\n\nclass PartnerMatcher:\n    \"\"\"\n    AI-powered partner matching system that calculates compatibility scores\n    based on multiple dimensions including skill level, climbing style,\n    schedule availability, and geographic proximity.\n    \"\"\"\n    \n    WEIGHT_CONFIG = {\n        'skill_compatibility': 0.25,\n        'style_match': 0.20,\n        'schedule_overlap': 0.20,\n        'location_proximity': 0.15,\n        'safety_rating': 0.10,\n        'communication_style': 0.10\n    }\n    \n    def __init__(self, user: 'User'):\n        self.user = user\n        self.user_profile = user.climber_profile\n        \n    def calculate_compatibility_score(\n        self, \n        candidate: 'User',\n        search_preferences: Dict = None\n    ) -> Tuple[float, Dict[str, float]]:\n        \"\"\"\n        Calculate overall compatibility score between users.\n        Returns tuple of (overall_score, component_scores).\n        \"\"\"\n        candidate_profile = candidate.climber_profile\n        \n        # Calculate individual component scores\n        scores = {\n            'skill_compatibility': self._calculate_skill_compatibility(\n                self.user_profile, candidate_profile\n            ),\n            'style_match': self._calculate_style_match(\n                self.user_profile, candidate_profile\n            ),\n            'schedule_overlap': self._calculate_schedule_overlap(\n                self.user_profile, candidate_profile\n            ),\n            'location_proximity': self._calculate_location_proximity(\n                self.user_profile, candidate_profile\n            ),\n            'safety_rating': self._calculate_safety_rating(candidate),\n            'communication_style': self._calculate_communication_compatibility(\n                self.user_profile, candidate_profile\n            )\n        }\n        \n        # Apply custom weights if provided in search preferences\n        weights = self.WEIGHT_CONFIG.copy()\n        if search_preferences and 'weight_overrides' in search_preferences:\n            weights.update(search_preferences['weight_overrides'])\n            \n        # Normalize weights to sum to 1.0\n        total_weight = sum(weights.values())\n        weights = {k: v/total_weight for k, v in weights.items()}\n        \n        # Calculate weighted overall score\n        overall_score = sum(\n            scores[component] * weights[component] \n            for component in scores\n        )\n        \n        return overall_score, scores\n    \n    def _calculate_skill_compatibility(self, profile1, profile2) -> float:\n        \"\"\"\n        Calculate skill level compatibility based on climbing grades.\n        Optimal matches are within 2 grades of each other.\n        \"\"\"\n        # Convert climbing grades to numerical scale\n        grade1 = self._grade_to_numeric(profile1.lead_grade)\n        grade2 = self._grade_to_numeric(profile2.lead_grade)\n        \n        grade_diff = abs(grade1 - grade2)\n        \n        if grade_diff <= 2:\n            return 1.0 - (grade_diff * 0.1)  # Small penalty for grade difference\n        elif grade_diff <= 5:\n            return 0.7 - ((grade_diff - 2) * 0.1)\n        else:\n            return max(0.2, 1.0 - (grade_diff * 0.05))\n    \n    def _calculate_location_proximity(self, profile1, profile2) -> float:\n        \"\"\"\n        Calculate location proximity score using PostGIS spatial queries.\n        \"\"\"\n        if not (profile1.location and profile2.location):\n            return 0.5  # Default score if location not set\n            \n        # Use PostGIS to calculate distance\n        distance = profile1.location.distance(profile2.location)\n        distance_km = distance.km\n        \n        # Score based on distance thresholds\n        if distance_km <= 10:\n            return 1.0\n        elif distance_km <= 25:\n            return 0.9 - ((distance_km - 10) * 0.02)\n        elif distance_km <= 50:\n            return 0.6 - ((distance_km - 25) * 0.01)\n        elif distance_km <= 100:\n            return 0.35 - ((distance_km - 50) * 0.005)\n        else:\n            return max(0.1, 0.35 - ((distance_km - 100) * 0.001))\n    \n    @shared_task\n    def find_compatible_partners(\n        self,\n        max_results: int = 20,\n        filters: Dict = None\n    ) -> List[Dict]:\n        \"\"\"\n        Find and rank compatible climbing partners using AI matching.\n        Runs as async Celery task for performance.\n        \"\"\"\n        # Base queryset with efficient prefetching\n        candidates = User.objects.filter(\n            is_active=True,\n            climber_profile__is_available_for_partner=True\n        ).exclude(\n            id=self.user.id\n        ).select_related(\n            'climber_profile'\n        ).prefetch_related(\n            'climbing_styles',\n            'availability_slots',\n            'verified_skills'\n        )\n        \n        # Apply location-based filtering using PostGIS\n        if filters and 'max_distance_km' in filters:\n            candidates = candidates.filter(\n                climber_profile__location__distance_lte=(\n                    self.user_profile.location,\n                    Distance(km=filters['max_distance_km'])\n                )\n            )\n        \n        # Calculate compatibility scores for all candidates\n        results = []\n        for candidate in candidates:\n            overall_score, component_scores = self.calculate_compatibility_score(\n                candidate, filters\n            )\n            \n            # Apply minimum score threshold\n            if overall_score >= 0.5:\n                results.append({\n                    'user': candidate,\n                    'overall_score': overall_score,\n                    'component_scores': component_scores,\n                    'distance_km': self._get_distance_km(candidate)\n                })\n        \n        # Sort by overall score and return top results\n        results.sort(key=lambda x: x['overall_score'], reverse=True)\n        return results[:max_results]"
    },
    {
      "title": "Real-time WebSocket Messaging System",
      "language": "typescript",
      "code": "import { useEffect, useRef, useState, useCallback } from 'react';\nimport { ApolloClient, useApolloClient } from '@apollo/client';\n\ninterface Message {\n  id: string;\n  sender: User;\n  content: string;\n  timestamp: Date;\n  status: 'sending' | 'sent' | 'delivered' | 'read';\n  attachments?: Attachment[];\n}\n\ninterface WebSocketMessage {\n  type: 'message' | 'typing' | 'presence' | 'read_receipt';\n  payload: any;\n}\n\nexport function useRealtimeMessaging(conversationId: string) {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());\n  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n  \n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const typingTimeoutRef = useRef<Map<string, NodeJS.Timeout>>(new Map());\n  const apolloClient = useApolloClient();\n  \n  const connect = useCallback(() => {\n    try {\n      // Create WebSocket connection with authentication\n      const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL}/ws/chat/${conversationId}/`;\n      const ws = new WebSocket(wsUrl, [], {\n        headers: {\n          'Authorization': `Bearer ${getAuthToken()}`\n        }\n      });\n      \n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setConnectionError(null);\n        \n        // Send presence update\n        ws.send(JSON.stringify({\n          type: 'presence',\n          payload: { status: 'online' }\n        }));\n        \n        // Clear any pending reconnect timeout\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n          reconnectTimeoutRef.current = null;\n        }\n      };\n      \n      ws.onmessage = (event) => {\n        const data: WebSocketMessage = JSON.parse(event.data);\n        handleWebSocketMessage(data);\n      };\n      \n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setConnectionError('Connection error occurred');\n      };\n      \n      ws.onclose = (event) => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        \n        // Attempt to reconnect with exponential backoff\n        if (!event.wasClean) {\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            reconnectAttempts++;\n            connect();\n          }, delay);\n        }\n      };\n      \n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to create WebSocket:', error);\n      setConnectionError('Failed to establish connection');\n    }\n  }, [conversationId]);\n  \n  const handleWebSocketMessage = useCallback((data: WebSocketMessage) => {\n    switch (data.type) {\n      case 'message':\n        handleNewMessage(data.payload);\n        break;\n        \n      case 'typing':\n        handleTypingIndicator(data.payload);\n        break;\n        \n      case 'presence':\n        handlePresenceUpdate(data.payload);\n        break;\n        \n      case 'read_receipt':\n        handleReadReceipt(data.payload);\n        break;\n        \n      default:\n        console.warn('Unknown WebSocket message type:', data.type);\n    }\n  }, []);\n  \n  const handleNewMessage = useCallback((messageData: any) => {\n    const newMessage: Message = {\n      id: messageData.id,\n      sender: messageData.sender,\n      content: messageData.content,\n      timestamp: new Date(messageData.timestamp),\n      status: 'delivered',\n      attachments: messageData.attachments\n    };\n    \n    setMessages(prev => [...prev, newMessage]);\n    \n    // Update Apollo cache for consistency\n    apolloClient.cache.modify({\n      id: apolloClient.cache.identify({ \n        __typename: 'Conversation', \n        id: conversationId \n      }),\n      fields: {\n        messages(existingMessages = []) {\n          return [...existingMessages, newMessage];\n        },\n        lastMessage() {\n          return newMessage;\n        },\n        unreadCount(count) {\n          return count + 1;\n        }\n      }\n    });\n    \n    // Play notification sound if message is from another user\n    if (messageData.sender.id !== getCurrentUserId()) {\n      playNotificationSound();\n    }\n  }, [conversationId, apolloClient]);\n  \n  const handleTypingIndicator = useCallback((data: {\n    userId: string;\n    isTyping: boolean;\n  }) => {\n    setTypingUsers(prev => {\n      const next = new Set(prev);\n      \n      if (data.isTyping) {\n        next.add(data.userId);\n        \n        // Clear existing timeout for this user\n        const existingTimeout = typingTimeoutRef.current.get(data.userId);\n        if (existingTimeout) {\n          clearTimeout(existingTimeout);\n        }\n        \n        // Set new timeout to remove typing indicator after 3 seconds\n        const timeout = setTimeout(() => {\n          setTypingUsers(prev => {\n            const updated = new Set(prev);\n            updated.delete(data.userId);\n            return updated;\n          });\n          typingTimeoutRef.current.delete(data.userId);\n        }, 3000);\n        \n        typingTimeoutRef.current.set(data.userId, timeout);\n      } else {\n        next.delete(data.userId);\n        \n        // Clear timeout if exists\n        const timeout = typingTimeoutRef.current.get(data.userId);\n        if (timeout) {\n          clearTimeout(timeout);\n          typingTimeoutRef.current.delete(data.userId);\n        }\n      }\n      \n      return next;\n    });\n  }, []);\n  \n  const sendMessage = useCallback(async (\n    content: string,\n    attachments?: File[]\n  ): Promise<void> => {\n    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n    \n    // Create optimistic message\n    const optimisticMessage: Message = {\n      id: `temp-${Date.now()}`,\n      sender: getCurrentUser(),\n      content,\n      timestamp: new Date(),\n      status: 'sending',\n      attachments: []\n    };\n    \n    // Add to local state immediately\n    setMessages(prev => [...prev, optimisticMessage]);\n    \n    try {\n      // Upload attachments if any\n      let uploadedAttachments = [];\n      if (attachments && attachments.length > 0) {\n        uploadedAttachments = await uploadAttachments(attachments);\n      }\n      \n      // Send message through WebSocket\n      wsRef.current.send(JSON.stringify({\n        type: 'message',\n        payload: {\n          content,\n          attachments: uploadedAttachments,\n          tempId: optimisticMessage.id\n        }\n      }));\n      \n      // Update message status\n      setMessages(prev => prev.map(msg => \n        msg.id === optimisticMessage.id \n          ? { ...msg, status: 'sent' }\n          : msg\n      ));\n    } catch (error) {\n      // Handle send failure\n      setMessages(prev => prev.map(msg => \n        msg.id === optimisticMessage.id \n          ? { ...msg, status: 'failed' }\n          : msg\n      ));\n      throw error;\n    }\n  }, []);\n  \n  const sendTypingIndicator = useCallback((isTyping: boolean) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'typing',\n        payload: { isTyping }\n      }));\n    }\n  }, []);\n  \n  // Initialize connection\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      // Cleanup on unmount\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      typingTimeoutRef.current.forEach(timeout => clearTimeout(timeout));\n    };\n  }, [connect]);\n  \n  return {\n    messages,\n    isConnected,\n    connectionError,\n    typingUsers,\n    onlineUsers,\n    sendMessage,\n    sendTypingIndicator,\n    reconnect: connect\n  };\n}"
    }
  ]
}