---
title: "Arquitetura MCP para Triagem de Tickets de Suporte: Um Design Completo de Sistema"
date: "2025-04-23"
excerpt: "Projete e implemente um sistema automatizado de triagem de tickets de suporte usando a arquitetura Model Context Protocol (MCP). Aprenda a construir sistemas de IA agentiva de nível empresarial com separação adequada de responsabilidades."
tags: ["MCP", "Suporte ao Cliente", "Arquitetura de IA", "IA Empresarial", "Triagem de Tickets", "Design de Sistema"]
author: "Brandon"
---

import { Callout } from '@/components/ui/callout'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Badge } from '@/components/ui/badge'

Construir sistemas automatizados de suporte ao cliente que possam triar tickets de forma inteligente, escalar problemas urgentes e coordenar entre múltiplas plataformas requer planejamento arquitetural cuidadoso. Este guia demonstra como usar o Model Context Protocol (MCP) para criar um sistema distribuído e escalável que lida com fluxos de trabalho de suporte ao cliente de nível empresarial.

<Callout type="tip" className="mt-6">
  **Insight Principal**: O MCP permite construir sistemas de IA distribuídos onde cada componente se especializa em seu domínio, criando soluções empresariais mantíveis e escaláveis.
</Callout>

<Card className="mt-6">
  <CardHeader>
    <CardTitle>🎓 O Que Você Aprenderá</CardTitle>
  </CardHeader>
  <CardContent>
    <ul className="space-y-2">
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🏗️</Badge>
        <span>Projetar sistemas de IA distribuídos usando arquitetura MCP</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🔌</Badge>
        <span>Construir servidores MCP especializados para diferentes integrações</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🤖</Badge>
        <span>Implementar triagem inteligente de tickets com análise LLM</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🚀</Badge>
        <span>Implantar fluxos de trabalho de IA empresarial prontos para produção</span>
      </li>
    </ul>
  </CardContent>
</Card>

## 🎯 Definição do Problema

O suporte ao cliente moderno requer um sistema de IA agentiva que possa:

<Card className="mt-4">
  <CardHeader>
    <CardTitle>Requisitos Principais</CardTitle>
  </CardHeader>
  <CardContent>
    <ul className="space-y-2">
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">📂</Badge>
        <span><strong>Triar</strong> tickets de suporte ao cliente para as filas apropriadas</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🚨</Badge>
        <span><strong>Escalar</strong> problemas urgentes automaticamente</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🔔</Badge>
        <span><strong>Acionar comunicações no Slack</strong> para equipes relevantes</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🐞</Badge>
        <span><strong>Criar cards de bugs</strong> em ferramentas de gerenciamento de projetos</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">👥</Badge>
        <span><strong>Atribuir tickets</strong> às equipes apropriadas</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">📢</Badge>
        <span><strong>Enviar notificações</strong> para canais específicos das equipes</span>
      </li>
    </ul>
  </CardContent>
</Card>

<Callout type="warning" className="mt-4">
  Abordagens monolíticas tradicionais lutam com a complexidade e os requisitos de integração de ambientes empresariais. O MCP fornece a estrutura arquitetural necessária para construir sistemas distribuídos e mantíveis.
</Callout>

## 🏗️ Visão Geral da Arquitetura MCP

### 🤖 Aplicação Host (Cliente MCP)

<Card className="mt-4">
  <CardHeader>
    <CardTitle>Agente de Triagem de Suporte</CardTitle>
  </CardHeader>
  <CardContent>
    <p className="mb-3">O microserviço principal que:</p>
    <ul className="space-y-2">
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">📨</Badge>
        <span>Recebe tickets de suporte recebidos (via webhook, polling ou stream de eventos)</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🔌</Badge>
        <span>Usa a biblioteca cliente MCP para se comunicar com múltiplos servidores especializados</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">🧠</Badge>
        <span>Contém a lógica de negócios principal para processamento de tickets</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">✅</Badge>
        <span>Toma decisões finais sobre ações a serem executadas</span>
      </li>
    </ul>
  </CardContent>
</Card>

### 🔌 Servidores MCP (Múltiplos Servidores Especializados)

<Callout type="info" className="mt-4 mb-4">
  O poder do MCP está em sua capacidade de conectar múltiplos servidores especializados, cada um lidando com preocupações específicas:
</Callout>

### 1️⃣ Servidor MCP do Sistema de Suporte

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>🎫 Servidor do Sistema de Suporte</CardTitle>
  </CardHeader>
  <CardContent>
    <div className="space-y-3">
      <div>
        <Badge className="mb-2">🔧 Ferramentas</Badge>
        <p>Criar tickets, atualizar status, atribuir a filas, definir prioridade</p>
      </div>
      <div>
        <Badge className="mb-2">📊 Recursos</Badge>
        <p>Dados de tickets existentes, informações de filas, padrões históricos</p>
      </div>
      <div>
        <Badge className="mb-2">⚡ Capacidades</Badge>
        <p>Operações CRUD completas em tickets de suporte</p>
      </div>
    </div>
  </CardContent>
</Card>

<Tabs defaultValue="code" className="mt-4">
  <TabsList>
    <TabsTrigger value="code">Implementação da Ferramenta</TabsTrigger>
    <TabsTrigger value="explanation">Como Funciona</TabsTrigger>
  </TabsList>
  
  <TabsContent value="code">
```python
# Servidor do Sistema de Suporte
from mcp import FastMCP

support_mcp = FastMCP(name="support-system-server")

@support_mcp.tool
def update_ticket_status(ticket_id: str, status: str, assignee: str = None) -> dict:
    """Atualizar status do ticket e opcionalmente atribuir a membro da equipe."""
    # Integração com API do sistema de suporte (Zendesk, Freshdesk, etc.)
    result = support_api.update_ticket(
        ticket_id=ticket_id,
        status=status,
        assignee=assignee
    )
    return {
        "ticket_id": ticket_id,
        "new_status": status,
        "assigned_to": assignee,
        "updated_at": result.updated_at
    }

@support_mcp.resource
def get_queue_metrics() -> str:
    """Obter cargas de trabalho atuais das filas e tempos de resposta."""
    queues = support_api.get_all_queues()
    metrics = []
    for queue in queues:
        metrics.append({
            "queue_name": queue.name,
            "pending_tickets": queue.pending_count,
            "avg_response_time": queue.avg_response_hours,
            "capacity_utilization": queue.utilization_percent
        })
    return json.dumps(metrics)
```
  </TabsContent>
  
  <TabsContent value="explanation">
    <Card>
      <CardHeader>
        <CardTitle>Funcionalidade do Servidor</CardTitle>
      </CardHeader>
      <CardContent>
        <p>Este servidor fornece:</p>
        <ul className="mt-3 space-y-2">
          <li>• Atualizações de status de tickets em tempo real</li>
          <li>• Métricas de carga de trabalho das filas para roteamento inteligente</li>
          <li>• Acesso a dados históricos para reconhecimento de padrões</li>
          <li>• Integração com plataformas de suporte (Zendesk, Freshdesk, etc.)</li>
        </ul>
      </CardContent>
    </Card>
  </TabsContent>
</Tabs>

### 2️⃣ Servidor MCP do Slack

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>💬 Servidor de Comunicação Slack</CardTitle>
  </CardHeader>
  <CardContent>
    <div className="space-y-3">
      <div>
        <Badge className="mb-2">🔧 Ferramentas</Badge>
        <p>Enviar mensagens, criar canais, postar em canais específicos</p>
      </div>
      <div>
        <Badge className="mb-2">📊 Recursos</Badge>
        <p>Listas de canais, diretório de usuários, mapeamentos de equipes</p>
      </div>
      <div>
        <Badge className="mb-2">⚡ Capacidades</Badge>
        <p>Todas as operações da API do Slack</p>
      </div>
    </div>
  </CardContent>
</Card>

<Tabs defaultValue="code" className="mt-4">
  <TabsList>
    <TabsTrigger value="code">Implementação</TabsTrigger>
    <TabsTrigger value="integration">Detalhes da Integração</TabsTrigger>
  </TabsList>
  
  <TabsContent value="code">

```python
slack_mcp = FastMCP(name="slack-server")

@slack_mcp.tool
def send_urgent_notification(channel: str, message: str, ticket_id: str) -> dict:
    """Enviar notificação urgente para canal Slack especificado."""
    slack_message = {
        "channel": channel,
        "blocks": [
            {
                "type": "section",
                "text": {"type": "mrkdwn", "text": f"🚨 *Ticket Urgente*: {message}"}
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {"type": "plain_text", "text": "Ver Ticket"},
                        "url": f"https://support.company.com/tickets/{ticket_id}"
                    }
                ]
            }
        ]
    }
    
    response = slack_client.chat_postMessage(**slack_message)
    return {
        "message_sent": True,
        "channel": channel,
        "timestamp": response["ts"]
    }

@slack_mcp.resource
def get_team_channels() -> str:
    """Obter mapeamento de equipes para seus canais Slack."""
    team_mappings = {
        "frontend": "#frontend-team",
        "backend": "#backend-team",
        "infrastructure": "#infra-alerts",
        "product": "#product-team",
        "support": "#customer-support"
    }
    return json.dumps(team_mappings)
```

  </TabsContent>
  
  <TabsContent value="integration">
    <Card>
      <CardHeader>
        <CardTitle>Benefícios da Integração Slack</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-2">
          <li>• Notificações de equipe em tempo real</li>
          <li>• Blocos de mensagem interativos com botões de ação</li>
          <li>• Integração direta com canais de equipe</li>
          <li>• Trilha de auditoria de todas as comunicações</li>
        </ul>
      </CardContent>
    </Card>
  </TabsContent>
</Tabs>

### 3️⃣ Servidor MCP de Gerenciamento de Projetos

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>📋 Servidor de Gerenciamento de Projetos</CardTitle>
  </CardHeader>
  <CardContent>
    <div className="space-y-3">
      <div>
        <Badge className="mb-2">🔧 Ferramentas</Badge>
        <p>Criar histórias/bugs, atribuir a equipes, definir prioridades, adicionar etiquetas</p>
      </div>
      <div>
        <Badge className="mb-2">📊 Recursos</Badge>
        <p>Dados do projeto, atribuições de equipe, informações do sprint atual</p>
      </div>
      <div>
        <Badge className="mb-2">⚡ Capacidades</Badge>
        <p>Operações completas de gerenciamento de projetos (Shortcut, JIRA, Linear)</p>
      </div>
    </div>
  </CardContent>
</Card>

<Tabs defaultValue="code" className="mt-4">
  <TabsList>
    <TabsTrigger value="code">Implementação</TabsTrigger>
    <TabsTrigger value="workflow">Integração de Fluxo de Trabalho</TabsTrigger>
  </TabsList>
  
  <TabsContent value="code">

```python
project_mcp = FastMCP(name="project-management-server")

@project_mcp.tool
def create_bug_card(
    title: str, 
    description: str, 
    team: str, 
    priority: str,
    customer_impact: str
) -> dict:
    """Criar um card de bug no sistema de gerenciamento de projetos."""
    
    bug_data = {
        "name": title,
        "description": f"{description}\n\nImpacto no Cliente: {customer_impact}",
        "story_type": "bug",
        "requested_by_id": get_support_user_id(),
        "owner_ids": get_team_member_ids(team),
        "labels": [
            {"name": f"priority-{priority.lower()}"},
            {"name": "customer-reported"},
            {"name": f"team-{team.lower()}"}
        ]
    }
    
    story = shortcut_client.create_story(bug_data)
    
    return {
        "story_id": story.id,
        "story_url": story.app_url,
        "assigned_team": team,
        "priority": priority,
        "created_at": story.created_at
    }
```

  </TabsContent>
  
  <TabsContent value="workflow">
    <Card>
      <CardHeader>
        <CardTitle>Integração de Gerenciamento de Projetos</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-2">
          <li>• Criação automática de cards de bugs a partir de tickets</li>
          <li>• Atribuição de equipe baseada na área técnica</li>
          <li>• Mapeamento de prioridade dos níveis de urgência</li>
          <li>• Sincronização bidirecional com sistema de suporte</li>
        </ul>
      </CardContent>
    </Card>
  </TabsContent>
</Tabs>

### 4️⃣ Servidor MCP de Base de Conhecimento

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>📚 Servidor de Base de Conhecimento</CardTitle>
  </CardHeader>
  <CardContent>
    <div className="space-y-3">
      <div>
        <Badge className="mb-2">🔧 Ferramentas</Badge>
        <p>Pesquisar documentação, criar/atualizar artigos</p>
      </div>
      <div>
        <Badge className="mb-2">📊 Recursos</Badge>
        <p>Banco de dados de FAQ, guias de solução de problemas, procedimentos de escalonamento</p>
      </div>
      <div>
        <Badge className="mb-2">⚡ Capacidades</Badge>
        <p>Gerenciamento de conteúdo e pesquisa</p>
      </div>
    </div>
  </CardContent>
</Card>

## 🔄 Implementação Detalhada do Fluxo de Trabalho

### 🔍 Fase 1: Avaliação Inicial do Ticket

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>📄 Dados de Entrada</CardTitle>
  </CardHeader>
  <CardContent>
    <p>Novo ticket de suporte contendo:</p>
    <ul className="mt-2 space-y-1">
      <li>• Mensagem e consulta do cliente</li>
      <li>• Informações de contato</li>
      <li>• Área do produto ou serviço</li>
      <li>• Dados históricos de interação</li>
    </ul>
  </CardContent>
</Card>

<Tabs defaultValue="implementation" className="mt-4">
  <TabsList>
    <TabsTrigger value="implementation">Implementação do Fluxo MCP</TabsTrigger>
    <TabsTrigger value="workflow">Etapas do Fluxo de Trabalho</TabsTrigger>
  </TabsList>
  
  <TabsContent value="implementation">

```python
import asyncio
from mcp import stdio_client
from openai import OpenAI

class SupportTriageAgent:
    def __init__(self):
        self.openai_client = OpenAI()
        self.mcp_sessions = {}
    
    async def connect_to_servers(self):
        """Estabelecer conexões com todos os servidores MCP."""
        server_configs = {
            "support": {"command": "python", "args": ["support_server.py"]},
            "slack": {"command": "python", "args": ["slack_server.py"]},
            "project": {"command": "python", "args": ["project_server.py"]},
            "knowledge": {"command": "python", "args": ["kb_server.py"]}
        }
        
        for name, config in server_configs.items():
            session = stdio_client(config)
            await session.__aenter__()
            self.mcp_sessions[name] = session
    
    async def assess_new_ticket(self, ticket_data: dict) -> dict:
        """Fase 1: Avaliação inicial do ticket com coleta de recursos."""
        
        # Etapa 1: Descoberta de Capacidades
        print("Descobrindo capacidades disponíveis...")
        capabilities = {}
        for name, session in self.mcp_sessions.items():
            tools = await session.list_tools()
            resources = await session.list_resources()
            capabilities[name] = {"tools": tools, "resources": resources}
        
        # Etapa 2: Coleta de Recursos
        print("Coletando recursos contextuais...")
        
        # Obter dados históricos de tickets
        historical_data = await self.mcp_sessions["support"].read_resource(
            "similar_tickets", 
            {"query": ticket_data["content"][:200]}
        )
        
        # Obter informações da base de conhecimento
        kb_data = await self.mcp_sessions["knowledge"].read_resource(
            "troubleshooting_guides",
            {"category": ticket_data.get("category", "general")}
        )
        
        # Obter cargas de trabalho atuais das equipes
        team_workloads = await self.mcp_sessions["project"].read_resource(
            "team_capacity"
        )
        
        # Etapa 3: Análise LLM
        assessment_prompt = f"""
        Analise este ticket de suporte ao cliente:
        
        Conteúdo do Ticket: {ticket_data['content']}
        ID do Cliente: {ticket_data['customer_id']}
        Área do Produto: {ticket_data.get('product_area', 'unknown')}
        
        Contexto Histórico: {historical_data}
        Informações da Base de Conhecimento: {kb_data}
        Cargas de Trabalho das Equipes: {team_workloads}
        
        Forneça avaliação:
        1. Categoria do Problema (bug, feature_request, general_support, account_issue)
        2. Nível de Urgência (critical, high, medium, low)
        3. Área Técnica (frontend, backend, api, database, infrastructure)
        4. Atribuição Recomendada de Equipe
        5. Pontuação de Confiança (0.0-1.0)
        
        Formate como JSON.
        """
        
        response = self.openai_client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": assessment_prompt}],
            temperature=0.1
        )
        
        assessment = json.loads(response.choices[0].message.content)
        assessment["ticket_id"] = ticket_data["id"]
        
        return assessment
```
  </TabsContent>
  
  <TabsContent value="workflow">
    <Card>
      <CardHeader>
        <CardTitle>Fluxo de Trabalho de Avaliação</CardTitle>
      </CardHeader>
      <CardContent>
        <ol className="list-decimal list-inside space-y-3">
          <li>
            <strong>Descoberta de Capacidades</strong>
            <p className="ml-6 text-sm text-muted-foreground">Identificar ferramentas e recursos disponíveis dos servidores conectados</p>
          </li>
          <li>
            <strong>Coleta de Recursos</strong>
            <p className="ml-6 text-sm text-muted-foreground">Coletar dados históricos, informações da base de conhecimento e cargas de trabalho das equipes</p>
          </li>
          <li>
            <strong>Análise LLM</strong>
            <p className="ml-6 text-sm text-muted-foreground">Analisar conteúdo do ticket e fornecer categorização com pontuações de confiança</p>
          </li>
          <li>
            <strong>Geração de Avaliação</strong>
            <p className="ml-6 text-sm text-muted-foreground">Criar avaliação estruturada com categoria, urgência e recomendações de roteamento</p>
          </li>
        </ol>
      </CardContent>
    </Card>
  </TabsContent>
</Tabs>

### 📋 Fase 2: Classificação e Roteamento

<Callout type="info" className="mt-4 mb-4">
  **Decisão Crítica de Design**: A avaliação de regras de negócio acontece fora do controle do LLM. A IA fornece análise e recomendações, mas as decisões de roteamento seguem lógica de negócios predefinida.
</Callout>

#### 🦭 Análise de Recursos e Tomada de Decisão

```python
async def classify_and_route(self, ticket_data: dict, assessment: dict) -> dict:
    """Fase 2: Decisões de classificação e roteamento."""
    
    # Avaliação de regras de negócio (não decisões LLM)
    routing_decision = {
        "primary_action": None,
        "secondary_actions": [],
        "escalation_required": False,
        "notifications": []
    }
    
    # Lógica de negócio crítica: Limites de escalonamento
    if assessment["urgency_level"] == "critical":
        routing_decision["escalation_required"] = True
        routing_decision["primary_action"] = "immediate_escalation"
    
    # Fluxo de trabalho de tratamento de bugs
    elif assessment["issue_category"] == "bug":
        routing_decision["primary_action"] = "create_bug_card"
        routing_decision["secondary_actions"].append("notify_dev_team")
    
    # Roteamento de suporte padrão
    else:
        routing_decision["primary_action"] = "route_to_queue"
        if assessment["urgency_level"] == "high":
            routing_decision["secondary_actions"].append("notify_team_lead")
    
    # Determinar alvos de notificação
    team_channel_mapping = {
        "frontend": "#frontend-team",
        "backend": "#backend-team", 
        "infrastructure": "#infra-alerts",
        "api": "#backend-team"
    }
    
    target_channel = team_channel_mapping.get(assessment["technical_area"])
    if target_channel:
        routing_decision["notifications"].append({
            "type": "slack",
            "channel": target_channel,
            "urgency": assessment["urgency_level"]
        })
    
    return routing_decision
```

### ⚡ Fase 3: Execução de Ações

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>⚡ Estratégia de Execução</CardTitle>
  </CardHeader>
  <CardContent>
    <p>As ações são executadas com base nas decisões de roteamento:</p>
    <ul className="mt-3 space-y-2">
      <li>• <Badge variant="outline">Ações Primárias</Badge> Executar fluxo de trabalho principal (criação de bug, escalonamento, roteamento)</li>
      <li>• <Badge variant="outline">Ações Secundárias</Badge> Executar em paralelo (notificações, atualizações)</li>
      <li>• <Badge variant="outline">Notificações</Badge> Alertar equipes relevantes via canais configurados</li>
    </ul>
  </CardContent>
</Card>

#### 🔧 Sequência de Invocação de Ferramentas

```python
async def execute_actions(self, ticket_data: dict, assessment: dict, routing: dict):
    """Fase 3: Executar ações determinadas via ferramentas MCP."""
    
    results = []
    
    # Executar ação primária
    if routing["primary_action"] == "create_bug_card":
        result = await self.execute_bug_creation(ticket_data, assessment)
        results.append(result)
    
    elif routing["primary_action"] == "immediate_escalation":
        result = await self.execute_escalation(ticket_data, assessment)
        results.append(result)
    
    elif routing["primary_action"] == "route_to_queue":
        result = await self.execute_queue_routing(ticket_data, assessment)
        results.append(result)
    
    # Executar ações secundárias em paralelo
    secondary_tasks = []
    for action in routing["secondary_actions"]:
        if action == "notify_dev_team":
            task = self.send_team_notification(ticket_data, assessment)
            secondary_tasks.append(task)
        elif action == "notify_team_lead":
            task = self.send_lead_notification(ticket_data, assessment)
            secondary_tasks.append(task)
    
    if secondary_tasks:
        secondary_results = await asyncio.gather(*secondary_tasks)
        results.extend(secondary_results)
    
    # Executar notificações
    for notification in routing["notifications"]:
        if notification["type"] == "slack":
            result = await self.send_slack_notification(
                ticket_data, assessment, notification
            )
            results.append(result)
    
    return results

async def execute_bug_creation(self, ticket_data: dict, assessment: dict) -> dict:
    """Criar card de bug via servidor MCP de Gerenciamento de Projetos."""
    
    bug_title = f"Problema do Cliente: {ticket_data['subject']}"
    bug_description = f"""
    Relato do Cliente: {ticket_data['content']}
    
    ID do Cliente: {ticket_data['customer_id']}
    Área Técnica: {assessment['technical_area']}
    Urgência: {assessment['urgency_level']}
    
    Confiança da Avaliação: {assessment['confidence_score']}
    """
    
    # Chamar ferramenta MCP
    result = await self.mcp_sessions["project"].call_tool(
        "create_bug_card",
        {
            "title": bug_title,
            "description": bug_description,
            "team": assessment["recommended_squad"],
            "priority": assessment["urgency_level"],
            "customer_impact": self.assess_customer_impact(ticket_data)
        }
    )
    
    # Atualizar ticket original com link do bug
    await self.mcp_sessions["support"].call_tool(
        "update_ticket_status",
        {
            "ticket_id": ticket_data["id"],
            "status": "in_development",
            "external_link": result["story_url"]
        }
    )
    
    return {
        "action": "bug_created",
        "bug_id": result["story_id"],
        "bug_url": result["story_url"],
        "assigned_team": result["assigned_team"]
    }

async def send_slack_notification(self, ticket_data: dict, assessment: dict, notification: dict) -> dict:
    """Enviar notificação via servidor MCP do Slack."""
    
    urgency_emoji = {
        "critical": "🚨",
        "high": "⚠️", 
        "medium": "📋",
        "low": "📝"
    }
    
    message = f"""
    {urgency_emoji.get(assessment['urgency_level'], '📋')} Novo {assessment['issue_category'].replace('_', ' ').title()}
    
    Cliente: {ticket_data['customer_id']}
    Área: {assessment['technical_area']}
    Confiança: {assessment['confidence_score']:.1%}
    
    Prévia: {ticket_data['content'][:150]}...
    """
    
    result = await self.mcp_sessions["slack"].call_tool(
        "send_urgent_notification" if assessment["urgency_level"] == "critical" else "send_team_notification",
        {
            "channel": notification["channel"],
            "message": message,
            "ticket_id": ticket_data["id"]
        }
    )
    
    return {
        "action": "notification_sent",
        "channel": notification["channel"],
        "message_timestamp": result["timestamp"]
    }
```

## 🏗️ Decisões Arquiteturais Principais

### 1️⃣ Múltiplos Servidores Especializados

<Card className="mt-4">
  <CardHeader>
    <CardTitle>Decisão: Servidores MCP Separados</CardTitle>
  </CardHeader>
  <CardContent>
    <p className="mb-3"><strong>Usar servidores MCP separados para cada sistema externo</strong></p>
    
    <div className="space-y-3 mt-4">
      <div className="flex items-start gap-2">
        <Badge className="mt-0.5">Separação</Badge>
        <span>Cada servidor lida com um domínio de integração</span>
      </div>
      <div className="flex items-start gap-2">
        <Badge className="mt-0.5">Desenvolvimento</Badge>
        <span>Equipes podem atualizar integrações independentemente</span>
      </div>
      <div className="flex items-start gap-2">
        <Badge className="mt-0.5">Reusabilidade</Badge>
        <span>Outros aplicativos podem usar os mesmos servidores</span>
      </div>
      <div className="flex items-start gap-2">
        <Badge className="mt-0.5">Segurança</Badge>
        <span>Autenticação/autorização diferente por sistema</span>
      </div>
      <div className="flex items-start gap-2">
        <Badge className="mt-0.5">Escalabilidade</Badge>
        <span>Implantar servidores independentemente com base na carga</span>
      </div>
    </div>
  </CardContent>
</Card>

### 2️⃣ Processamento Síncrono vs. Assíncrono

<Card className="mt-4">
  <CardHeader>
    <CardTitle>Decisão: Modelo de Processamento Híbrido</CardTitle>
  </CardHeader>
  <CardContent>
    <p><strong>Classificação imediata com execução assíncrona de ações</strong></p>
    
    <div className="mt-4 space-y-2">
      <div className="flex items-center gap-2">
        <Badge variant="outline">🔴 Sync</Badge>
        <span>Avaliação inicial e decisões de roteamento</span>
      </div>
      <div className="flex items-center gap-2">
        <Badge variant="outline">🔵 Async</Badge>
        <span>Execução de ações e notificações</span>
      </div>
    </div>
  </CardContent>
</Card>

<Tabs defaultValue="implementation" className="mt-4">
  <TabsList>
    <TabsTrigger value="implementation">Implementação</TabsTrigger>
    <TabsTrigger value="benefits">Benefícios</TabsTrigger>
  </TabsList>
  
  <TabsContent value="implementation">
```python
async def process_ticket_workflow(self, ticket_data: dict) -> dict:
    """Fluxo de trabalho principal com processamento híbrido sync/async."""
    
    # Processamento imediato (síncrono)
    assessment = await self.assess_new_ticket(ticket_data)
    routing_decision = await self.classify_and_route(ticket_data, assessment)
    
    # Execução assíncrona de ações
    asyncio.create_task(
        self.execute_actions(ticket_data, assessment, routing_decision)
    )
    
    # Retornar resposta imediata
    return {
        "ticket_id": ticket_data["id"],
        "status": "processing",
        "assessment": assessment,
        "routing": routing_decision["primary_action"]
    }
```
  </TabsContent>
  
  <TabsContent value="benefits">
    <Card>
      <CardHeader>
        <CardTitle>Benefícios da Abordagem Híbrida</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-2">
          <li>✅ Resposta imediata ao cliente</li>
          <li>✅ Execução de ações não bloqueante</li>
          <li>✅ Melhor utilização de recursos</li>
          <li>✅ Tratamento gracioso de falhas downstream</li>
          <li>✅ Capacidade de agrupar ações similares</li>
        </ul>
      </CardContent>
    </Card>
  </TabsContent>
</Tabs>

### 3️⃣ Limites de Decisão do LLM

<Callout type="warning" className="mt-4 mb-4">
  **Separação Crítica**: Limites claros entre análise de IA e lógica de negócios garantem conformidade, auditabilidade e comportamento previsível do sistema.
</Callout>

<div className="grid gap-4 mt-4">
  <Card>
    <CardHeader>
      <CardTitle>🤖 Responsabilidades do LLM</CardTitle>
    </CardHeader>
    <CardContent>
      <ul className="space-y-2">
        <li>• Análise e categorização de conteúdo</li>
        <li>• Correspondência de similaridade com dados históricos</li>
        <li>• Identificação de área técnica</li>
        <li>• Avaliação de urgência baseada na linguagem do cliente</li>
      </ul>
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>💼 Responsabilidades da Lógica de Negócios</CardTitle>
    </CardHeader>
    <CardContent>
      <ul className="space-y-2">
        <li>• Decisões finais de roteamento baseadas nas cargas atuais das filas</li>
        <li>• Limites e procedimentos de escalonamento</li>
        <li>• Algoritmos de atribuição de equipe</li>
        <li>• Requisitos de conformidade e trilha de auditoria</li>
      </ul>
    </CardContent>
  </Card>
</div>

### 4️⃣ Tratamento de Erros e Fallbacks

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>🚫 Estratégia de Fallback</CardTitle>
  </CardHeader>
  <CardContent>
    <p>Sistema de fallback multinível garante confiabilidade:</p>
    <ol className="mt-3 list-decimal list-inside space-y-2">
      <li><Badge variant="outline">Nível 1</Badge> Falhas de avaliação LLM → Categorização padrão</li>
      <li><Badge variant="outline">Nível 2</Badge> Falhas de servidor → Fila para nova tentativa + alerta ops</li>
      <li><Badge variant="outline">Nível 3</Badge> Falhas críticas → Intervenção humana necessária</li>
    </ol>
  </CardContent>
</Card>
```python
class FallbackHandler:
    def __init__(self, agent):
        self.agent = agent
    
    async def handle_assessment_failure(self, ticket_data: dict) -> dict:
        """Nível 1: Fallback para falha de avaliação LLM."""
        return {
            "issue_category": "general_support",
            "urgency_level": "medium",
            "technical_area": "general",
            "confidence_score": 0.1,
            "fallback_reason": "llm_assessment_failed"
        }
    
    async def handle_server_failure(self, server_name: str, action: str, params: dict):
        """Nível 2: Fallback para falhas de servidor MCP."""
        # Enfileirar ação para nova tentativa
        await self.queue_for_retry(server_name, action, params)
        
        # Alertar equipe de operações
        await self.alert_ops_team(f"Servidor MCP {server_name} indisponível")
        
        return {"status": "queued_for_retry", "server": server_name}
    
    async def handle_critical_failure(self, ticket_data: dict, error: Exception):
        """Nível 3: Falha crítica do sistema - intervenção humana."""
        await self.alert_human_operators({
            "ticket_id": ticket_data["id"],
            "error": str(error),
            "timestamp": datetime.utcnow().isoformat(),
            "requires_manual_triage": True
        })
```

## 📊 Monitoramento e Observabilidade

<Tabs defaultValue="monitoring" className="mt-4">
  <TabsList>
    <TabsTrigger value="monitoring">Implementação de Monitoramento</TabsTrigger>
    <TabsTrigger value="metrics">Métricas Principais</TabsTrigger>
  </TabsList>
  
  <TabsContent value="monitoring">

```python
class SystemMonitor:
    def __init__(self):
        self.metrics = {}
        self.health_checks = {}
    
    async def monitor_mcp_servers(self, sessions: dict):
        """Monitorar saúde de todos os servidores MCP."""
        for name, session in sessions.items():
            try:
                # Verificação de saúde via chamada de ferramenta
                health = await session.call_tool("health_check", {})
                self.health_checks[name] = {
                    "status": "healthy",
                    "response_time": health.get("response_time_ms"),
                    "last_check": datetime.utcnow().isoformat()
                }
            except Exception as e:
                self.health_checks[name] = {
                    "status": "unhealthy",
                    "error": str(e),
                    "last_check": datetime.utcnow().isoformat()
                }
    
    def track_decision_accuracy(self, ticket_id: str, predicted: dict, actual: dict):
        """Rastrear precisão de decisão LLM para melhoria contínua."""
        accuracy_metrics = {
            "category_correct": predicted["issue_category"] == actual["issue_category"],
            "urgency_correct": predicted["urgency_level"] == actual["urgency_level"],
            "squad_correct": predicted["recommended_squad"] == actual["actual_squad"]
        }
        
        self.metrics[ticket_id] = {
            "predicted": predicted,
            "actual": actual,
            "accuracy": accuracy_metrics,
            "timestamp": datetime.utcnow().isoformat()
        }
```
  </TabsContent>
  
  <TabsContent value="metrics">
    <Card>
      <CardHeader>
        <CardTitle>Métricas Essenciais para Rastrear</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid gap-3">
          <div>
            <Badge className="mb-2">Saúde do Servidor</Badge>
            <ul className="text-sm space-y-1 ml-4">
              <li>• Tempos de resposta por servidor</li>
              <li>• Disponibilidade e tempo de atividade</li>
              <li>• Taxas de erro por operação</li>
            </ul>
          </div>
          <div>
            <Badge className="mb-2">Precisão de Decisão</Badge>
            <ul className="text-sm space-y-1 ml-4">
              <li>• Precisão de previsão de categoria</li>
              <li>• Precisão de avaliação de urgência</li>
              <li>• Correção de atribuição de equipe</li>
            </ul>
          </div>
          <div>
            <Badge className="mb-2">Métricas de Negócio</Badge>
            <ul className="text-sm space-y-1 ml-4">
              <li>• Tempo médio de resolução</li>
              <li>• Taxas de escalonamento</li>
              <li>• Pontuações de satisfação do cliente</li>
            </ul>
          </div>
        </div>
      </CardContent>
    </Card>
  </TabsContent>
</Tabs>

## 🔒 Segurança e Conformidade

<Card className="mt-4 mb-4">
  <CardHeader>
    <CardTitle>Implementação de Segurança</CardTitle>
  </CardHeader>
  <CardContent>
    <p>Considerações de segurança de nível empresarial:</p>
    <ul className="mt-3 space-y-2">
      <li>• <Badge variant="outline">Trilha de Auditoria</Badge> Registro completo de todas as decisões e ações</li>
      <li>• <Badge variant="outline">Sanitização de Dados</Badge> Remover informações sensíveis de logs e métricas</li>
      <li>• <Badge variant="outline">Controle de Acesso</Badge> Autenticação e autorização por servidor</li>
      <li>• <Badge variant="outline">Conformidade</Badge> GDPR, CCPA e requisitos específicos da indústria</li>
    </ul>
  </CardContent>
</Card>

```python
class SecurityManager:
    def __init__(self):
        self.audit_log = []
    
    def log_tool_invocation(self, user_id: str, tool: str, params: dict, justification: str):
        """Registrar todas as invocações de ferramentas para trilha de auditoria."""
        self.audit_log.append({
            "timestamp": datetime.utcnow().isoformat(),
            "user_id": user_id,
            "tool": tool,
            "parameters": self.sanitize_sensitive_data(params),
            "justification": justification,
            "session_id": self.get_session_id()
        })
    
    def sanitize_sensitive_data(self, data: dict) -> dict:
        """Remover informações sensíveis dos logs."""
        sensitive_fields = ["password", "token", "api_key", "customer_email"]
        sanitized = data.copy()
        for field in sensitive_fields:
            if field in sanitized:
                sanitized[field] = "[REDACTED]"
        return sanitized
```

## 🎆 Benefícios Desta Arquitetura

<div className="grid gap-4 mt-6">
  <Card>
    <CardHeader>
      <CardTitle>🔌 Plugabilidade</CardTitle>
    </CardHeader>
    <CardContent>
      <ul className="space-y-2">
        <li>• Fácil adicionar novas integrações (JIRA, Teams, etc.)</li>
        <li>• Servidores desenvolvidos e implantados independentemente</li>
        <li>• Sem necessidade de modificar lógica de triagem principal para novas ferramentas</li>
      </ul>
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>🔍 Descoberta</CardTitle>
    </CardHeader>
    <CardContent>
      <ul className="space-y-2">
        <li>• Cliente aprende automaticamente sobre capacidades disponíveis</li>
        <li>• Novos servidores podem ser registrados sem alterações de código</li>
        <li>• Adaptação dinâmica aos serviços disponíveis</li>
      </ul>
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>🧩 Composição</CardTitle>
    </CardHeader>
    <CardContent>
      <ul className="space-y-2">
        <li>• Servidores podem se encadear (servidor Shortcut usando servidor Slack)</li>
        <li>• Fluxos de trabalho complexos emergem de interações simples de servidor</li>
        <li>• Componentes reutilizáveis em diferentes aplicações</li>
      </ul>
    </CardContent>
  </Card>
</div>

## 🎯 Conclusão

<Card className="mt-6">
  <CardHeader>
    <CardTitle>Principais Conclusões</CardTitle>
  </CardHeader>
  <CardContent>
    <p className="mb-4">Esta arquitetura baseada em MCP fornece uma solução escalável e mantível que:</p>
    <ul className="space-y-2">
      <li>✅ Aproveita a plugabilidade do protocolo para fácil extensão</li>
      <li>✅ Mantém separação adequada de responsabilidades</li>
      <li>✅ Garante controle de negócios sobre decisões críticas</li>
      <li>✅ Cria limites claros entre IA e lógica de negócios</li>
      <li>✅ Permite confiabilidade e conformidade de nível empresarial</li>
    </ul>
  </CardContent>
</Card>

<Callout type="success" className="mt-6">
  **Lembre-se**: Ao distribuir funcionalidade entre servidores especializados e manter uma camada clara de orquestração, você pode construir sistemas robustos, testáveis e adaptáveis a requisitos de negócios em mudança, enquanto fornece os benefícios de automação que o suporte ao cliente moderno exige.
</Callout>

## 🚀 Próximos Passos

<Card className="mt-6">
  <CardHeader>
    <CardTitle>Pronto para Construir?</CardTitle>
  </CardHeader>
  <CardContent>
    <p className="mb-4">Comece a implementar seu próprio sistema de suporte ao cliente baseado em MCP:</p>
    <ol className="list-decimal list-inside space-y-2">
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">1</Badge>
        <span>Configure seu ambiente de desenvolvimento com bibliotecas MCP</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">2</Badge>
        <span>Crie seu primeiro servidor MCP especializado para uma integração</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">3</Badge>
        <span>Construa o agente principal de triagem com lógica básica de roteamento</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">4</Badge>
        <span>Adicione monitoramento e observabilidade desde o início</span>
      </li>
      <li className="flex items-start gap-2">
        <Badge variant="outline" className="mt-0.5">5</Badge>
        <span>Itere e expanda com servidores e capacidades adicionais</span>
      </li>
    </ol>
  </CardContent>
</Card>

<Callout type="info" className="mt-6">
  **Dica Profissional**: Comece pequeno com um ou dois servidores MCP e expanda gradualmente. A beleza desta arquitetura é que você pode adicionar novas capacidades sem modificar componentes existentes.
</Callout>