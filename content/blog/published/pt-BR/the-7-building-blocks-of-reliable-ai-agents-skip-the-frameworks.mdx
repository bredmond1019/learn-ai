---
title: "Os 7 Blocos de ConstruÃ§Ã£o de Agentes de IA ConfiÃ¡veisâ€”Pule os Frameworks"
date: "2025-07-23"
excerpt: "Pare de debater frameworks. Comece a construir agentes que funcionam. Harrison Chase do LangChain revela os 7 componentes fundamentais que todo sistema de agente confiÃ¡vel precisa, independentemente da stack."
tags: ["Agentes de IA", "Arquitetura de Sistemas", "LangChain", "Engenharia de IA", "Melhores PrÃ¡ticas"]
author: "Brandon"
featured: true
---

"Qual framework de agentes devo usar?"

Pergunta errada.

Harrison Chase, CEO do LangChain, acabou de jogar uma bomba de conhecimento que deveria reformular como pensamos sobre construÃ§Ã£o de agentes. Depois de analisar centenas de sistemas de agentes em produÃ§Ã£o, ele identificou 7 blocos de construÃ§Ã£o fundamentais que TODOS os agentes confiÃ¡veis compartilham.

O kicker? NÃ£o importa se vocÃª estÃ¡ usando LangChain, AutoGPT, CrewAI ou cÃ³digo puro. Esses blocos sÃ£o universais.

## A Armadilha do Framework ğŸª¤

Vamos enfrentar a realidade:

<Callout type="warning">
**A Verdade Inconveniente**: A maioria dos debates sobre frameworks de agentes Ã© como discutir qual marca de martelo comprar quando vocÃª ainda nÃ£o decidiu o que estÃ¡ construindo.
</Callout>

Harrison viu esse padrÃ£o repetidamente:
- Equipes gastam semanas avaliando frameworks
- Escolhem um baseado em hype/estrelas no GitHub
- Percebem que ainda precisam construir os mesmos componentes principais
- Acabam construindo metade de um framework customizado de qualquer jeito

Parada. Vamos focar no que realmente importa.

## Os 7 Blocos de ConstruÃ§Ã£o de Agentes ConfiÃ¡veis ğŸ—ï¸

<CodeExample
  title="A Arquitetura Universal de Agentes"
  language="yaml"
  code={`blocos_construcao_agente:
  1_modelos_base:
    - llm: "CÃ©rebro do raciocÃ­nio"
    - embedding: "CompreensÃ£o semÃ¢ntica"
    - reranking: "PriorizaÃ§Ã£o de relevÃ¢ncia"
  
  2_orquestracao:
    - agentic: "Tomada de decisÃ£o autÃ´noma"
    - deterministico: "Fluxos de trabalho previsÃ­veis"
    - hibrido: "Melhor dos dois mundos"
  
  3_design_prompt:
    - especifico_tarefa: "O que fazer"
    - formatacao_saida: "Como responder"
    - exemplos_contexto: "Como se comportar"
  
  4_recuperacao:
    - busca_vetorial: "Encontrar similar"
    - busca_palavras_chave: "Encontrar exato"
    - grafos_conhecimento: "Encontrar conectado"
  
  5_memoria:
    - dialogo: "Lembrar conversa"
    - tarefa: "Lembrar progresso"
    - conhecimento: "Lembrar aprendizados"
  
  6_ferramentas:
    - utilitarios: "Calculadora, data/hora"
    - integracao: "APIs, bancos de dados"
    - customizadas: "LÃ³gica de negÃ³cio"
  
  7_guardrails:
    - seguranca: "Prevenir danos"
    - qualidade: "Garantir precisÃ£o"
    - compliance: "Seguir regras"`}
/>

Vamos detalhar cada um com exemplos do mundo real.

## Bloco 1: Modelosâ€”Escolha Sua PotÃªncia ğŸ§ 

Harrison esclareceu: "Pare de tentar fazer um modelo fazer tudo. Use modelos especializados para tarefas especializadas."

<CodeExample
  title="SeleÃ§Ã£o de Modelo EstratÃ©gica"
  language="javascript"
  code={`class SeletorModeloInteligente {
  constructor() {
    // Diferentes modelos para diferentes trabalhos
    this.modelos = {
      raciocinio: 'gpt-4', // Caro mas inteligente
      classificacao: 'gpt-3.5-turbo', // RÃ¡pido e barato
      embeddings: 'text-embedding-3-small', // Eficiente
      reranking: 'cohere-rerank-v2', // Especializado
      codigo: 'claude-3-opus', // Melhor para programaÃ§Ã£o
      multilingual: 'claude-3-sonnet' // Ã“timo com idiomas
    };
  }
  
  async processar(tarefa) {
    // Escolher modelo baseado na tarefa
    switch(tarefa.tipo) {
      case 'decisao_complexa':
        return await this.usarModelo('raciocinio', tarefa);
        
      case 'filtrar_resultados':
        // Usar modelo barato para filtrar, caro para processar
        const candidatos = await this.usarModelo('classificacao', tarefa);
        return await this.usarModelo('raciocinio', candidatos);
        
      case 'busca_semantica':
        const embeddings = await this.usarModelo('embeddings', tarefa);
        return await this.usarModelo('reranking', embeddings);
        
      default:
        return await this.usarModelo('classificacao', tarefa);
    }
  }
}`}
/>

**Insight chave**: Usar GPT-4 para tudo Ã© como usar uma Ferrari para entregar pizzaâ€”caro e desnecessÃ¡rio.

## Bloco 2: OrquestraÃ§Ã£oâ€”O PadrÃ£o de Controle ğŸ¯

Este Ã© onde a maioria das equipes se perde. Harrison identificou trÃªs padrÃµes:

<CodeExample
  title="PadrÃµes de OrquestraÃ§Ã£o"
  language="python"
  code={`# PadrÃ£o 1: Totalmente AgÃªntico (CaÃ³tico mas FlexÃ­vel)
class AgenteAutonomo:
    def executar(self, objetivo):
        while not objetivo_completo:
            acao = self.llm.decidir_proxima_acao(objetivo, historico)
            resultado = self.executar_acao(acao)
            historico.append(resultado)
            # Problema: Pode dar loops infinitos
            
# PadrÃ£o 2: DeterminÃ­stico (PrevisÃ­vel mas RÃ­gido)
class FluxoTrabalhoFixo:
    def executar(self, entrada):
        resultado1 = self.passo1(entrada)
        resultado2 = self.passo2(resultado1)
        return self.passo3(resultado2)
        # Problema: NÃ£o consegue se adaptar
        
# PadrÃ£o 3: HÃ­brido (Melhor PrÃ¡tica do LangChain)
class OrquestradorHibrido:
    def executar(self, objetivo):
        # Fluxo de trabalho determinÃ­stico de alto nÃ­vel
        plano = self.criar_plano(objetivo)
        
        for passo in plano.passos:
            if passo.requer_julgamento:
                # Deixar agente decidir como executar
                resultado = self.execucao_agentiva(passo)
            else:
                # Usar lÃ³gica determinÃ­stica
                resultado = self.execucao_fixa(passo)
                
            if resultado.requer_replanejamento:
                plano = self.adaptar_plano(plano, resultado)
                
        return self.compilar_resultados()`}
/>

Harrison revelou: "80% dos agentes de produÃ§Ã£o bem-sucedidos usam orquestraÃ§Ã£o hÃ­brida."

## Bloco 3: Design de Promptâ€”A ProgramaÃ§Ã£o de Agentes ğŸ“

EsqueÃ§a prompts genÃ©ricos. Harrison enfatizou especificidade extrema:

<CodeExample
  title="Sistema de Prompt de NÃ­vel de ProduÃ§Ã£o"
  language="python"
  code={`class SistemaPromptProducao:
    def __init__(self):
        # Prompts base versionados
        self.prompts = {
            'analisador_vendas': {
                'v1.2': """VocÃª Ã© um analista de vendas para {company}.
                
CONTEXTO:
- Trimestre fiscal atual: {quarter}
- Meta de vendas: ${target}
- Produtos principais: {products}

SUA TAREFA:
1. Analisar dados de vendas fornecidos
2. Identificar tendÃªncias (positivas e negativas)
3. Sugerir aÃ§Ãµes especÃ­ficas

FORMATO DE SAÃDA:
```json
{
  "resumo": "2-3 frases",
  "tendencias": [{"tipo": "positiva|negativa", "detalhe": "..."}],
  "acoes": [{"prioridade": "alta|media|baixa", "acao": "..."}]
}
```

EXEMPLOS:
{examples}

RESTRIÃ‡Ã•ES:
- NÃºmeros devem ter precisÃ£o de 2 decimais
- Mencionar apenas produtos de {products}
- AÃ§Ãµes devem ser implementÃ¡veis em 30 dias"""
            }
        }
    
    def gerar_prompt(self, tipo, contexto):
        # Injetar contexto dinÃ¢mico
        template = self.prompts[tipo][self.versao_ativa]
        
        # Adicionar exemplos especÃ­ficos do domÃ­nio
        exemplos = self.buscar_exemplos_relevantes(tipo, contexto)
        
        # Formatar com variÃ¡veis
        return template.format(
            **contexto,
            examples=self.formatar_exemplos(exemplos)
        )`}
/>

**Sacada profunda**: "Seu prompt Ã‰ seu cÃ³digo. Versione, teste e faÃ§a deploy como tal."

## Bloco 4: RecuperaÃ§Ã£oâ€”Encontrando Agulhas em Palheiros ğŸ”

Harrison foi direto: "RAG ruim mata mais agentes do que qualquer outra coisa."

<CodeExample
  title="Sistema de RecuperaÃ§Ã£o Multicamadas"
  language="javascript"
  code={`class RecuperadorInteligente {
  constructor() {
    this.estrategias = {
      denso: new BuscaVetorial(),      // Busca semÃ¢ntica
      esparso: new BuscaBM25(),        // Busca por palavra-chave
      hibrido: new BuscaHibrida(),     // Combinar pontuaÃ§Ãµes
      grafo: new BuscaGrafo(),         // RelaÃ§Ãµes
      sql: new BuscaEstruturada()      // Dados exatos
    };
  }
  
  async recuperar(consulta, contexto) {
    // Analisar tipo de consulta
    const tipoConsulta = this.analisarConsulta(consulta);
    
    // RecuperaÃ§Ã£o multicamadas
    let resultados = [];
    
    if (tipoConsulta.necessitaSemantica) {
      const semanticos = await this.estrategias.denso.buscar(consulta);
      resultados.push(...semanticos);
    }
    
    if (tipoConsulta.temPalavrasChaveEspecificas) {
      const exatos = await this.estrategias.esparso.buscar(consulta);
      resultados.push(...exatos);
    }
    
    if (tipoConsulta.necessitaContextoRelacional) {
      const relacionados = await this.estrategias.grafo.buscarRelacionados(
        consulta, 
        profundidade=2
      );
      resultados.push(...relacionados);
    }
    
    // Reranking inteligente
    const rerankeados = await this.reranker.classificar(
      consulta, 
      resultados,
      contexto
    );
    
    // Retornar top K com metadados
    return rerankeados.slice(0, contexto.k).map(r => ({
      conteudo: r.conteudo,
      pontuacao: r.pontuacao,
      fonte: r.fonte,
      tipo: r.tipo,
      confianca: this.calcularConfianca(r)
    }));
  }
}`}
/>

## Bloco 5: MemÃ³riaâ€”Dando Contexto aos Agentes ğŸ§©

Harrison destacou trÃªs tipos de memÃ³ria que todo agente precisa:

<CodeExample
  title="Sistema de MemÃ³ria em TrÃªs Camadas"
  language="python"
  code={`class SistemaMemoriaCompleto:
    def __init__(self):
        # MemÃ³ria de diÃ¡logo (curto prazo)
        self.dialogo = MemoriaDialogo(
            janela_max=50,  # Ãšltimas 50 mensagens
            estrategia_resumo='progressiva'  # Resumir mensagens antigas
        )
        
        # MemÃ³ria de tarefa (mÃ©dio prazo)
        self.tarefa = MemoriaTarefa(
            estrutura={
                'objetivo_atual': None,
                'subtarefas_completas': [],
                'blockers': [],
                'decisoes_tomadas': [],
                'contexto_acumulado': {}
            }
        )
        
        # MemÃ³ria de conhecimento (longo prazo)
        self.conhecimento = MemoriaConhecimento(
            backend='pgvector',
            estrategia_indexacao='hierarquica',
            politica_retencao='baseada_em_relevancia'
        )
    
    def atualizar(self, evento):
        # Rotear para memÃ³ria apropriada
        if evento.tipo == 'mensagem_usuario':
            self.dialogo.adicionar(evento)
            
        elif evento.tipo == 'tarefa_progresso':
            self.tarefa.atualizar(evento)
            
        elif evento.tipo == 'aprendizado':
            # Extrair conhecimento generalizÃ¡vel
            conhecimento = self.extrair_conhecimento(evento)
            self.conhecimento.armazenar(conhecimento)
    
    def recuperar_contexto(self, consulta):
        return {
            'conversa_recente': self.dialogo.obter_relevante(consulta),
            'estado_tarefa': self.tarefa.obter_estado_atual(),
            'conhecimento_relevante': self.conhecimento.buscar(consulta, k=5)
        }`}
/>

**Ponto crÃ­tico**: "MemÃ³ria sem estratÃ©gia de poda Ã© apenas acumulaÃ§Ã£o de lixo."

## Bloco 6: Ferramentasâ€”Dando MÃ£os aos Agentes ğŸ› ï¸

Harrison foi enfÃ¡tico: "Pare de criar ferramentas desnecessÃ¡rias."

<CodeExample
  title="Design de Ferramentas Inteligente"
  language="typescript"
  code={`class GerenciadorFerramentas {
  constructor() {
    // Apenas ferramentas que realmente precisam ser ferramentas
    this.ferramentas = new Map();
    
    // NÃƒO faÃ§a ferramentas para estas:
    // âŒ Obter data atual (coloque no prompt)
    // âŒ MatemÃ¡tica bÃ¡sica (LLM pode fazer)
    // âŒ FormataÃ§Ã£o de string (desperdÃ­cio)
    
    // FAÃ‡A ferramentas para estas:
    // âœ… Chamadas de API externas
    // âœ… Consultas de banco de dados
    // âœ… OperaÃ§Ãµes de arquivo
    // âœ… CÃ¡lculos complexos
  }
  
  registrarFerramenta(nome: string, config: ConfigFerramenta) {
    // Validar que a ferramenta Ã© necessÃ¡ria
    if (this.podeSerFeitoNativamente(config)) {
      throw new Error(`${nome} deveria ser lÃ³gica inline, nÃ£o ferramenta`);
    }
    
    this.ferramentas.set(nome, {
      // Metadados ricos para seleÃ§Ã£o de ferramenta
      descricao: config.descricao,
      parametros: config.parametros,
      exemplos: config.exemplos,
      quandoUsar: config.quandoUsar,
      quandoNaoUsar: config.quandoNaoUsar,
      
      // ImplementaÃ§Ã£o real
      executar: async (params) => {
        // ValidaÃ§Ã£o de entrada
        this.validar(params, config.parametros);
        
        // ExecuÃ§Ã£o com tratamento de erro
        try {
          const resultado = await config.implementacao(params);
          return { sucesso: true, data: resultado };
        } catch (erro) {
          return { 
            sucesso: false, 
            erro: erro.message,
            podeRetentar: this.ehRetentavel(erro)
          };
        }
      }
    });
  }
}`}
/>

## Bloco 7: Guardrailsâ€”Mantendo Agentes nos Trilhos ğŸ›¡ï¸

O bloco final e mais crÃ­tico:

<CodeExample
  title="Sistema de Guardrails Abrangente"
  language="python"
  code={`class SistemaGuardrails:
    def __init__(self):
        self.verificadores = []
        
        # Guardrails de seguranÃ§a
        self.adicionar_verificador(VerificadorInjecaoPrompt())
        self.adicionar_verificador(VerificadorPII())
        self.adicionar_verificador(VerificadorToxicidade())
        
        # Guardrails de qualidade
        self.adicionar_verificador(VerificadorAlucinacao())
        self.adicionar_verificador(VerificadorConsistencia())
        self.adicionar_verificador(VerificadorFormatoSaida())
        
        # Guardrails de negÃ³cio
        self.adicionar_verificador(VerificadorPoliticaEmpresa())
        self.adicionar_verificador(VerificadorLimitesCusto())
        self.adicionar_verificador(VerificadorSLA())
    
    async def verificar_entrada(self, entrada):
        for verificador in self.verificadores:
            if verificador.aplica_a_entrada:
                resultado = await verificador.verificar_entrada(entrada)
                if not resultado.passou:
                    return self.lidar_com_falha(resultado)
    
    async def verificar_saida(self, saida, contexto):
        for verificador in self.verificadores:
            if verificador.aplica_a_saida:
                resultado = await verificador.verificar_saida(saida, contexto)
                if not resultado.passou:
                    if resultado.pode_corrigir:
                        saida = await self.tentar_corrigir(saida, resultado)
                    else:
                        return self.lidar_com_falha(resultado)
        
        return saida
    
    def lidar_com_falha(self, resultado):
        # Registrar para anÃ¡lise
        self.logger.avisar(f"Guardrail acionado: {resultado}")
        
        # Retornar resposta segura
        return {
            'resposta': self.resposta_fallback,
            'razao': resultado.razao_amigavel_usuario,
            'metadados': {
                'guardrail_acionado': resultado.verificador,
                'gravidade': resultado.gravidade
            }
        }`}
/>

## Juntando Tudo: Arquitetura de ReferÃªncia ğŸ›ï¸

Harrison compartilhou esta arquitetura de referÃªncia do LangChain:

<CodeExample
  title="Arquitetura de Agente de ProduÃ§Ã£o Completa"
  language="yaml"
  code={`arquitetura_agente_producao:
  camada_entrada:
    - validacao_entrada
    - classificacao_intencao
    - guardrails_seguranca
  
  camada_processamento:
    modelos:
      classificador: gpt-3.5-turbo
      raciocinador: gpt-4
      embedder: text-embedding-3
    
    orquestracao:
      tipo: hibrido
      fluxo_deterministico: 
        - analisar_consulta
        - recuperar_contexto
        - gerar_resposta
        - validar_saida
      
      decisoes_agentivas:
        - quando_buscar_mais_info
        - qual_ferramenta_usar
        - como_formatar_resposta
    
    memoria:
      dialogo: redis (TTL 24h)
      tarefa: postgres 
      conhecimento: pgvector
    
    recuperacao:
      estrategia: hibrida
      indices:
        - semantico: pgvector
        - palavra_chave: elasticsearch
        - estruturado: postgres
    
    ferramentas:
      - api_interna
      - calculadora_complexa
      - gerador_relatorios
  
  camada_saida:
    - formatacao_resposta
    - guardrails_qualidade
    - rastreamento_metricas
    - cache_resposta`}
/>

## LiÃ§Ãµes do Mundo Real do LangChain ğŸ“

### LiÃ§Ã£o 1: Comece Simples, Adicione Complexidade
"90% dos POCs falham porque tentam usar todos os 7 blocos perfeitamente desde o dia 1. Comece com 3-4, faÃ§a funcionar, depois adicione."

### LiÃ§Ã£o 2: InstrumentaÃ§Ã£o Ã© ObrigatÃ³ria
"Se vocÃª nÃ£o consegue ver o que seu agente estÃ¡ fazendo, nÃ£o consegue melhorÃ¡-lo. LangSmith existe porque aprendemos isso da maneira difÃ­cil."

### LiÃ§Ã£o 3: HÃ­brido > Puro
"Agentes puramente autÃ´nomos sÃ£o demos legais. Agentes hÃ­bridos sÃ£o sistemas de produÃ§Ã£o."

### LiÃ§Ã£o 4: O Contexto Ã© Rei
"Um agente medÃ­ocre com excelente recuperaÃ§Ã£o supera um agente brilhante com RAG ruim."

## Seu Checklist de ImplementaÃ§Ã£o âœ…

<Callout type="action">
**Semana 1-2: MVP com 4 Blocos**
- [ ] Escolha modelo principal (provavelmente GPT-3.5 para comeÃ§ar)
- [ ] Implemente orquestraÃ§Ã£o bÃ¡sica (comece determinÃ­stica)
- [ ] Escreva 3-5 prompts especÃ­ficos de tarefa
- [ ] Adicione guardrails bÃ¡sicos de seguranÃ§a

**Semana 3-4: Adicione InteligÃªncia**
- [ ] Implemente recuperaÃ§Ã£o bÃ¡sica (comece com busca vetorial)
- [ ] Adicione memÃ³ria de diÃ¡logo
- [ ] Crie 2-3 ferramentas essenciais

**MÃªs 2: EndureÃ§a para ProduÃ§Ã£o**
- [ ] Upgrade para orquestraÃ§Ã£o hÃ­brida
- [ ] Implemente todas as 3 camadas de memÃ³ria
- [ ] Adicione guardrails completos
- [ ] Implemente monitoramento/observabilidade

**MÃªs 3: Otimize e Escale**
- [ ] OtimizaÃ§Ã£o de seleÃ§Ã£o de modelo
- [ ] Ajuste fino de recuperaÃ§Ã£o
- [ ] OtimizaÃ§Ã£o de desempenho
- [ ] Testes de carga
</Callout>

## A Mentalidade Anti-Framework ğŸ§ 

As palavras finais de Harrison que deveriam estar gravadas em pedra:

"Frameworks sÃ£o implementaÃ§Ãµes opinativas desses 7 blocos. Uma vez que vocÃª entende os blocos, pode usar qualquer frameworkâ€”ou nenhumâ€”e ainda construir Ã³timos agentes."

O segredo nÃ£o Ã© escolher o framework perfeito. Ã‰ entender os componentes fundamentais tÃ£o bem que vocÃª poderia construÃ­-los do zero se precisasse.

<Callout type="insight">
**A PercepÃ§Ã£o Final**: Agentes confiÃ¡veis nÃ£o vÃªm de frameworks mÃ¡gicos. Eles vÃªm de implementar deliberadamente cada um desses 7 blocos de uma forma que se adeque ao seu caso de uso especÃ­fico.

Pare de procurar balas de prata. Comece a construir com blocos fundamentais.
</Callout>

Agora pare de ler sobre frameworks e comece a construir. Seus agentes estÃ£o esperando.

*P.S. - Sim, Harrison Ã© o CEO do LangChain e ainda estÃ¡ dizendo para nÃ£o ficar obcecado com frameworks. Isso deveria te dizer algo.*