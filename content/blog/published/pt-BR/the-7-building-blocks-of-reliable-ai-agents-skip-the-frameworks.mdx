---
title: "Os 7 Blocos de Construção de Agentes de IA Confiáveis—Pule os Frameworks"
date: "2025-07-23"
excerpt: "Pare de debater frameworks. Comece a construir agentes que funcionam. Harrison Chase do LangChain revela os 7 componentes fundamentais que todo sistema de agente confiável precisa, independentemente da stack."
tags: ["Agentes de IA", "Arquitetura de Sistemas", "LangChain", "Engenharia de IA", "Melhores Práticas"]
author: "Brandon"
featured: true
---

"Qual framework de agentes devo usar?"

Pergunta errada.

Harrison Chase, CEO do LangChain, acabou de jogar uma bomba de conhecimento que deveria reformular como pensamos sobre construção de agentes. Depois de analisar centenas de sistemas de agentes em produção, ele identificou 7 blocos de construção fundamentais que TODOS os agentes confiáveis compartilham.

O kicker? Não importa se você está usando LangChain, AutoGPT, CrewAI ou código puro. Esses blocos são universais.

## A Armadilha do Framework 🪤

Vamos enfrentar a realidade:

<Callout type="warning">
**A Verdade Inconveniente**: A maioria dos debates sobre frameworks de agentes é como discutir qual marca de martelo comprar quando você ainda não decidiu o que está construindo.
</Callout>

Harrison viu esse padrão repetidamente:
- Equipes gastam semanas avaliando frameworks
- Escolhem um baseado em hype/estrelas no GitHub
- Percebem que ainda precisam construir os mesmos componentes principais
- Acabam construindo metade de um framework customizado de qualquer jeito

Parada. Vamos focar no que realmente importa.

## Os 7 Blocos de Construção de Agentes Confiáveis 🏗️

<CodeExample
  title="A Arquitetura Universal de Agentes"
  language="yaml"
  code={`blocos_construcao_agente:
  1_modelos_base:
    - llm: "Cérebro do raciocínio"
    - embedding: "Compreensão semântica"
    - reranking: "Priorização de relevância"
  
  2_orquestracao:
    - agentic: "Tomada de decisão autônoma"
    - deterministico: "Fluxos de trabalho previsíveis"
    - hibrido: "Melhor dos dois mundos"
  
  3_design_prompt:
    - especifico_tarefa: "O que fazer"
    - formatacao_saida: "Como responder"
    - exemplos_contexto: "Como se comportar"
  
  4_recuperacao:
    - busca_vetorial: "Encontrar similar"
    - busca_palavras_chave: "Encontrar exato"
    - grafos_conhecimento: "Encontrar conectado"
  
  5_memoria:
    - dialogo: "Lembrar conversa"
    - tarefa: "Lembrar progresso"
    - conhecimento: "Lembrar aprendizados"
  
  6_ferramentas:
    - utilitarios: "Calculadora, data/hora"
    - integracao: "APIs, bancos de dados"
    - customizadas: "Lógica de negócio"
  
  7_guardrails:
    - seguranca: "Prevenir danos"
    - qualidade: "Garantir precisão"
    - compliance: "Seguir regras"`}
/>

Vamos detalhar cada um com exemplos do mundo real.

## Bloco 1: Modelos—Escolha Sua Potência 🧠

Harrison esclareceu: "Pare de tentar fazer um modelo fazer tudo. Use modelos especializados para tarefas especializadas."

<CodeExample
  title="Seleção de Modelo Estratégica"
  language="javascript"
  code={`class SeletorModeloInteligente {
  constructor() {
    // Diferentes modelos para diferentes trabalhos
    this.modelos = {
      raciocinio: 'gpt-4', // Caro mas inteligente
      classificacao: 'gpt-3.5-turbo', // Rápido e barato
      embeddings: 'text-embedding-3-small', // Eficiente
      reranking: 'cohere-rerank-v2', // Especializado
      codigo: 'claude-3-opus', // Melhor para programação
      multilingual: 'claude-3-sonnet' // Ótimo com idiomas
    };
  }
  
  async processar(tarefa) {
    // Escolher modelo baseado na tarefa
    switch(tarefa.tipo) {
      case 'decisao_complexa':
        return await this.usarModelo('raciocinio', tarefa);
        
      case 'filtrar_resultados':
        // Usar modelo barato para filtrar, caro para processar
        const candidatos = await this.usarModelo('classificacao', tarefa);
        return await this.usarModelo('raciocinio', candidatos);
        
      case 'busca_semantica':
        const embeddings = await this.usarModelo('embeddings', tarefa);
        return await this.usarModelo('reranking', embeddings);
        
      default:
        return await this.usarModelo('classificacao', tarefa);
    }
  }
}`}
/>

**Insight chave**: Usar GPT-4 para tudo é como usar uma Ferrari para entregar pizza—caro e desnecessário.

## Bloco 2: Orquestração—O Padrão de Controle 🎯

Este é onde a maioria das equipes se perde. Harrison identificou três padrões:

<CodeExample
  title="Padrões de Orquestração"
  language="python"
  code={`# Padrão 1: Totalmente Agêntico (Caótico mas Flexível)
class AgenteAutonomo:
    def executar(self, objetivo):
        while not objetivo_completo:
            acao = self.llm.decidir_proxima_acao(objetivo, historico)
            resultado = self.executar_acao(acao)
            historico.append(resultado)
            # Problema: Pode dar loops infinitos
            
# Padrão 2: Determinístico (Previsível mas Rígido)
class FluxoTrabalhoFixo:
    def executar(self, entrada):
        resultado1 = self.passo1(entrada)
        resultado2 = self.passo2(resultado1)
        return self.passo3(resultado2)
        # Problema: Não consegue se adaptar
        
# Padrão 3: Híbrido (Melhor Prática do LangChain)
class OrquestradorHibrido:
    def executar(self, objetivo):
        # Fluxo de trabalho determinístico de alto nível
        plano = self.criar_plano(objetivo)
        
        for passo in plano.passos:
            if passo.requer_julgamento:
                # Deixar agente decidir como executar
                resultado = self.execucao_agentiva(passo)
            else:
                # Usar lógica determinística
                resultado = self.execucao_fixa(passo)
                
            if resultado.requer_replanejamento:
                plano = self.adaptar_plano(plano, resultado)
                
        return self.compilar_resultados()`}
/>

Harrison revelou: "80% dos agentes de produção bem-sucedidos usam orquestração híbrida."

## Bloco 3: Design de Prompt—A Programação de Agentes 📝

Esqueça prompts genéricos. Harrison enfatizou especificidade extrema:

<CodeExample
  title="Sistema de Prompt de Nível de Produção"
  language="python"
  code={`class SistemaPromptProducao:
    def __init__(self):
        # Prompts base versionados
        self.prompts = {
            'analisador_vendas': {
                'v1.2': """Você é um analista de vendas para {company}.
                
CONTEXTO:
- Trimestre fiscal atual: {quarter}
- Meta de vendas: ${target}
- Produtos principais: {products}

SUA TAREFA:
1. Analisar dados de vendas fornecidos
2. Identificar tendências (positivas e negativas)
3. Sugerir ações específicas

FORMATO DE SAÍDA:
```json
{
  "resumo": "2-3 frases",
  "tendencias": [{"tipo": "positiva|negativa", "detalhe": "..."}],
  "acoes": [{"prioridade": "alta|media|baixa", "acao": "..."}]
}
```

EXEMPLOS:
{examples}

RESTRIÇÕES:
- Números devem ter precisão de 2 decimais
- Mencionar apenas produtos de {products}
- Ações devem ser implementáveis em 30 dias"""
            }
        }
    
    def gerar_prompt(self, tipo, contexto):
        # Injetar contexto dinâmico
        template = self.prompts[tipo][self.versao_ativa]
        
        # Adicionar exemplos específicos do domínio
        exemplos = self.buscar_exemplos_relevantes(tipo, contexto)
        
        # Formatar com variáveis
        return template.format(
            **contexto,
            examples=self.formatar_exemplos(exemplos)
        )`}
/>

**Sacada profunda**: "Seu prompt É seu código. Versione, teste e faça deploy como tal."

## Bloco 4: Recuperação—Encontrando Agulhas em Palheiros 🔍

Harrison foi direto: "RAG ruim mata mais agentes do que qualquer outra coisa."

<CodeExample
  title="Sistema de Recuperação Multicamadas"
  language="javascript"
  code={`class RecuperadorInteligente {
  constructor() {
    this.estrategias = {
      denso: new BuscaVetorial(),      // Busca semântica
      esparso: new BuscaBM25(),        // Busca por palavra-chave
      hibrido: new BuscaHibrida(),     // Combinar pontuações
      grafo: new BuscaGrafo(),         // Relações
      sql: new BuscaEstruturada()      // Dados exatos
    };
  }
  
  async recuperar(consulta, contexto) {
    // Analisar tipo de consulta
    const tipoConsulta = this.analisarConsulta(consulta);
    
    // Recuperação multicamadas
    let resultados = [];
    
    if (tipoConsulta.necessitaSemantica) {
      const semanticos = await this.estrategias.denso.buscar(consulta);
      resultados.push(...semanticos);
    }
    
    if (tipoConsulta.temPalavrasChaveEspecificas) {
      const exatos = await this.estrategias.esparso.buscar(consulta);
      resultados.push(...exatos);
    }
    
    if (tipoConsulta.necessitaContextoRelacional) {
      const relacionados = await this.estrategias.grafo.buscarRelacionados(
        consulta, 
        profundidade=2
      );
      resultados.push(...relacionados);
    }
    
    // Reranking inteligente
    const rerankeados = await this.reranker.classificar(
      consulta, 
      resultados,
      contexto
    );
    
    // Retornar top K com metadados
    return rerankeados.slice(0, contexto.k).map(r => ({
      conteudo: r.conteudo,
      pontuacao: r.pontuacao,
      fonte: r.fonte,
      tipo: r.tipo,
      confianca: this.calcularConfianca(r)
    }));
  }
}`}
/>

## Bloco 5: Memória—Dando Contexto aos Agentes 🧩

Harrison destacou três tipos de memória que todo agente precisa:

<CodeExample
  title="Sistema de Memória em Três Camadas"
  language="python"
  code={`class SistemaMemoriaCompleto:
    def __init__(self):
        # Memória de diálogo (curto prazo)
        self.dialogo = MemoriaDialogo(
            janela_max=50,  # Últimas 50 mensagens
            estrategia_resumo='progressiva'  # Resumir mensagens antigas
        )
        
        # Memória de tarefa (médio prazo)
        self.tarefa = MemoriaTarefa(
            estrutura={
                'objetivo_atual': None,
                'subtarefas_completas': [],
                'blockers': [],
                'decisoes_tomadas': [],
                'contexto_acumulado': {}
            }
        )
        
        # Memória de conhecimento (longo prazo)
        self.conhecimento = MemoriaConhecimento(
            backend='pgvector',
            estrategia_indexacao='hierarquica',
            politica_retencao='baseada_em_relevancia'
        )
    
    def atualizar(self, evento):
        # Rotear para memória apropriada
        if evento.tipo == 'mensagem_usuario':
            self.dialogo.adicionar(evento)
            
        elif evento.tipo == 'tarefa_progresso':
            self.tarefa.atualizar(evento)
            
        elif evento.tipo == 'aprendizado':
            # Extrair conhecimento generalizável
            conhecimento = self.extrair_conhecimento(evento)
            self.conhecimento.armazenar(conhecimento)
    
    def recuperar_contexto(self, consulta):
        return {
            'conversa_recente': self.dialogo.obter_relevante(consulta),
            'estado_tarefa': self.tarefa.obter_estado_atual(),
            'conhecimento_relevante': self.conhecimento.buscar(consulta, k=5)
        }`}
/>

**Ponto crítico**: "Memória sem estratégia de poda é apenas acumulação de lixo."

## Bloco 6: Ferramentas—Dando Mãos aos Agentes 🛠️

Harrison foi enfático: "Pare de criar ferramentas desnecessárias."

<CodeExample
  title="Design de Ferramentas Inteligente"
  language="typescript"
  code={`class GerenciadorFerramentas {
  constructor() {
    // Apenas ferramentas que realmente precisam ser ferramentas
    this.ferramentas = new Map();
    
    // NÃO faça ferramentas para estas:
    // ❌ Obter data atual (coloque no prompt)
    // ❌ Matemática básica (LLM pode fazer)
    // ❌ Formatação de string (desperdício)
    
    // FAÇA ferramentas para estas:
    // ✅ Chamadas de API externas
    // ✅ Consultas de banco de dados
    // ✅ Operações de arquivo
    // ✅ Cálculos complexos
  }
  
  registrarFerramenta(nome: string, config: ConfigFerramenta) {
    // Validar que a ferramenta é necessária
    if (this.podeSerFeitoNativamente(config)) {
      throw new Error(`${nome} deveria ser lógica inline, não ferramenta`);
    }
    
    this.ferramentas.set(nome, {
      // Metadados ricos para seleção de ferramenta
      descricao: config.descricao,
      parametros: config.parametros,
      exemplos: config.exemplos,
      quandoUsar: config.quandoUsar,
      quandoNaoUsar: config.quandoNaoUsar,
      
      // Implementação real
      executar: async (params) => {
        // Validação de entrada
        this.validar(params, config.parametros);
        
        // Execução com tratamento de erro
        try {
          const resultado = await config.implementacao(params);
          return { sucesso: true, data: resultado };
        } catch (erro) {
          return { 
            sucesso: false, 
            erro: erro.message,
            podeRetentar: this.ehRetentavel(erro)
          };
        }
      }
    });
  }
}`}
/>

## Bloco 7: Guardrails—Mantendo Agentes nos Trilhos 🛡️

O bloco final e mais crítico:

<CodeExample
  title="Sistema de Guardrails Abrangente"
  language="python"
  code={`class SistemaGuardrails:
    def __init__(self):
        self.verificadores = []
        
        # Guardrails de segurança
        self.adicionar_verificador(VerificadorInjecaoPrompt())
        self.adicionar_verificador(VerificadorPII())
        self.adicionar_verificador(VerificadorToxicidade())
        
        # Guardrails de qualidade
        self.adicionar_verificador(VerificadorAlucinacao())
        self.adicionar_verificador(VerificadorConsistencia())
        self.adicionar_verificador(VerificadorFormatoSaida())
        
        # Guardrails de negócio
        self.adicionar_verificador(VerificadorPoliticaEmpresa())
        self.adicionar_verificador(VerificadorLimitesCusto())
        self.adicionar_verificador(VerificadorSLA())
    
    async def verificar_entrada(self, entrada):
        for verificador in self.verificadores:
            if verificador.aplica_a_entrada:
                resultado = await verificador.verificar_entrada(entrada)
                if not resultado.passou:
                    return self.lidar_com_falha(resultado)
    
    async def verificar_saida(self, saida, contexto):
        for verificador in self.verificadores:
            if verificador.aplica_a_saida:
                resultado = await verificador.verificar_saida(saida, contexto)
                if not resultado.passou:
                    if resultado.pode_corrigir:
                        saida = await self.tentar_corrigir(saida, resultado)
                    else:
                        return self.lidar_com_falha(resultado)
        
        return saida
    
    def lidar_com_falha(self, resultado):
        # Registrar para análise
        self.logger.avisar(f"Guardrail acionado: {resultado}")
        
        # Retornar resposta segura
        return {
            'resposta': self.resposta_fallback,
            'razao': resultado.razao_amigavel_usuario,
            'metadados': {
                'guardrail_acionado': resultado.verificador,
                'gravidade': resultado.gravidade
            }
        }`}
/>

## Juntando Tudo: Arquitetura de Referência 🏛️

Harrison compartilhou esta arquitetura de referência do LangChain:

<CodeExample
  title="Arquitetura de Agente de Produção Completa"
  language="yaml"
  code={`arquitetura_agente_producao:
  camada_entrada:
    - validacao_entrada
    - classificacao_intencao
    - guardrails_seguranca
  
  camada_processamento:
    modelos:
      classificador: gpt-3.5-turbo
      raciocinador: gpt-4
      embedder: text-embedding-3
    
    orquestracao:
      tipo: hibrido
      fluxo_deterministico: 
        - analisar_consulta
        - recuperar_contexto
        - gerar_resposta
        - validar_saida
      
      decisoes_agentivas:
        - quando_buscar_mais_info
        - qual_ferramenta_usar
        - como_formatar_resposta
    
    memoria:
      dialogo: redis (TTL 24h)
      tarefa: postgres 
      conhecimento: pgvector
    
    recuperacao:
      estrategia: hibrida
      indices:
        - semantico: pgvector
        - palavra_chave: elasticsearch
        - estruturado: postgres
    
    ferramentas:
      - api_interna
      - calculadora_complexa
      - gerador_relatorios
  
  camada_saida:
    - formatacao_resposta
    - guardrails_qualidade
    - rastreamento_metricas
    - cache_resposta`}
/>

## Lições do Mundo Real do LangChain 🎓

### Lição 1: Comece Simples, Adicione Complexidade
"90% dos POCs falham porque tentam usar todos os 7 blocos perfeitamente desde o dia 1. Comece com 3-4, faça funcionar, depois adicione."

### Lição 2: Instrumentação é Obrigatória
"Se você não consegue ver o que seu agente está fazendo, não consegue melhorá-lo. LangSmith existe porque aprendemos isso da maneira difícil."

### Lição 3: Híbrido > Puro
"Agentes puramente autônomos são demos legais. Agentes híbridos são sistemas de produção."

### Lição 4: O Contexto é Rei
"Um agente medíocre com excelente recuperação supera um agente brilhante com RAG ruim."

## Seu Checklist de Implementação ✅

<Callout type="action">
**Semana 1-2: MVP com 4 Blocos**
- [ ] Escolha modelo principal (provavelmente GPT-3.5 para começar)
- [ ] Implemente orquestração básica (comece determinística)
- [ ] Escreva 3-5 prompts específicos de tarefa
- [ ] Adicione guardrails básicos de segurança

**Semana 3-4: Adicione Inteligência**
- [ ] Implemente recuperação básica (comece com busca vetorial)
- [ ] Adicione memória de diálogo
- [ ] Crie 2-3 ferramentas essenciais

**Mês 2: Endureça para Produção**
- [ ] Upgrade para orquestração híbrida
- [ ] Implemente todas as 3 camadas de memória
- [ ] Adicione guardrails completos
- [ ] Implemente monitoramento/observabilidade

**Mês 3: Otimize e Escale**
- [ ] Otimização de seleção de modelo
- [ ] Ajuste fino de recuperação
- [ ] Otimização de desempenho
- [ ] Testes de carga
</Callout>

## A Mentalidade Anti-Framework 🧠

As palavras finais de Harrison que deveriam estar gravadas em pedra:

"Frameworks são implementações opinativas desses 7 blocos. Uma vez que você entende os blocos, pode usar qualquer framework—ou nenhum—e ainda construir ótimos agentes."

O segredo não é escolher o framework perfeito. É entender os componentes fundamentais tão bem que você poderia construí-los do zero se precisasse.

<Callout type="insight">
**A Percepção Final**: Agentes confiáveis não vêm de frameworks mágicos. Eles vêm de implementar deliberadamente cada um desses 7 blocos de uma forma que se adeque ao seu caso de uso específico.

Pare de procurar balas de prata. Comece a construir com blocos fundamentais.
</Callout>

Agora pare de ler sobre frameworks e comece a construir. Seus agentes estão esperando.

*P.S. - Sim, Harrison é o CEO do LangChain e ainda está dizendo para não ficar obcecado com frameworks. Isso deveria te dizer algo.*