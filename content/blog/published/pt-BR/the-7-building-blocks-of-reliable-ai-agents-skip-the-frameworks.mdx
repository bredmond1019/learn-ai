---
title: "Os 7 Blocos de Constru√ß√£o de Agentes de IA Confi√°veis‚ÄîPule os Frameworks"
date: "2025-07-23"
excerpt: "Pare de debater frameworks. Comece a construir agentes que funcionam. Harrison Chase do LangChain revela os 7 componentes fundamentais que todo sistema de agente confi√°vel precisa, independentemente da stack."
tags: ["Agentes de IA", "Arquitetura de Sistemas", "LangChain", "Engenharia de IA", "Melhores Pr√°ticas"]
author: "Brandon"
featured: true
---

"Qual framework de agentes devo usar?"

Pergunta errada.

Harrison Chase, CEO do LangChain, acabou de jogar uma bomba de conhecimento que deveria reformular como pensamos sobre constru√ß√£o de agentes. Depois de analisar centenas de sistemas de agentes em produ√ß√£o, ele identificou 7 blocos de constru√ß√£o fundamentais que TODOS os agentes confi√°veis compartilham.

O kicker? N√£o importa se voc√™ est√° usando LangChain, AutoGPT, CrewAI ou c√≥digo puro. Esses blocos s√£o universais.

## A Armadilha do Framework ü™§

Vamos enfrentar a realidade:

<Callout type="warning">
**A Verdade Inconveniente**: A maioria dos debates sobre frameworks de agentes √© como discutir qual marca de martelo comprar quando voc√™ ainda n√£o decidiu o que est√° construindo.
</Callout>

Harrison viu esse padr√£o repetidamente:
- Equipes gastam semanas avaliando frameworks
- Escolhem um baseado em hype/estrelas no GitHub
- Percebem que ainda precisam construir os mesmos componentes principais
- Acabam construindo metade de um framework customizado de qualquer jeito

Parada. Vamos focar no que realmente importa.

## Os 7 Blocos de Constru√ß√£o de Agentes Confi√°veis üèóÔ∏è

### A Arquitetura Universal de Agentes

```yaml
blocos_construcao_agente:
  1_modelos_base:
    - llm: "C√©rebro do racioc√≠nio"
    - embedding: "Compreens√£o sem√¢ntica"
    - reranking: "Prioriza√ß√£o de relev√¢ncia"
  
  2_orquestracao:
    - agentic: "Tomada de decis√£o aut√¥noma"
    - deterministico: "Fluxos de trabalho previs√≠veis"
    - hibrido: "Melhor dos dois mundos"
  
  3_design_prompt:
    - especifico_tarefa: "O que fazer"
    - formatacao_saida: "Como responder"
    - exemplos_contexto: "Como se comportar"
  
  4_recuperacao:
    - busca_vetorial: "Encontrar similar"
    - busca_palavras_chave: "Encontrar exato"
    - grafos_conhecimento: "Encontrar conectado"
  
  5_memoria:
    - dialogo: "Lembrar conversa"
    - tarefa: "Lembrar progresso"
    - conhecimento: "Lembrar aprendizados"
  
  6_ferramentas:
    - utilitarios: "Calculadora, data/hora"
    - integracao: "APIs, bancos de dados"
    - customizadas: "L√≥gica de neg√≥cio"
  
  7_guardrails:
    - seguranca: "Prevenir danos"
    - qualidade: "Garantir precis√£o"
    - compliance: "Seguir regras"
```

Vamos detalhar cada um com exemplos do mundo real.

## Bloco 1: Modelos‚ÄîEscolha Sua Pot√™ncia üß†

Harrison esclareceu: "Pare de tentar fazer um modelo fazer tudo. Use modelos especializados para tarefas especializadas."

### Sele√ß√£o de Modelo Estrat√©gica

```javascript
class SeletorModeloInteligente {
  constructor() {
    // Diferentes modelos para diferentes trabalhos
    this.modelos = {
      raciocinio: 'gpt-4', // Caro mas inteligente
      classificacao: 'gpt-3.5-turbo', // R√°pido e barato
      embeddings: 'text-embedding-3-small', // Eficiente
      reranking: 'cohere-rerank-v2', // Especializado
      codigo: 'claude-3-opus', // Melhor para programa√ß√£o
      multilingual: 'claude-3-sonnet' // √ìtimo com idiomas
    };
  }
  
  async processar(tarefa) {
    // Escolher modelo baseado na tarefa
    switch(tarefa.tipo) {
      case 'decisao_complexa':
        return await this.usarModelo('raciocinio', tarefa);
        
      case 'filtrar_resultados':
        // Usar modelo barato para filtrar, caro para processar
        const candidatos = await this.usarModelo('classificacao', tarefa);
        return await this.usarModelo('raciocinio', candidatos);
        
      case 'busca_semantica':
        const embeddings = await this.usarModelo('embeddings', tarefa);
        return await this.usarModelo('reranking', embeddings);
        
      default:
        return await this.usarModelo('classificacao', tarefa);
    }
  }
}
```

**Insight chave**: Usar GPT-4 para tudo √© como usar uma Ferrari para entregar pizza‚Äîcaro e desnecess√°rio.

## Bloco 2: Orquestra√ß√£o‚ÄîO Padr√£o de Controle üéØ

Este √© onde a maioria das equipes se perde. Harrison identificou tr√™s padr√µes:

### Padr√µes de Orquestra√ß√£o

```python
# Padr√£o 1: Totalmente Ag√™ntico (Ca√≥tico mas Flex√≠vel)
class AgenteAutonomo:
    def executar(self, objetivo):
        while not objetivo_completo:
            acao = self.llm.decidir_proxima_acao(objetivo, historico)
            resultado = self.executar_acao(acao)
            historico.append(resultado)
            # Problema: Pode dar loops infinitos
            
# Padr√£o 2: Determin√≠stico (Previs√≠vel mas R√≠gido)
class FluxoTrabalhoFixo:
    def executar(self, entrada):
        resultado1 = self.passo1(entrada)
        resultado2 = self.passo2(resultado1)
        return self.passo3(resultado2)
        # Problema: N√£o consegue se adaptar
        
# Padr√£o 3: H√≠brido (Melhor Pr√°tica do LangChain)
class OrquestradorHibrido:
    def executar(self, objetivo):
        # Fluxo de trabalho determin√≠stico de alto n√≠vel
        plano = self.criar_plano(objetivo)
        
        for passo in plano.passos:
            if passo.requer_julgamento:
                # Deixar agente decidir como executar
                resultado = self.execucao_agentiva(passo)
            else:
                # Usar l√≥gica determin√≠stica
                resultado = self.execucao_fixa(passo)
                
            if resultado.requer_replanejamento:
                plano = self.adaptar_plano(plano, resultado)
                
        return self.compilar_resultados()
```

Harrison revelou: "80% dos agentes de produ√ß√£o bem-sucedidos usam orquestra√ß√£o h√≠brida."

## Bloco 3: Design de Prompt‚ÄîA Programa√ß√£o de Agentes üìù

Esque√ßa prompts gen√©ricos. Harrison enfatizou especificidade extrema:

### Sistema de Prompt de N√≠vel de Produ√ß√£o

```python
class SistemaPromptProducao:
    def __init__(self):
        # Prompts base versionados
        self.prompts = {
            'analisador_vendas': {
                'v1.2': """Voc√™ √© um analista de vendas para {company}.
                
CONTEXTO:
- Trimestre fiscal atual: {quarter}
- Meta de vendas: ${target}
- Produtos principais: {products}

SUA TAREFA:
1. Analisar dados de vendas fornecidos
2. Identificar tend√™ncias (positivas e negativas)
3. Sugerir a√ß√µes espec√≠ficas

FORMATO DE SA√çDA:
```json
{
  "resumo": "2-3 frases",
  "tendencias": [{"tipo": "positiva|negativa", "detalhe": "..."}],
  "acoes": [{"prioridade": "alta|media|baixa", "acao": "..."}]
}
```

EXEMPLOS:
\{examples\}

RESTRI√á√ïES:
- N√∫meros devem ter precis√£o de 2 decimais
- Mencionar apenas produtos de \{products\}
- A√ß√µes devem ser implement√°veis em 30 dias"""
            }
        }
    
    def gerar_prompt(self, tipo, contexto):
        # Injetar contexto din√¢mico
        template = self.prompts[tipo][self.versao_ativa]
        
        # Adicionar exemplos espec√≠ficos do dom√≠nio
        exemplos = self.buscar_exemplos_relevantes(tipo, contexto)
        
        # Formatar com vari√°veis
        return template.format(
            **contexto,
            examples=self.formatar_exemplos(exemplos)
        )
```

**Sacada profunda**: "Seu prompt √â seu c√≥digo. Versione, teste e fa√ßa deploy como tal."

## Bloco 4: Recupera√ß√£o‚ÄîEncontrando Agulhas em Palheiros üîç

Harrison foi direto: "RAG ruim mata mais agentes do que qualquer outra coisa."

### Sistema de Recupera√ß√£o Multicamadas

```javascript
class RecuperadorInteligente {
  constructor() {
    this.estrategias = {
      denso: new BuscaVetorial(),      // Busca sem√¢ntica
      esparso: new BuscaBM25(),        // Busca por palavra-chave
      hibrido: new BuscaHibrida(),     // Combinar pontua√ß√µes
      grafo: new BuscaGrafo(),         // Rela√ß√µes
      sql: new BuscaEstruturada()      // Dados exatos
    };
  }
  
  async recuperar(consulta, contexto) {
    // Analisar tipo de consulta
    const tipoConsulta = this.analisarConsulta(consulta);
    
    // Recupera√ß√£o multicamadas
    let resultados = [];
    
    if (tipoConsulta.necessitaSemantica) {
      const semanticos = await this.estrategias.denso.buscar(consulta);
      resultados.push(...semanticos);
    }
    
    if (tipoConsulta.temPalavrasChaveEspecificas) {
      const exatos = await this.estrategias.esparso.buscar(consulta);
      resultados.push(...exatos);
    }
    
    if (tipoConsulta.necessitaContextoRelacional) {
      const relacionados = await this.estrategias.grafo.buscarRelacionados(
        consulta, 
        profundidade=2
      );
      resultados.push(...relacionados);
    }
    
    // Reranking inteligente
    const rerankeados = await this.reranker.classificar(
      consulta, 
      resultados,
      contexto
    );
    
    // Retornar top K com metadados
    return rerankeados.slice(0, contexto.k).map(r => ({
      conteudo: r.conteudo,
      pontuacao: r.pontuacao,
      fonte: r.fonte,
      tipo: r.tipo,
      confianca: this.calcularConfianca(r)
    }));
  }
}
```

## Bloco 5: Mem√≥ria‚ÄîDando Contexto aos Agentes üß©

Harrison destacou tr√™s tipos de mem√≥ria que todo agente precisa:

### Sistema de Mem√≥ria em Tr√™s Camadas

```python
class SistemaMemoriaCompleto:
    def __init__(self):
        # Mem√≥ria de di√°logo (curto prazo)
        self.dialogo = MemoriaDialogo(
            janela_max=50,  # √öltimas 50 mensagens
            estrategia_resumo='progressiva'  # Resumir mensagens antigas
        )
        
        # Mem√≥ria de tarefa (m√©dio prazo)
        self.tarefa = MemoriaTarefa(
            estrutura={
                'objetivo_atual': None,
                'subtarefas_completas': [],
                'blockers': [],
                'decisoes_tomadas': [],
                'contexto_acumulado': {}
            }
        )
        
        # Mem√≥ria de conhecimento (longo prazo)
        self.conhecimento = MemoriaConhecimento(
            backend='pgvector',
            estrategia_indexacao='hierarquica',
            politica_retencao='baseada_em_relevancia'
        )
    
    def atualizar(self, evento):
        # Rotear para mem√≥ria apropriada
        if evento.tipo == 'mensagem_usuario':
            self.dialogo.adicionar(evento)
            
        elif evento.tipo == 'tarefa_progresso':
            self.tarefa.atualizar(evento)
            
        elif evento.tipo == 'aprendizado':
            # Extrair conhecimento generaliz√°vel
            conhecimento = self.extrair_conhecimento(evento)
            self.conhecimento.armazenar(conhecimento)
    
    def recuperar_contexto(self, consulta):
        return {
            'conversa_recente': self.dialogo.obter_relevante(consulta),
            'estado_tarefa': self.tarefa.obter_estado_atual(),
            'conhecimento_relevante': self.conhecimento.buscar(consulta, k=5)
        }
```

**Ponto cr√≠tico**: "Mem√≥ria sem estrat√©gia de poda √© apenas acumula√ß√£o de lixo."

## Bloco 6: Ferramentas‚ÄîDando M√£os aos Agentes üõ†Ô∏è

Harrison foi enf√°tico: "Pare de criar ferramentas desnecess√°rias."

### Design de Ferramentas Inteligente

```typescript
class GerenciadorFerramentas {
  constructor() {
    // Apenas ferramentas que realmente precisam ser ferramentas
    this.ferramentas = new Map();
    
    // N√ÉO fa√ßa ferramentas para estas:
    // ‚ùå Obter data atual (coloque no prompt)
    // ‚ùå Matem√°tica b√°sica (LLM pode fazer)
    // ‚ùå Formata√ß√£o de string (desperd√≠cio)
    
    // FA√áA ferramentas para estas:
    // ‚úÖ Chamadas de API externas
    // ‚úÖ Consultas de banco de dados
    // ‚úÖ Opera√ß√µes de arquivo
    // ‚úÖ C√°lculos complexos
  }
  
  registrarFerramenta(nome: string, config: ConfigFerramenta) {
    // Validar que a ferramenta √© necess√°ria
    if (this.podeSerFeitoNativamente(config)) {
      throw new Error(`${nome} deveria ser l√≥gica inline, n√£o ferramenta`);
    }
    
    this.ferramentas.set(nome, {
      // Metadados ricos para sele√ß√£o de ferramenta
      descricao: config.descricao,
      parametros: config.parametros,
      exemplos: config.exemplos,
      quandoUsar: config.quandoUsar,
      quandoNaoUsar: config.quandoNaoUsar,
      
      // Implementa√ß√£o real
      executar: async (params) => {
        // Valida√ß√£o de entrada
        this.validar(params, config.parametros);
        
        // Execu√ß√£o com tratamento de erro
        try {
          const resultado = await config.implementacao(params);
          return { sucesso: true, data: resultado };
        } catch (erro) {
          return { 
            sucesso: false, 
            erro: erro.message,
            podeRetentar: this.ehRetentavel(erro)
          };
        }
      }
    });
  }
}
```

## Bloco 7: Guardrails‚ÄîMantendo Agentes nos Trilhos üõ°Ô∏è

O bloco final e mais cr√≠tico:

### Sistema de Guardrails Abrangente

```python
class SistemaGuardrails:
    def __init__(self):
        self.verificadores = []
        
        # Guardrails de seguran√ßa
        self.adicionar_verificador(VerificadorInjecaoPrompt())
        self.adicionar_verificador(VerificadorPII())
        self.adicionar_verificador(VerificadorToxicidade())
        
        # Guardrails de qualidade
        self.adicionar_verificador(VerificadorAlucinacao())
        self.adicionar_verificador(VerificadorConsistencia())
        self.adicionar_verificador(VerificadorFormatoSaida())
        
        # Guardrails de neg√≥cio
        self.adicionar_verificador(VerificadorPoliticaEmpresa())
        self.adicionar_verificador(VerificadorLimitesCusto())
        self.adicionar_verificador(VerificadorSLA())
    
    async def verificar_entrada(self, entrada):
        for verificador in self.verificadores:
            if verificador.aplica_a_entrada:
                resultado = await verificador.verificar_entrada(entrada)
                if not resultado.passou:
                    return self.lidar_com_falha(resultado)
    
    async def verificar_saida(self, saida, contexto):
        for verificador in self.verificadores:
            if verificador.aplica_a_saida:
                resultado = await verificador.verificar_saida(saida, contexto)
                if not resultado.passou:
                    if resultado.pode_corrigir:
                        saida = await self.tentar_corrigir(saida, resultado)
                    else:
                        return self.lidar_com_falha(resultado)
        
        return saida
    
    def lidar_com_falha(self, resultado):
        # Registrar para an√°lise
        self.logger.avisar(f"Guardrail acionado: {resultado}")
        
        # Retornar resposta segura
        return {
            'resposta': self.resposta_fallback,
            'razao': resultado.razao_amigavel_usuario,
            'metadados': {
                'guardrail_acionado': resultado.verificador,
                'gravidade': resultado.gravidade
            }
        }
```

## Juntando Tudo: Arquitetura de Refer√™ncia üèõÔ∏è

Harrison compartilhou esta arquitetura de refer√™ncia do LangChain:

### Arquitetura de Agente de Produ√ß√£o Completa

```yaml
arquitetura_agente_producao:
  camada_entrada:
    - validacao_entrada
    - classificacao_intencao
    - guardrails_seguranca
  
  camada_processamento:
    modelos:
      classificador: gpt-3.5-turbo
      raciocinador: gpt-4
      embedder: text-embedding-3
    
    orquestracao:
      tipo: hibrido
      fluxo_deterministico: 
        - analisar_consulta
        - recuperar_contexto
        - gerar_resposta
        - validar_saida
      
      decisoes_agentivas:
        - quando_buscar_mais_info
        - qual_ferramenta_usar
        - como_formatar_resposta
    
    memoria:
      dialogo: redis (TTL 24h)
      tarefa: postgres 
      conhecimento: pgvector
    
    recuperacao:
      estrategia: hibrida
      indices:
        - semantico: pgvector
        - palavra_chave: elasticsearch
        - estruturado: postgres
    
    ferramentas:
      - api_interna
      - calculadora_complexa
      - gerador_relatorios
  
  camada_saida:
    - formatacao_resposta
    - guardrails_qualidade
    - rastreamento_metricas
    - cache_resposta
```

## Li√ß√µes do Mundo Real do LangChain üéì

### Li√ß√£o 1: Comece Simples, Adicione Complexidade
"90% dos POCs falham porque tentam usar todos os 7 blocos perfeitamente desde o dia 1. Comece com 3-4, fa√ßa funcionar, depois adicione."

### Li√ß√£o 2: Instrumenta√ß√£o √© Obrigat√≥ria
"Se voc√™ n√£o consegue ver o que seu agente est√° fazendo, n√£o consegue melhor√°-lo. LangSmith existe porque aprendemos isso da maneira dif√≠cil."

### Li√ß√£o 3: H√≠brido > Puro
"Agentes puramente aut√¥nomos s√£o demos legais. Agentes h√≠bridos s√£o sistemas de produ√ß√£o."

### Li√ß√£o 4: O Contexto √© Rei
"Um agente med√≠ocre com excelente recupera√ß√£o supera um agente brilhante com RAG ruim."

## Seu Checklist de Implementa√ß√£o ‚úÖ

<Callout type="success">
**Semana 1-2: MVP com 4 Blocos**
- [ ] Escolha modelo principal (provavelmente GPT-3.5 para come√ßar)
- [ ] Implemente orquestra√ß√£o b√°sica (comece determin√≠stica)
- [ ] Escreva 3-5 prompts espec√≠ficos de tarefa
- [ ] Adicione guardrails b√°sicos de seguran√ßa

**Semana 3-4: Adicione Intelig√™ncia**
- [ ] Implemente recupera√ß√£o b√°sica (comece com busca vetorial)
- [ ] Adicione mem√≥ria de di√°logo
- [ ] Crie 2-3 ferramentas essenciais

**M√™s 2: Endure√ßa para Produ√ß√£o**
- [ ] Upgrade para orquestra√ß√£o h√≠brida
- [ ] Implemente todas as 3 camadas de mem√≥ria
- [ ] Adicione guardrails completos
- [ ] Implemente monitoramento/observabilidade

**M√™s 3: Otimize e Escale**
- [ ] Otimiza√ß√£o de sele√ß√£o de modelo
- [ ] Ajuste fino de recupera√ß√£o
- [ ] Otimiza√ß√£o de desempenho
- [ ] Testes de carga
</Callout>

## A Mentalidade Anti-Framework üß†

As palavras finais de Harrison que deveriam estar gravadas em pedra:

"Frameworks s√£o implementa√ß√µes opinativas desses 7 blocos. Uma vez que voc√™ entende os blocos, pode usar qualquer framework‚Äîou nenhum‚Äîe ainda construir √≥timos agentes."

O segredo n√£o √© escolher o framework perfeito. √â entender os componentes fundamentais t√£o bem que voc√™ poderia constru√≠-los do zero se precisasse.

<Callout type="info">
**A Percep√ß√£o Final**: Agentes confi√°veis n√£o v√™m de frameworks m√°gicos. Eles v√™m de implementar deliberadamente cada um desses 7 blocos de uma forma que se adeque ao seu caso de uso espec√≠fico.

Pare de procurar balas de prata. Comece a construir com blocos fundamentais.
</Callout>

Agora pare de ler sobre frameworks e comece a construir. Seus agentes est√£o esperando.

*P.S. - Sim, Harrison √© o CEO do LangChain e ainda est√° dizendo para n√£o ficar obcecado com frameworks. Isso deveria te dizer algo.*