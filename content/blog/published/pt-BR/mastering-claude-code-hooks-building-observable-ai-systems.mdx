---
title: "Dominando Claude Code Hooks: Construindo Sistemas de IA Observ√°veis"
date: "2025-07-23"
excerpt: "Aprenda como os 6 hooks de ciclo de vida do Claude Code transformam agentes de IA de caixas-pretas em sistemas totalmente observ√°veis e control√°veis. Do b√°sico aos padr√µes avan√ßados de produ√ß√£o."
tags: ["Claude Code", "Hooks", "Observabilidade", "Arquitetura de IA", "Engenharia de Sistemas"]
author: "Brandon"
featured: true
---

"Claude est√° prestes a executar `rm -rf /`. Voc√™ quer permitir isso?"

Essa notifica√ß√£o salvou o projeto de algu√©m ontem. E √© exatamente por isso que os hooks do Claude Code s√£o revolucion√°rios.

Enquanto todos falam sobre prompts e modelos, os verdadeiros construtores descobriram o segredo: hooks transformam agentes de IA imprevis√≠veis em sistemas de produ√ß√£o confi√°veis. Depois de assistir Dan Shipper demonstrar como usa hooks para controle total sobre o Claude Code, percebi que isso n√£o √© apenas uma funcionalidade‚Äî√© a arquitetura fundamental para IA confi√°vel.

## O Problema da Caixa-Preta üé≠

Vamos ser honestos: dar a uma IA acesso ao seu sistema de arquivos √© aterrorizante. √â como entregar as chaves do seu carro para algu√©m usando uma venda e dizer "dirija com cuidado!"

<Callout type="warning">
**O Paradoxo da IA**: Queremos que a IA seja poderosa o suficiente para automatizar trabalho complexo, mas segura o suficiente para n√£o destruir tudo no processo.
</Callout>

Hooks resolvem esse paradoxo dando a voc√™ pontos de intercepta√ß√£o em cada est√°gio cr√≠tico da execu√ß√£o da IA. Pense neles como pontos de verifica√ß√£o de seguran√ßa que transformam um agente rebelde em um assistente confi√°vel.

## Os 6 Hooks Que Mudam Tudo ü™ù

O Claude Code fornece seis hooks de ciclo de vida, cada um servindo a um prop√≥sito crucial:

<CodeExample
  title="Os 6 Hooks de Ciclo de Vida do Claude Code"
  language="yaml"
  code={`hooks:
  1. pre-prompt:
     quando: "Antes da IA processar sua solicita√ß√£o"
     use_para: "Validar/modificar entrada, adicionar contexto"
     
  2. pre-tool-use:
     quando: "Antes da IA executar qualquer ferramenta"
     use_para: "Aprovar/rejeitar a√ß√µes, modificar par√¢metros"
     
  3. post-tool-use:
     quando: "Ap√≥s a execu√ß√£o da ferramenta"
     use_para: "Registrar resultados, acionar a√ß√µes secund√°rias"
     
  4. notification:
     quando: "Baseado em condi√ß√µes customizadas"
     use_para: "Alertar sobre eventos importantes"
     
  5. stop:
     quando: "Execu√ß√£o sendo interrompida"
     use_para: "Limpeza, salvar estado"
     
  6. pre-compact:
     quando: "Antes da compacta√ß√£o do contexto"
     use_para: "Preservar informa√ß√µes cr√≠ticas"`}
/>

Mas aqui est√° o que a documenta√ß√£o n√£o diz: esses hooks n√£o s√£o apenas sobre seguran√ßa‚Äîeles s√£o sobre transformar IA em engenharia de software real.

## Hook Pre-Prompt: Seu Guardi√£o de Contexto üõ°Ô∏è

O hook pre-prompt √© executado antes que o Claude processe qualquer solicita√ß√£o. Dan o usa brilhantemente para injetar contexto que o Claude n√£o saberia de outra forma:

<CodeExample
  title="Hook Pre-Prompt em A√ß√£o"
  language="javascript"
  code={`// Exemplo de .claude/hooks/pre-prompt.js
export default async function prePromptHook(prompt) {
  // Adicionar contexto do projeto
  const projectContext = await loadProjectContext();
  
  // Verifica√ß√µes de seguran√ßa
  if (containsSensitivePatterns(prompt)) {
    return {
      error: "Detectado padr√£o potencialmente perigoso",
      suggestion: "Reformule sem incluir credenciais"
    };
  }
  
  // Enriquecer com metadados
  return {
    prompt: prompt,
    context: {
      projectType: projectContext.type,
      dependencies: projectContext.deps,
      recentErrors: getRecentErrors(),
      userPreferences: getUserPrefs()
    }
  };
}`}
/>

**Casos de Uso Matadores**:
- Adicionar automaticamente conven√ß√µes do projeto
- Injetar logs de erros recentes para melhor depura√ß√£o
- Incluir prefer√™ncias espec√≠ficas do usu√°rio
- Validar solicita√ß√µes contra pol√≠ticas da empresa

## Hook Pre-Tool-Use: Seu Firewall de Execu√ß√£o üö¶

Este √© o her√≥i da nossa hist√≥ria de abertura. Antes que o Claude execute QUALQUER ferramenta, este hook lhe d√° poder de veto:

<CodeExample
  title="Prevenindo Desastres com Pre-Tool-Use"
  language="javascript"
  code={`// Salvando voc√™ de comandos destrutivos
export default async function preToolUseHook(tool, args) {
  const dangerousPatterns = [
    /rm\s+-rf\s+\//,
    /DROP\s+DATABASE/i,
    /format\s+[cC]:/,
    /:(){ :|:& };:/  // Fork bomb!
  ];
  
  if (tool === 'bash') {
    const command = args.command;
    
    // Verificar padr√µes perigosos
    for (const pattern of dangerousPatterns) {
      if (pattern.test(command)) {
        return {
          action: 'deny',
          reason: `Comando perigoso detectado: ${pattern}`,
          notification: {
            title: 'Comando Bloqueado',
            message: `Claude tentou executar: ${command}`,
            type: 'error'
          }
        };
      }
    }
    
    // Aprovar com logging
    console.log(`[AUDITORIA] Executando: ${command}`);
    return { action: 'allow' };
  }
}`}
/>

Dan compartilhou como isso salvou seu bacon v√°rias vezes: "Claude uma vez tentou 'otimizar' meu projeto deletando todos os arquivos de teste. O hook pre-tool-use pegou isso e me perguntou primeiro."

## Hook Post-Tool-Use: Seu Sistema Nervoso üß†

Ap√≥s a execu√ß√£o de cada ferramenta, este hook permite que voc√™ reaja aos resultados:

<CodeExample
  title="Criando Sistemas Reativos com Post-Tool-Use"
  language="javascript"
  code={`export default async function postToolUseHook(tool, args, result) {
  // Rastrear todas as opera√ß√µes de arquivo
  if (tool === 'write_file') {
    await updateFileIndex(args.path, result.content);
    
    // Acionar a√ß√µes baseadas em tipo de arquivo
    if (args.path.endsWith('.test.js')) {
      await queueTestRun(args.path);
    }
    
    if (args.path.includes('/api/')) {
      await regenerateAPIDocs();
    }
  }
  
  // Monitorar sa√∫de da build
  if (tool === 'bash' && args.command.includes('npm run build')) {
    if (result.exitCode !== 0) {
      await notifyBuildFailure(result.stderr);
      await suggestFixes(result.stderr);
    }
  }
  
  // Coletar m√©tricas
  await trackMetrics({
    tool,
    duration: result.duration,
    success: !result.error,
    timestamp: Date.now()
  });
}`}
/>

## Hook de Notifica√ß√£o: Seu Centro de Comando üì°

Notifica√ß√µes n√£o s√£o apenas sobre erros‚Äîs√£o sobre manter voc√™ informado:

<CodeExample
  title="Sistema de Notifica√ß√£o Inteligente"
  language="javascript"
  code={`// Sistema de notifica√ß√£o baseado em contexto
export function setupNotifications() {
  // Marcos de progresso
  on('files_modified', (count) => {
    if (count > 10) {
      notify({
        title: 'Refatora√ß√£o Principal em Andamento',
        message: `Claude modificou ${count} arquivos`,
        actions: ['Ver mudan√ßas', 'Pausar execu√ß√£o']
      });
    }
  });
  
  // Alertas de seguran√ßa
  on('sensitive_file_access', (file) => {
    notify({
      title: 'Acesso a Arquivo Sens√≠vel',
      message: `Claude est√° acessando: ${file}`,
      type: 'warning',
      requiresResponse: true
    });
  });
  
  // Atualiza√ß√µes de desempenho
  on('long_running_operation', (operation) => {
    notify({
      title: 'Opera√ß√£o Demorada',
      message: `${operation} est√° levando mais que o esperado`,
      progress: operation.progress
    });
  });
}`}
/>

## Hook Stop: Seu Graceful Shutdown üõ¨

Quando as coisas s√£o interrompidas (e ser√£o), este hook garante uma aterrissagem suave:

<CodeExample
  title="Tratamento Gracioso de Interrup√ß√µes"
  language="javascript"
  code={`export default async function stopHook(reason) {
  console.log(`Parando execu√ß√£o: ${reason}`);
  
  // Salvar estado para retomada
  await saveExecutionState({
    timestamp: Date.now(),
    reason,
    completedTasks: getCompletedTasks(),
    pendingTasks: getPendingTasks(),
    lastSuccessfulOperation: getLastOperation()
  });
  
  // Limpar recursos
  await cleanupTempFiles();
  await closeOpenConnections();
  
  // Gerar relat√≥rio de resumo
  const summary = await generateExecutionSummary();
  await writeFile('.claude/last-run-summary.md', summary);
  
  // Notificar se cr√≠tico
  if (reason === 'error' || reason === 'timeout') {
    await sendAlert({
      title: 'Execu√ß√£o do Claude Interrompida',
      summary,
      resumable: true
    });
  }
}`}
/>

## Hook Pre-Compact: Seu Preservador de Mem√≥ria üíæ

Este √© o hook secreto que Dan chama de "game-changer para projetos longos":

<CodeExample
  title="Preservando Contexto Cr√≠tico Durante Compacta√ß√£o"
  language="javascript"
  code={`export default async function preCompactHook(context) {
  // Identificar informa√ß√µes cr√≠ticas para preservar
  const criticalInfo = {
    projectGoals: context.projectGoals,
    keyDecisions: extractKeyDecisions(context),
    errorPatterns: getRecurringErrors(context),
    userCorrections: getUserCorrections(context),
    
    // Sempre lembrar destes
    doNotDelete: [
      'Arquitetura principal decidida em...',
      'Usu√°rio prefere TypeScript sobre JavaScript',
      'Evitar modificar arquivos de teste legados'
    ]
  };
  
  // Comprimir informa√ß√µes menos cr√≠ticas
  const compressible = identifyCompressibleContent(context);
  
  return {
    preserve: criticalInfo,
    compress: compressible,
    strategy: 'progressive'  // Manter detalhes recentes, comprimir antigos
  };
}`}
/>

## Padr√µes Avan√ßados: Orquestrando Hooks üéº

O verdadeiro poder vem da combina√ß√£o de hooks em sistemas coerentes:

### Padr√£o 1: O Pipeline de Valida√ß√£o

<CodeExample
  title="Pipeline de Valida√ß√£o Multi-Etapas"
  language="javascript"
  code={`// Validar ‚Üí Executar ‚Üí Verificar ‚Üí Relatar
class ValidationPipeline {
  async prePrompt(prompt) {
    const validation = await this.validateRequest(prompt);
    if (!validation.valid) {
      throw new ValidationError(validation.errors);
    }
    return this.enrichWithContext(prompt);
  }
  
  async preToolUse(tool, args) {
    // Verifica√ß√µes espec√≠ficas da ferramenta
    const policy = await this.getToolPolicy(tool);
    return policy.evaluate(args);
  }
  
  async postToolUse(tool, args, result) {
    // Verificar resultados contra expectativas
    const expected = await this.getExpectedOutcome(tool, args);
    if (!this.matchesExpectation(result, expected)) {
      await this.triggerRemediation(tool, args, result);
    }
  }
}`}
/>

### Padr√£o 2: O Observador de Sistema

<CodeExample
  title="Observabilidade Completa do Sistema"
  language="javascript"
  code={`// Rastrear tudo, entender padr√µes, melhorar com o tempo
class SystemObserver {
  constructor() {
    this.metrics = new MetricsCollector();
    this.patterns = new PatternRecognizer();
    this.optimizer = new PerformanceOptimizer();
  }
  
  async observe(hookType, data) {
    // Coletar m√©tricas
    await this.metrics.record(hookType, data);
    
    // Reconhecer padr√µes
    const patterns = await this.patterns.analyze(hookType, data);
    
    // Sugerir otimiza√ß√µes
    if (patterns.inefficiency) {
      await this.optimizer.suggest(patterns);
    }
    
    // Transmitir para dashboard
    await this.broadcast({
      hook: hookType,
      data,
      patterns,
      metrics: this.metrics.current()
    });
  }
}`}
/>

## Aplica√ß√µes do Mundo Real üåç

Dan compartilhou v√°rios casos de uso em produ√ß√£o onde hooks fizeram a diferen√ßa:

### 1. Conformidade Automatizada
```javascript
// Garantir que todo c√≥digo segue os padr√µes da empresa
preToolUse: async (tool, args) => {
  if (tool === 'write_file' && args.path.endsWith('.js')) {
    args.content = await enforceCodeStandards(args.content);
  }
}
```

### 2. Otimiza√ß√£o de Custos
```javascript
// Prevenir opera√ß√µes caras de IA
prePrompt: async (prompt) => {
  const estimatedCost = await estimateAICost(prompt);
  if (estimatedCost > threshold) {
    return requestApproval(estimatedCost);
  }
}
```

### 3. Integra√ß√£o Cont√≠nua
```javascript
// Acionar pipelines de CI/CD automaticamente
postToolUse: async (tool, args, result) => {
  if (tool === 'git_commit') {
    await triggerCIPipeline(result.commitHash);
  }
}
```

## Melhores Pr√°ticas de Hooks üìã

Ap√≥s construir v√°rios sistemas com hooks, aqui est√£o os padr√µes vencedores:

### 1. Mantenha Hooks Focados
Cada hook deve ter uma responsabilidade clara. N√£o tente fazer tudo em um √∫nico hook.

### 2. Falhe Graciosamente
Hooks n√£o devem quebrar o fluxo de execu√ß√£o a menos que seja cr√≠tico:

```javascript
try {
  await riskyOperation();
} catch (error) {
  console.warn('Hook warning:', error);
  // Continuar execu√ß√£o com fallback
}
```

### 3. Use Composi√ß√£o
Construa hooks complexos a partir de fun√ß√µes menores e test√°veis:

```javascript
export default compose(
  withLogging,
  withMetrics,
  withValidation,
  actualHookLogic
);
```

### 4. Considere Desempenho
Hooks s√£o executados frequentemente‚Äîmantenha-os r√°pidos:

```javascript
// Bom: Opera√ß√µes ass√≠ncronas n√£o-bloqueantes
await Promise.all([
  logAsync(data),
  metricsAsync(data)
]);

// Ruim: Opera√ß√µes s√≠ncronas sequenciais
logSync(data);
metricsSync(data);
```

## Seu Kit de Ferramentas de Hooks üß∞

Pronto para implementar hooks? Aqui est√° seu kit inicial:

<CodeExample
  title="Template de Configura√ß√£o de Hooks"
  language="javascript"
  code={`// .claude/hooks/index.js
import { SecurityGuard } from './security';
import { PerformanceMonitor } from './performance';
import { ContextEnricher } from './context';
import { NotificationCenter } from './notifications';

export default {
  'pre-prompt': async (prompt) => {
    return await ContextEnricher.enrich(prompt);
  },
  
  'pre-tool-use': async (tool, args) => {
    return await SecurityGuard.validate(tool, args);
  },
  
  'post-tool-use': async (tool, args, result) => {
    await PerformanceMonitor.track(tool, result);
  },
  
  'notification': NotificationCenter.handle,
  
  'stop': async (reason) => {
    await cleanup(reason);
  },
  
  'pre-compact': async (context) => {
    return await preserveCriticalContext(context);
  }
};`}
/>

<Callout type="action">
**Pr√≥ximos Passos**: 
1. Comece com um hook pre-tool-use b√°sico para seguran√ßa
2. Adicione logging post-tool-use para observabilidade
3. Implemente notifica√ß√µes para eventos importantes
4. Evolua para padr√µes mais complexos conforme necess√°rio

Lembre-se: Hooks transformam Claude Code de uma ferramenta poderosa em um sistema de produ√ß√£o confi√°vel.
</Callout>

## O Futuro dos Hooks üîÆ

Dan deu uma dica do que est√° por vir: "Imagine hooks que aprendem com cada execu√ß√£o, se adaptando automaticamente aos seus padr√µes e prefer√™ncias."

Estamos caminhando para:
- Hooks auto-otimizantes baseados em m√©tricas
- Composi√ß√£o visual de hooks para n√£o-programadores
- Hooks marketplace para solu√ß√µes pr√©-constru√≠das
- Hooks com IA que escrevem outros hooks

Os hooks de hoje s√£o apenas o come√ßo. Eles s√£o a base sobre a qual construiremos a pr√≥xima gera√ß√£o de sistemas de IA‚Äîsistemas que n√£o s√£o apenas poderosos, mas tamb√©m observ√°veis, control√°veis e confi√°veis.

Bem-vindo ao desenvolvimento de IA observ√°vel. Seus agentes nunca mais ser√£o caixas-pretas.